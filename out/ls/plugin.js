var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// node_modules/@sqltools/base-driver/dist/lib/factory.js
var require_factory = __commonJS({
  "node_modules/@sqltools/base-driver/dist/lib/factory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var queryFactory2 = (pieces, ...placeholders) => {
      function queryConstructor(params = {}) {
        return pieces.reduce((q, piece, index) => {
          const ph = placeholders[index];
          q += piece.replace(/\r?\n\s+/g, " ");
          if (typeof ph !== "undefined") {
            q += typeof ph !== "function" ? ph : ph(params);
          }
          return q;
        }, "").trim();
      }
      queryConstructor.raw = pieces.reduce((q, piece, index) => {
        const ph = placeholders[index];
        q += piece.replace(/\r?\n\s+/g, " ");
        if (typeof ph !== "undefined") {
          q += "${" + ph.toString() + "}";
        }
        return q;
      }, "").trim();
      return queryConstructor;
    };
    exports.default = queryFactory2;
  }
});

// node_modules/@sqltools/types/index.js
var require_types = __commonJS({
  "node_modules/@sqltools/types/index.js"(exports, module2) {
    var ContextValue3 = {
      "CONNECTION": "connection",
      "CONNECTED_CONNECTION": "connectedConnection",
      "COLUMN": "connection.column",
      "FUNCTION": "connection.function",
      "SCHEMA": "connection.schema",
      "RESOURCE_GROUP": "connection.resource_group",
      "DATABASE": "connection.database",
      "TABLE": "connection.table",
      "VIEW": "connection.view",
      "MATERIALIZED_VIEW": "connection.materializedView",
      "NO_CHILD": "NO_CHILD",
      "KEYWORDS": "KEYWORDS"
    };
    Object.freeze(ContextValue3);
    module2.exports = {
      ContextValue: ContextValue3
    };
  }
});

// node_modules/strip-comments/lib/compile.js
var require_compile = __commonJS({
  "node_modules/strip-comments/lib/compile.js"(exports, module2) {
    "use strict";
    var compile = (cst, options = {}) => {
      const keepProtected = options.safe === true || options.keepProtected === true;
      let firstSeen = false;
      const walk = (node, parent) => {
        let output = "";
        let inner;
        let lines;
        for (const child of node.nodes) {
          switch (child.type) {
            case "block":
              if (options.first && firstSeen === true) {
                output += walk(child, node);
                break;
              }
              if (options.preserveNewlines === true) {
                inner = walk(child, node);
                lines = inner.split("\n");
                output += "\n".repeat(lines.length - 1);
                break;
              }
              if (keepProtected === true && child.protected === true) {
                output += walk(child, node);
                break;
              }
              firstSeen = true;
              break;
            case "line":
              if (options.first && firstSeen === true) {
                output += child.value;
                break;
              }
              if (keepProtected === true && child.protected === true) {
                output += child.value;
              }
              firstSeen = true;
              break;
            case "open":
            case "close":
            case "text":
            case "newline":
            default: {
              output += child.value || "";
              break;
            }
          }
        }
        return output;
      };
      return walk(cst);
    };
    module2.exports = compile;
  }
});

// node_modules/strip-comments/lib/Node.js
var require_Node = __commonJS({
  "node_modules/strip-comments/lib/Node.js"(exports, module2) {
    "use strict";
    var Node = class {
      constructor(node) {
        this.type = node.type;
        if (node.value)
          this.value = node.value;
        if (node.match)
          this.match = node.match;
        this.newline = node.newline || "";
      }
      get protected() {
        return Boolean(this.match) && this.match[1] === "!";
      }
    };
    var Block = class extends Node {
      constructor(node) {
        super(node);
        this.nodes = node.nodes || [];
      }
      push(node) {
        this.nodes.push(node);
      }
      get protected() {
        return this.nodes.length > 0 && this.nodes[0].protected === true;
      }
    };
    module2.exports = { Node, Block };
  }
});

// node_modules/strip-comments/lib/languages.js
var require_languages = __commonJS({
  "node_modules/strip-comments/lib/languages.js"(exports) {
    "use strict";
    exports.ada = { LINE_REGEX: /^--.*/ };
    exports.apl = { LINE_REGEX: /^‚çù.*/ };
    exports.applescript = {
      BLOCK_OPEN_REGEX: /^\(\*/,
      BLOCK_CLOSE_REGEX: /^\*\)/
    };
    exports.csharp = {
      LINE_REGEX: /^\/\/.*/
    };
    exports.haskell = {
      BLOCK_OPEN_REGEX: /^\{-/,
      BLOCK_CLOSE_REGEX: /^-\}/,
      LINE_REGEX: /^--.*/
    };
    exports.html = {
      BLOCK_OPEN_REGEX: /^\n*<!--(?!-?>)/,
      BLOCK_CLOSE_REGEX: /^(?<!(?:<!-))-->/,
      BLOCK_CLOSE_LOOSE_REGEX: /^(?<!(?:<!-))--\s*>/,
      BLOCK_CLOSE_STRICT_NEWLINE_REGEX: /^(?<!(?:<!-))-->(\s*\n+|\n*)/,
      BLOCK_CLOSE_STRICT_LOOSE_REGEX: /^(?<!(?:<!-))--\s*>(\s*\n+|\n*)/
    };
    exports.javascript = {
      BLOCK_OPEN_REGEX: /^\/\*\*?(!?)/,
      BLOCK_CLOSE_REGEX: /^\*\/(\n?)/,
      LINE_REGEX: /^\/\/(!?).*/
    };
    exports.lua = {
      BLOCK_OPEN_REGEX: /^--\[\[/,
      BLOCK_CLOSE_REGEX: /^\]\]/,
      LINE_REGEX: /^--.*/
    };
    exports.matlab = {
      BLOCK_OPEN_REGEX: /^%{/,
      BLOCK_CLOSE_REGEX: /^%}/,
      LINE_REGEX: /^%.*/
    };
    exports.perl = {
      LINE_REGEX: /^#.*/
    };
    exports.php = {
      ...exports.javascript,
      LINE_REGEX: /^(#|\/\/).*?(?=\?>|\n)/
    };
    exports.python = {
      BLOCK_OPEN_REGEX: /^"""/,
      BLOCK_CLOSE_REGEX: /^"""/,
      LINE_REGEX: /^#.*/
    };
    exports.ruby = {
      BLOCK_OPEN_REGEX: /^=begin/,
      BLOCK_CLOSE_REGEX: /^=end/,
      LINE_REGEX: /^#.*/
    };
    exports.shebang = exports.hashbang = {
      LINE_REGEX: /^#!.*/
    };
    exports.c = exports.javascript;
    exports.csharp = exports.javascript;
    exports.css = exports.javascript;
    exports.java = exports.javascript;
    exports.js = exports.javascript;
    exports.less = exports.javascript;
    exports.pascal = exports.applescript;
    exports.ocaml = exports.applescript;
    exports.sass = exports.javascript;
    exports.sql = exports.ada;
    exports.swift = exports.javascript;
    exports.ts = exports.javascript;
    exports.typscript = exports.javascript;
    exports.xml = exports.html;
  }
});

// node_modules/strip-comments/lib/parse.js
var require_parse = __commonJS({
  "node_modules/strip-comments/lib/parse.js"(exports, module2) {
    "use strict";
    var { Node, Block } = require_Node();
    var languages = require_languages();
    var constants = {
      ESCAPED_CHAR_REGEX: /^\\./,
      QUOTED_STRING_REGEX: /^(['"`])((?:\\.|[^\1])+?)(\1)/,
      NEWLINE_REGEX: /^\r*\n/
    };
    var parse = (input, options = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected input to be a string");
      }
      const cst = new Block({ type: "root", nodes: [] });
      const stack = [cst];
      const name = (options.language || "javascript").toLowerCase();
      const lang = languages[name];
      if (typeof lang === "undefined") {
        throw new Error(`Language "${name}" is not supported by strip-comments`);
      }
      const { LINE_REGEX, BLOCK_OPEN_REGEX, BLOCK_CLOSE_REGEX } = lang;
      let block = cst;
      let remaining = input;
      let token;
      let prev;
      const source = [BLOCK_OPEN_REGEX, BLOCK_CLOSE_REGEX].filter(Boolean);
      let tripleQuotes = false;
      if (source.every((regex) => regex.source === '^"""')) {
        tripleQuotes = true;
      }
      const consume = (value = remaining[0] || "") => {
        remaining = remaining.slice(value.length);
        return value;
      };
      const scan = (regex, type = "text") => {
        const match = regex.exec(remaining);
        if (match) {
          consume(match[0]);
          return { type, value: match[0], match };
        }
      };
      const push = (node) => {
        if (prev && prev.type === "text" && node.type === "text") {
          prev.value += node.value;
          return;
        }
        block.push(node);
        if (node.nodes) {
          stack.push(node);
          block = node;
        }
        prev = node;
      };
      const pop = () => {
        if (block.type === "root") {
          throw new SyntaxError("Unclosed block comment");
        }
        stack.pop();
        block = stack[stack.length - 1];
      };
      while (remaining !== "") {
        if (token = scan(constants.ESCAPED_CHAR_REGEX, "text")) {
          push(new Node(token));
          continue;
        }
        if (block.type !== "block" && (!prev || !/\w$/.test(prev.value)) && !(tripleQuotes && remaining.startsWith('"""'))) {
          if (token = scan(constants.QUOTED_STRING_REGEX, "text")) {
            push(new Node(token));
            continue;
          }
        }
        if (token = scan(constants.NEWLINE_REGEX, "newline")) {
          push(new Node(token));
          continue;
        }
        if (BLOCK_OPEN_REGEX && options.block && !(tripleQuotes && block.type === "block")) {
          if (token = scan(BLOCK_OPEN_REGEX, "open")) {
            push(new Block({ type: "block" }));
            push(new Node(token));
            continue;
          }
        }
        if (BLOCK_CLOSE_REGEX && block.type === "block" && options.block) {
          if (token = scan(BLOCK_CLOSE_REGEX, "close")) {
            token.newline = token.match[1] || "";
            push(new Node(token));
            pop();
            continue;
          }
        }
        if (LINE_REGEX && block.type !== "block" && options.line) {
          if (token = scan(LINE_REGEX, "line")) {
            push(new Node(token));
            continue;
          }
        }
        if (token = scan(/^[a-zABD-Z0-9\t ]+/, "text")) {
          push(new Node(token));
          continue;
        }
        push(new Node({ type: "text", value: consume(remaining[0]) }));
      }
      return cst;
    };
    module2.exports = parse;
  }
});

// node_modules/strip-comments/index.js
var require_strip_comments = __commonJS({
  "node_modules/strip-comments/index.js"(exports, module2) {
    "use strict";
    var compile = require_compile();
    var parse = require_parse();
    var strip = module2.exports = (input, options) => {
      const opts = { ...options, block: true, line: true };
      return compile(parse(input, opts), opts);
    };
    strip.block = (input, options) => {
      const opts = { ...options, block: true };
      return compile(parse(input, opts), opts);
    };
    strip.line = (input, options) => {
      const opts = { ...options, line: true };
      return compile(parse(input, opts), opts);
    };
    strip.first = (input, options) => {
      const opts = { ...options, block: true, line: true, first: true };
      return compile(parse(input, opts), opts);
    };
    strip.parse = parse;
  }
});

// node_modules/vscode-jsonrpc/lib/common/is.js
var require_is = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/is.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
    function boolean(value) {
      return value === true || value === false;
    }
    exports.boolean = boolean;
    function string(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports.string = string;
    function number(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports.number = number;
    function error(value) {
      return value instanceof Error;
    }
    exports.error = error;
    function func(value) {
      return typeof value === "function";
    }
    exports.func = func;
    function array(value) {
      return Array.isArray(value);
    }
    exports.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string(elem));
    }
    exports.stringArray = stringArray;
  }
});

// node_modules/vscode-jsonrpc/lib/common/messages.js
var require_messages = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/messages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Message = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType = exports.RequestType0 = exports.AbstractMessageSignature = exports.ParameterStructures = exports.ResponseError = exports.ErrorCodes = void 0;
    var is = require_is();
    var ErrorCodes;
    (function(ErrorCodes2) {
      ErrorCodes2.ParseError = -32700;
      ErrorCodes2.InvalidRequest = -32600;
      ErrorCodes2.MethodNotFound = -32601;
      ErrorCodes2.InvalidParams = -32602;
      ErrorCodes2.InternalError = -32603;
      ErrorCodes2.jsonrpcReservedErrorRangeStart = -32099;
      ErrorCodes2.serverErrorStart = -32099;
      ErrorCodes2.MessageWriteError = -32099;
      ErrorCodes2.MessageReadError = -32098;
      ErrorCodes2.PendingResponseRejected = -32097;
      ErrorCodes2.ConnectionInactive = -32096;
      ErrorCodes2.ServerNotInitialized = -32002;
      ErrorCodes2.UnknownErrorCode = -32001;
      ErrorCodes2.jsonrpcReservedErrorRangeEnd = -32e3;
      ErrorCodes2.serverErrorEnd = -32e3;
    })(ErrorCodes || (exports.ErrorCodes = ErrorCodes = {}));
    var ResponseError = class extends Error {
      constructor(code, message, data) {
        super(message);
        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
        this.data = data;
        Object.setPrototypeOf(this, ResponseError.prototype);
      }
      toJson() {
        const result = {
          code: this.code,
          message: this.message
        };
        if (this.data !== void 0) {
          result.data = this.data;
        }
        return result;
      }
    };
    exports.ResponseError = ResponseError;
    var ParameterStructures = class {
      constructor(kind) {
        this.kind = kind;
      }
      static is(value) {
        return value === ParameterStructures.auto || value === ParameterStructures.byName || value === ParameterStructures.byPosition;
      }
      toString() {
        return this.kind;
      }
    };
    exports.ParameterStructures = ParameterStructures;
    ParameterStructures.auto = new ParameterStructures("auto");
    ParameterStructures.byPosition = new ParameterStructures("byPosition");
    ParameterStructures.byName = new ParameterStructures("byName");
    var AbstractMessageSignature = class {
      constructor(method, numberOfParams) {
        this.method = method;
        this.numberOfParams = numberOfParams;
      }
      get parameterStructures() {
        return ParameterStructures.auto;
      }
    };
    exports.AbstractMessageSignature = AbstractMessageSignature;
    var RequestType0 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 0);
      }
    };
    exports.RequestType0 = RequestType0;
    var RequestType = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports.RequestType = RequestType;
    var RequestType1 = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports.RequestType1 = RequestType1;
    var RequestType2 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 2);
      }
    };
    exports.RequestType2 = RequestType2;
    var RequestType3 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 3);
      }
    };
    exports.RequestType3 = RequestType3;
    var RequestType4 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 4);
      }
    };
    exports.RequestType4 = RequestType4;
    var RequestType5 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 5);
      }
    };
    exports.RequestType5 = RequestType5;
    var RequestType6 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 6);
      }
    };
    exports.RequestType6 = RequestType6;
    var RequestType7 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 7);
      }
    };
    exports.RequestType7 = RequestType7;
    var RequestType8 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 8);
      }
    };
    exports.RequestType8 = RequestType8;
    var RequestType9 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 9);
      }
    };
    exports.RequestType9 = RequestType9;
    var NotificationType = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports.NotificationType = NotificationType;
    var NotificationType0 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 0);
      }
    };
    exports.NotificationType0 = NotificationType0;
    var NotificationType1 = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports.NotificationType1 = NotificationType1;
    var NotificationType2 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 2);
      }
    };
    exports.NotificationType2 = NotificationType2;
    var NotificationType3 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 3);
      }
    };
    exports.NotificationType3 = NotificationType3;
    var NotificationType4 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 4);
      }
    };
    exports.NotificationType4 = NotificationType4;
    var NotificationType5 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 5);
      }
    };
    exports.NotificationType5 = NotificationType5;
    var NotificationType6 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 6);
      }
    };
    exports.NotificationType6 = NotificationType6;
    var NotificationType7 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 7);
      }
    };
    exports.NotificationType7 = NotificationType7;
    var NotificationType8 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 8);
      }
    };
    exports.NotificationType8 = NotificationType8;
    var NotificationType9 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 9);
      }
    };
    exports.NotificationType9 = NotificationType9;
    var Message;
    (function(Message2) {
      function isRequest(message) {
        const candidate = message;
        return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
      }
      Message2.isRequest = isRequest;
      function isNotification(message) {
        const candidate = message;
        return candidate && is.string(candidate.method) && message.id === void 0;
      }
      Message2.isNotification = isNotification;
      function isResponse(message) {
        const candidate = message;
        return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
      }
      Message2.isResponse = isResponse;
    })(Message || (exports.Message = Message = {}));
  }
});

// node_modules/vscode-jsonrpc/lib/common/linkedMap.js
var require_linkedMap = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/linkedMap.js"(exports) {
    "use strict";
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LRUCache = exports.LinkedMap = exports.Touch = void 0;
    var Touch;
    (function(Touch2) {
      Touch2.None = 0;
      Touch2.First = 1;
      Touch2.AsOld = Touch2.First;
      Touch2.Last = 2;
      Touch2.AsNew = Touch2.Last;
    })(Touch || (exports.Touch = Touch = {}));
    var LinkedMap = class {
      constructor() {
        this[_a] = "LinkedMap";
        this._map = /* @__PURE__ */ new Map();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state = 0;
      }
      clear() {
        this._map.clear();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state++;
      }
      isEmpty() {
        return !this._head && !this._tail;
      }
      get size() {
        return this._size;
      }
      get first() {
        return this._head?.value;
      }
      get last() {
        return this._tail?.value;
      }
      has(key) {
        return this._map.has(key);
      }
      get(key, touch = Touch.None) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        if (touch !== Touch.None) {
          this.touch(item, touch);
        }
        return item.value;
      }
      set(key, value, touch = Touch.None) {
        let item = this._map.get(key);
        if (item) {
          item.value = value;
          if (touch !== Touch.None) {
            this.touch(item, touch);
          }
        } else {
          item = { key, value, next: void 0, previous: void 0 };
          switch (touch) {
            case Touch.None:
              this.addItemLast(item);
              break;
            case Touch.First:
              this.addItemFirst(item);
              break;
            case Touch.Last:
              this.addItemLast(item);
              break;
            default:
              this.addItemLast(item);
              break;
          }
          this._map.set(key, item);
          this._size++;
        }
        return this;
      }
      delete(key) {
        return !!this.remove(key);
      }
      remove(key) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        this._map.delete(key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      shift() {
        if (!this._head && !this._tail) {
          return void 0;
        }
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        const item = this._head;
        this._map.delete(item.key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      forEach(callbackfn, thisArg) {
        const state = this._state;
        let current = this._head;
        while (current) {
          if (thisArg) {
            callbackfn.bind(thisArg)(current.value, current.key, this);
          } else {
            callbackfn(current.value, current.key, this);
          }
          if (this._state !== state) {
            throw new Error(`LinkedMap got modified during iteration.`);
          }
          current = current.next;
        }
      }
      keys() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.key, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      values() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.value, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      entries() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: [current.key, current.value], done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      [(_a = Symbol.toStringTag, Symbol.iterator)]() {
        return this.entries();
      }
      trimOld(newSize) {
        if (newSize >= this.size) {
          return;
        }
        if (newSize === 0) {
          this.clear();
          return;
        }
        let current = this._head;
        let currentSize = this.size;
        while (current && currentSize > newSize) {
          this._map.delete(current.key);
          current = current.next;
          currentSize--;
        }
        this._head = current;
        this._size = currentSize;
        if (current) {
          current.previous = void 0;
        }
        this._state++;
      }
      addItemFirst(item) {
        if (!this._head && !this._tail) {
          this._tail = item;
        } else if (!this._head) {
          throw new Error("Invalid list");
        } else {
          item.next = this._head;
          this._head.previous = item;
        }
        this._head = item;
        this._state++;
      }
      addItemLast(item) {
        if (!this._head && !this._tail) {
          this._head = item;
        } else if (!this._tail) {
          throw new Error("Invalid list");
        } else {
          item.previous = this._tail;
          this._tail.next = item;
        }
        this._tail = item;
        this._state++;
      }
      removeItem(item) {
        if (item === this._head && item === this._tail) {
          this._head = void 0;
          this._tail = void 0;
        } else if (item === this._head) {
          if (!item.next) {
            throw new Error("Invalid list");
          }
          item.next.previous = void 0;
          this._head = item.next;
        } else if (item === this._tail) {
          if (!item.previous) {
            throw new Error("Invalid list");
          }
          item.previous.next = void 0;
          this._tail = item.previous;
        } else {
          const next = item.next;
          const previous = item.previous;
          if (!next || !previous) {
            throw new Error("Invalid list");
          }
          next.previous = previous;
          previous.next = next;
        }
        item.next = void 0;
        item.previous = void 0;
        this._state++;
      }
      touch(item, touch) {
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        if (touch !== Touch.First && touch !== Touch.Last) {
          return;
        }
        if (touch === Touch.First) {
          if (item === this._head) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._tail) {
            previous.next = void 0;
            this._tail = previous;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.previous = void 0;
          item.next = this._head;
          this._head.previous = item;
          this._head = item;
          this._state++;
        } else if (touch === Touch.Last) {
          if (item === this._tail) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._head) {
            next.previous = void 0;
            this._head = next;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.next = void 0;
          item.previous = this._tail;
          this._tail.next = item;
          this._tail = item;
          this._state++;
        }
      }
      toJSON() {
        const data = [];
        this.forEach((value, key) => {
          data.push([key, value]);
        });
        return data;
      }
      fromJSON(data) {
        this.clear();
        for (const [key, value] of data) {
          this.set(key, value);
        }
      }
    };
    exports.LinkedMap = LinkedMap;
    var LRUCache = class extends LinkedMap {
      constructor(limit, ratio = 1) {
        super();
        this._limit = limit;
        this._ratio = Math.min(Math.max(0, ratio), 1);
      }
      get limit() {
        return this._limit;
      }
      set limit(limit) {
        this._limit = limit;
        this.checkTrim();
      }
      get ratio() {
        return this._ratio;
      }
      set ratio(ratio) {
        this._ratio = Math.min(Math.max(0, ratio), 1);
        this.checkTrim();
      }
      get(key, touch = Touch.AsNew) {
        return super.get(key, touch);
      }
      peek(key) {
        return super.get(key, Touch.None);
      }
      set(key, value) {
        super.set(key, value, Touch.Last);
        this.checkTrim();
        return this;
      }
      checkTrim() {
        if (this.size > this._limit) {
          this.trimOld(Math.round(this._limit * this._ratio));
        }
      }
    };
    exports.LRUCache = LRUCache;
  }
});

// node_modules/vscode-jsonrpc/lib/common/disposable.js
var require_disposable = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/disposable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Disposable = void 0;
    var Disposable;
    (function(Disposable2) {
      function create(func) {
        return {
          dispose: func
        };
      }
      Disposable2.create = create;
    })(Disposable || (exports.Disposable = Disposable = {}));
  }
});

// node_modules/vscode-jsonrpc/lib/common/ral.js
var require_ral = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/ral.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _ral;
    function RAL() {
      if (_ral === void 0) {
        throw new Error(`No runtime abstraction layer installed`);
      }
      return _ral;
    }
    (function(RAL2) {
      function install(ral) {
        if (ral === void 0) {
          throw new Error(`No runtime abstraction layer provided`);
        }
        _ral = ral;
      }
      RAL2.install = install;
    })(RAL || (RAL = {}));
    exports.default = RAL;
  }
});

// node_modules/vscode-jsonrpc/lib/common/events.js
var require_events = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/events.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Emitter = exports.Event = void 0;
    var ral_1 = require_ral();
    var Event;
    (function(Event2) {
      const _disposable = { dispose() {
      } };
      Event2.None = function() {
        return _disposable;
      };
    })(Event || (exports.Event = Event = {}));
    var CallbackList = class {
      add(callback, context = null, bucket) {
        if (!this._callbacks) {
          this._callbacks = [];
          this._contexts = [];
        }
        this._callbacks.push(callback);
        this._contexts.push(context);
        if (Array.isArray(bucket)) {
          bucket.push({ dispose: () => this.remove(callback, context) });
        }
      }
      remove(callback, context = null) {
        if (!this._callbacks) {
          return;
        }
        let foundCallbackWithDifferentContext = false;
        for (let i = 0, len = this._callbacks.length; i < len; i++) {
          if (this._callbacks[i] === callback) {
            if (this._contexts[i] === context) {
              this._callbacks.splice(i, 1);
              this._contexts.splice(i, 1);
              return;
            } else {
              foundCallbackWithDifferentContext = true;
            }
          }
        }
        if (foundCallbackWithDifferentContext) {
          throw new Error("When adding a listener with a context, you should remove it with the same context");
        }
      }
      invoke(...args) {
        if (!this._callbacks) {
          return [];
        }
        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
        for (let i = 0, len = callbacks.length; i < len; i++) {
          try {
            ret.push(callbacks[i].apply(contexts[i], args));
          } catch (e) {
            (0, ral_1.default)().console.error(e);
          }
        }
        return ret;
      }
      isEmpty() {
        return !this._callbacks || this._callbacks.length === 0;
      }
      dispose() {
        this._callbacks = void 0;
        this._contexts = void 0;
      }
    };
    var Emitter = class {
      constructor(_options) {
        this._options = _options;
      }
      get event() {
        if (!this._event) {
          this._event = (listener, thisArgs, disposables) => {
            if (!this._callbacks) {
              this._callbacks = new CallbackList();
            }
            if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
              this._options.onFirstListenerAdd(this);
            }
            this._callbacks.add(listener, thisArgs);
            const result = {
              dispose: () => {
                if (!this._callbacks) {
                  return;
                }
                this._callbacks.remove(listener, thisArgs);
                result.dispose = Emitter._noop;
                if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                  this._options.onLastListenerRemove(this);
                }
              }
            };
            if (Array.isArray(disposables)) {
              disposables.push(result);
            }
            return result;
          };
        }
        return this._event;
      }
      fire(event) {
        if (this._callbacks) {
          this._callbacks.invoke.call(this._callbacks, event);
        }
      }
      dispose() {
        if (this._callbacks) {
          this._callbacks.dispose();
          this._callbacks = void 0;
        }
      }
    };
    exports.Emitter = Emitter;
    Emitter._noop = function() {
    };
  }
});

// node_modules/vscode-jsonrpc/lib/common/cancellation.js
var require_cancellation = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/cancellation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CancellationTokenSource = exports.CancellationToken = void 0;
    var ral_1 = require_ral();
    var Is = require_is();
    var events_1 = require_events();
    var CancellationToken;
    (function(CancellationToken2) {
      CancellationToken2.None = Object.freeze({
        isCancellationRequested: false,
        onCancellationRequested: events_1.Event.None
      });
      CancellationToken2.Cancelled = Object.freeze({
        isCancellationRequested: true,
        onCancellationRequested: events_1.Event.None
      });
      function is(value) {
        const candidate = value;
        return candidate && (candidate === CancellationToken2.None || candidate === CancellationToken2.Cancelled || Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested);
      }
      CancellationToken2.is = is;
    })(CancellationToken || (exports.CancellationToken = CancellationToken = {}));
    var shortcutEvent = Object.freeze(function(callback, context) {
      const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);
      return { dispose() {
        handle.dispose();
      } };
    });
    var MutableToken = class {
      constructor() {
        this._isCancelled = false;
      }
      cancel() {
        if (!this._isCancelled) {
          this._isCancelled = true;
          if (this._emitter) {
            this._emitter.fire(void 0);
            this.dispose();
          }
        }
      }
      get isCancellationRequested() {
        return this._isCancelled;
      }
      get onCancellationRequested() {
        if (this._isCancelled) {
          return shortcutEvent;
        }
        if (!this._emitter) {
          this._emitter = new events_1.Emitter();
        }
        return this._emitter.event;
      }
      dispose() {
        if (this._emitter) {
          this._emitter.dispose();
          this._emitter = void 0;
        }
      }
    };
    var CancellationTokenSource = class {
      get token() {
        if (!this._token) {
          this._token = new MutableToken();
        }
        return this._token;
      }
      cancel() {
        if (!this._token) {
          this._token = CancellationToken.Cancelled;
        } else {
          this._token.cancel();
        }
      }
      dispose() {
        if (!this._token) {
          this._token = CancellationToken.None;
        } else if (this._token instanceof MutableToken) {
          this._token.dispose();
        }
      }
    };
    exports.CancellationTokenSource = CancellationTokenSource;
  }
});

// node_modules/vscode-jsonrpc/lib/common/sharedArrayCancellation.js
var require_sharedArrayCancellation = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/sharedArrayCancellation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SharedArrayReceiverStrategy = exports.SharedArraySenderStrategy = void 0;
    var cancellation_1 = require_cancellation();
    var CancellationState;
    (function(CancellationState2) {
      CancellationState2.Continue = 0;
      CancellationState2.Cancelled = 1;
    })(CancellationState || (CancellationState = {}));
    var SharedArraySenderStrategy = class {
      constructor() {
        this.buffers = /* @__PURE__ */ new Map();
      }
      enableCancellation(request) {
        if (request.id === null) {
          return;
        }
        const buffer = new SharedArrayBuffer(4);
        const data = new Int32Array(buffer, 0, 1);
        data[0] = CancellationState.Continue;
        this.buffers.set(request.id, buffer);
        request.$cancellationData = buffer;
      }
      async sendCancellation(_conn, id) {
        const buffer = this.buffers.get(id);
        if (buffer === void 0) {
          return;
        }
        const data = new Int32Array(buffer, 0, 1);
        Atomics.store(data, 0, CancellationState.Cancelled);
      }
      cleanup(id) {
        this.buffers.delete(id);
      }
      dispose() {
        this.buffers.clear();
      }
    };
    exports.SharedArraySenderStrategy = SharedArraySenderStrategy;
    var SharedArrayBufferCancellationToken = class {
      constructor(buffer) {
        this.data = new Int32Array(buffer, 0, 1);
      }
      get isCancellationRequested() {
        return Atomics.load(this.data, 0) === CancellationState.Cancelled;
      }
      get onCancellationRequested() {
        throw new Error(`Cancellation over SharedArrayBuffer doesn't support cancellation events`);
      }
    };
    var SharedArrayBufferCancellationTokenSource = class {
      constructor(buffer) {
        this.token = new SharedArrayBufferCancellationToken(buffer);
      }
      cancel() {
      }
      dispose() {
      }
    };
    var SharedArrayReceiverStrategy = class {
      constructor() {
        this.kind = "request";
      }
      createCancellationTokenSource(request) {
        const buffer = request.$cancellationData;
        if (buffer === void 0) {
          return new cancellation_1.CancellationTokenSource();
        }
        return new SharedArrayBufferCancellationTokenSource(buffer);
      }
    };
    exports.SharedArrayReceiverStrategy = SharedArrayReceiverStrategy;
  }
});

// node_modules/vscode-jsonrpc/lib/common/semaphore.js
var require_semaphore = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/semaphore.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Semaphore = void 0;
    var ral_1 = require_ral();
    var Semaphore = class {
      constructor(capacity = 1) {
        if (capacity <= 0) {
          throw new Error("Capacity must be greater than 0");
        }
        this._capacity = capacity;
        this._active = 0;
        this._waiting = [];
      }
      lock(thunk) {
        return new Promise((resolve, reject) => {
          this._waiting.push({ thunk, resolve, reject });
          this.runNext();
        });
      }
      get active() {
        return this._active;
      }
      runNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
          return;
        }
        (0, ral_1.default)().timer.setImmediate(() => this.doRunNext());
      }
      doRunNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
          return;
        }
        const next = this._waiting.shift();
        this._active++;
        if (this._active > this._capacity) {
          throw new Error(`To many thunks active`);
        }
        try {
          const result = next.thunk();
          if (result instanceof Promise) {
            result.then((value) => {
              this._active--;
              next.resolve(value);
              this.runNext();
            }, (err) => {
              this._active--;
              next.reject(err);
              this.runNext();
            });
          } else {
            this._active--;
            next.resolve(result);
            this.runNext();
          }
        } catch (err) {
          this._active--;
          next.reject(err);
          this.runNext();
        }
      }
    };
    exports.Semaphore = Semaphore;
  }
});

// node_modules/vscode-jsonrpc/lib/common/messageReader.js
var require_messageReader = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/messageReader.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = void 0;
    var ral_1 = require_ral();
    var Is = require_is();
    var events_1 = require_events();
    var semaphore_1 = require_semaphore();
    var MessageReader;
    (function(MessageReader2) {
      function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) && Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);
      }
      MessageReader2.is = is;
    })(MessageReader || (exports.MessageReader = MessageReader = {}));
    var AbstractMessageReader = class {
      constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
        this.partialMessageEmitter = new events_1.Emitter();
      }
      dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
      }
      get onError() {
        return this.errorEmitter.event;
      }
      fireError(error) {
        this.errorEmitter.fire(this.asError(error));
      }
      get onClose() {
        return this.closeEmitter.event;
      }
      fireClose() {
        this.closeEmitter.fire(void 0);
      }
      get onPartialMessage() {
        return this.partialMessageEmitter.event;
      }
      firePartialMessage(info) {
        this.partialMessageEmitter.fire(info);
      }
      asError(error) {
        if (error instanceof Error) {
          return error;
        } else {
          return new Error(`Reader received error. Reason: ${Is.string(error.message) ? error.message : "unknown"}`);
        }
      }
    };
    exports.AbstractMessageReader = AbstractMessageReader;
    var ResolvedMessageReaderOptions;
    (function(ResolvedMessageReaderOptions2) {
      function fromOptions(options) {
        let charset;
        let result;
        let contentDecoder;
        const contentDecoders = /* @__PURE__ */ new Map();
        let contentTypeDecoder;
        const contentTypeDecoders = /* @__PURE__ */ new Map();
        if (options === void 0 || typeof options === "string") {
          charset = options ?? "utf-8";
        } else {
          charset = options.charset ?? "utf-8";
          if (options.contentDecoder !== void 0) {
            contentDecoder = options.contentDecoder;
            contentDecoders.set(contentDecoder.name, contentDecoder);
          }
          if (options.contentDecoders !== void 0) {
            for (const decoder of options.contentDecoders) {
              contentDecoders.set(decoder.name, decoder);
            }
          }
          if (options.contentTypeDecoder !== void 0) {
            contentTypeDecoder = options.contentTypeDecoder;
            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
          }
          if (options.contentTypeDecoders !== void 0) {
            for (const decoder of options.contentTypeDecoders) {
              contentTypeDecoders.set(decoder.name, decoder);
            }
          }
        }
        if (contentTypeDecoder === void 0) {
          contentTypeDecoder = (0, ral_1.default)().applicationJson.decoder;
          contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
        }
        return { charset, contentDecoder, contentDecoders, contentTypeDecoder, contentTypeDecoders };
      }
      ResolvedMessageReaderOptions2.fromOptions = fromOptions;
    })(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
    var ReadableStreamMessageReader = class extends AbstractMessageReader {
      constructor(readable, options) {
        super();
        this.readable = readable;
        this.options = ResolvedMessageReaderOptions.fromOptions(options);
        this.buffer = (0, ral_1.default)().messageBuffer.create(this.options.charset);
        this._partialMessageTimeout = 1e4;
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.readSemaphore = new semaphore_1.Semaphore(1);
      }
      set partialMessageTimeout(timeout) {
        this._partialMessageTimeout = timeout;
      }
      get partialMessageTimeout() {
        return this._partialMessageTimeout;
      }
      listen(callback) {
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.partialMessageTimer = void 0;
        this.callback = callback;
        const result = this.readable.onData((data) => {
          this.onData(data);
        });
        this.readable.onError((error) => this.fireError(error));
        this.readable.onClose(() => this.fireClose());
        return result;
      }
      onData(data) {
        try {
          this.buffer.append(data);
          while (true) {
            if (this.nextMessageLength === -1) {
              const headers = this.buffer.tryReadHeaders(true);
              if (!headers) {
                return;
              }
              const contentLength = headers.get("content-length");
              if (!contentLength) {
                this.fireError(new Error(`Header must provide a Content-Length property.
${JSON.stringify(Object.fromEntries(headers))}`));
                return;
              }
              const length = parseInt(contentLength);
              if (isNaN(length)) {
                this.fireError(new Error(`Content-Length value must be a number. Got ${contentLength}`));
                return;
              }
              this.nextMessageLength = length;
            }
            const body = this.buffer.tryReadBody(this.nextMessageLength);
            if (body === void 0) {
              this.setPartialMessageTimer();
              return;
            }
            this.clearPartialMessageTimer();
            this.nextMessageLength = -1;
            this.readSemaphore.lock(async () => {
              const bytes = this.options.contentDecoder !== void 0 ? await this.options.contentDecoder.decode(body) : body;
              const message = await this.options.contentTypeDecoder.decode(bytes, this.options);
              this.callback(message);
            }).catch((error) => {
              this.fireError(error);
            });
          }
        } catch (error) {
          this.fireError(error);
        }
      }
      clearPartialMessageTimer() {
        if (this.partialMessageTimer) {
          this.partialMessageTimer.dispose();
          this.partialMessageTimer = void 0;
        }
      }
      setPartialMessageTimer() {
        this.clearPartialMessageTimer();
        if (this._partialMessageTimeout <= 0) {
          return;
        }
        this.partialMessageTimer = (0, ral_1.default)().timer.setTimeout((token, timeout) => {
          this.partialMessageTimer = void 0;
          if (token === this.messageToken) {
            this.firePartialMessage({ messageToken: token, waitingTime: timeout });
            this.setPartialMessageTimer();
          }
        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
      }
    };
    exports.ReadableStreamMessageReader = ReadableStreamMessageReader;
  }
});

// node_modules/vscode-jsonrpc/lib/common/messageWriter.js
var require_messageWriter = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/messageWriter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = void 0;
    var ral_1 = require_ral();
    var Is = require_is();
    var semaphore_1 = require_semaphore();
    var events_1 = require_events();
    var ContentLength = "Content-Length: ";
    var CRLF = "\r\n";
    var MessageWriter;
    (function(MessageWriter2) {
      function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) && Is.func(candidate.onError) && Is.func(candidate.write);
      }
      MessageWriter2.is = is;
    })(MessageWriter || (exports.MessageWriter = MessageWriter = {}));
    var AbstractMessageWriter = class {
      constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
      }
      dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
      }
      get onError() {
        return this.errorEmitter.event;
      }
      fireError(error, message, count) {
        this.errorEmitter.fire([this.asError(error), message, count]);
      }
      get onClose() {
        return this.closeEmitter.event;
      }
      fireClose() {
        this.closeEmitter.fire(void 0);
      }
      asError(error) {
        if (error instanceof Error) {
          return error;
        } else {
          return new Error(`Writer received error. Reason: ${Is.string(error.message) ? error.message : "unknown"}`);
        }
      }
    };
    exports.AbstractMessageWriter = AbstractMessageWriter;
    var ResolvedMessageWriterOptions;
    (function(ResolvedMessageWriterOptions2) {
      function fromOptions(options) {
        if (options === void 0 || typeof options === "string") {
          return { charset: options ?? "utf-8", contentTypeEncoder: (0, ral_1.default)().applicationJson.encoder };
        } else {
          return { charset: options.charset ?? "utf-8", contentEncoder: options.contentEncoder, contentTypeEncoder: options.contentTypeEncoder ?? (0, ral_1.default)().applicationJson.encoder };
        }
      }
      ResolvedMessageWriterOptions2.fromOptions = fromOptions;
    })(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
    var WriteableStreamMessageWriter = class extends AbstractMessageWriter {
      constructor(writable, options) {
        super();
        this.writable = writable;
        this.options = ResolvedMessageWriterOptions.fromOptions(options);
        this.errorCount = 0;
        this.writeSemaphore = new semaphore_1.Semaphore(1);
        this.writable.onError((error) => this.fireError(error));
        this.writable.onClose(() => this.fireClose());
      }
      async write(msg) {
        return this.writeSemaphore.lock(async () => {
          const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer) => {
            if (this.options.contentEncoder !== void 0) {
              return this.options.contentEncoder.encode(buffer);
            } else {
              return buffer;
            }
          });
          return payload.then((buffer) => {
            const headers = [];
            headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
            headers.push(CRLF);
            return this.doWrite(msg, headers, buffer);
          }, (error) => {
            this.fireError(error);
            throw error;
          });
        });
      }
      async doWrite(msg, headers, data) {
        try {
          await this.writable.write(headers.join(""), "ascii");
          return this.writable.write(data);
        } catch (error) {
          this.handleError(error, msg);
          return Promise.reject(error);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
      end() {
        this.writable.end();
      }
    };
    exports.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
  }
});

// node_modules/vscode-jsonrpc/lib/common/messageBuffer.js
var require_messageBuffer = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/messageBuffer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AbstractMessageBuffer = void 0;
    var CR = 13;
    var LF = 10;
    var CRLF = "\r\n";
    var AbstractMessageBuffer = class {
      constructor(encoding = "utf-8") {
        this._encoding = encoding;
        this._chunks = [];
        this._totalLength = 0;
      }
      get encoding() {
        return this._encoding;
      }
      append(chunk) {
        const toAppend = typeof chunk === "string" ? this.fromString(chunk, this._encoding) : chunk;
        this._chunks.push(toAppend);
        this._totalLength += toAppend.byteLength;
      }
      tryReadHeaders(lowerCaseKeys = false) {
        if (this._chunks.length === 0) {
          return void 0;
        }
        let state = 0;
        let chunkIndex = 0;
        let offset = 0;
        let chunkBytesRead = 0;
        row:
          while (chunkIndex < this._chunks.length) {
            const chunk = this._chunks[chunkIndex];
            offset = 0;
            column:
              while (offset < chunk.length) {
                const value = chunk[offset];
                switch (value) {
                  case CR:
                    switch (state) {
                      case 0:
                        state = 1;
                        break;
                      case 2:
                        state = 3;
                        break;
                      default:
                        state = 0;
                    }
                    break;
                  case LF:
                    switch (state) {
                      case 1:
                        state = 2;
                        break;
                      case 3:
                        state = 4;
                        offset++;
                        break row;
                      default:
                        state = 0;
                    }
                    break;
                  default:
                    state = 0;
                }
                offset++;
              }
            chunkBytesRead += chunk.byteLength;
            chunkIndex++;
          }
        if (state !== 4) {
          return void 0;
        }
        const buffer = this._read(chunkBytesRead + offset);
        const result = /* @__PURE__ */ new Map();
        const headers = this.toString(buffer, "ascii").split(CRLF);
        if (headers.length < 2) {
          return result;
        }
        for (let i = 0; i < headers.length - 2; i++) {
          const header = headers[i];
          const index = header.indexOf(":");
          if (index === -1) {
            throw new Error(`Message header must separate key and value using ':'
${header}`);
          }
          const key = header.substr(0, index);
          const value = header.substr(index + 1).trim();
          result.set(lowerCaseKeys ? key.toLowerCase() : key, value);
        }
        return result;
      }
      tryReadBody(length) {
        if (this._totalLength < length) {
          return void 0;
        }
        return this._read(length);
      }
      get numberOfBytes() {
        return this._totalLength;
      }
      _read(byteCount) {
        if (byteCount === 0) {
          return this.emptyBuffer();
        }
        if (byteCount > this._totalLength) {
          throw new Error(`Cannot read so many bytes!`);
        }
        if (this._chunks[0].byteLength === byteCount) {
          const chunk = this._chunks[0];
          this._chunks.shift();
          this._totalLength -= byteCount;
          return this.asNative(chunk);
        }
        if (this._chunks[0].byteLength > byteCount) {
          const chunk = this._chunks[0];
          const result2 = this.asNative(chunk, byteCount);
          this._chunks[0] = chunk.slice(byteCount);
          this._totalLength -= byteCount;
          return result2;
        }
        const result = this.allocNative(byteCount);
        let resultOffset = 0;
        let chunkIndex = 0;
        while (byteCount > 0) {
          const chunk = this._chunks[chunkIndex];
          if (chunk.byteLength > byteCount) {
            const chunkPart = chunk.slice(0, byteCount);
            result.set(chunkPart, resultOffset);
            resultOffset += byteCount;
            this._chunks[chunkIndex] = chunk.slice(byteCount);
            this._totalLength -= byteCount;
            byteCount -= byteCount;
          } else {
            result.set(chunk, resultOffset);
            resultOffset += chunk.byteLength;
            this._chunks.shift();
            this._totalLength -= chunk.byteLength;
            byteCount -= chunk.byteLength;
          }
        }
        return result;
      }
    };
    exports.AbstractMessageBuffer = AbstractMessageBuffer;
  }
});

// node_modules/vscode-jsonrpc/lib/common/connection.js
var require_connection = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/connection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createMessageConnection = exports.ConnectionOptions = exports.MessageStrategy = exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.RequestCancellationReceiverStrategy = exports.IdCancellationReceiverStrategy = exports.ConnectionStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.TraceValues = exports.Trace = exports.NullLogger = exports.ProgressType = exports.ProgressToken = void 0;
    var ral_1 = require_ral();
    var Is = require_is();
    var messages_1 = require_messages();
    var linkedMap_1 = require_linkedMap();
    var events_1 = require_events();
    var cancellation_1 = require_cancellation();
    var CancelNotification;
    (function(CancelNotification2) {
      CancelNotification2.type = new messages_1.NotificationType("$/cancelRequest");
    })(CancelNotification || (CancelNotification = {}));
    var ProgressToken;
    (function(ProgressToken2) {
      function is(value) {
        return typeof value === "string" || typeof value === "number";
      }
      ProgressToken2.is = is;
    })(ProgressToken || (exports.ProgressToken = ProgressToken = {}));
    var ProgressNotification;
    (function(ProgressNotification2) {
      ProgressNotification2.type = new messages_1.NotificationType("$/progress");
    })(ProgressNotification || (ProgressNotification = {}));
    var ProgressType = class {
      constructor() {
      }
    };
    exports.ProgressType = ProgressType;
    var StarRequestHandler;
    (function(StarRequestHandler2) {
      function is(value) {
        return Is.func(value);
      }
      StarRequestHandler2.is = is;
    })(StarRequestHandler || (StarRequestHandler = {}));
    exports.NullLogger = Object.freeze({
      error: () => {
      },
      warn: () => {
      },
      info: () => {
      },
      log: () => {
      }
    });
    var Trace;
    (function(Trace2) {
      Trace2[Trace2["Off"] = 0] = "Off";
      Trace2[Trace2["Messages"] = 1] = "Messages";
      Trace2[Trace2["Compact"] = 2] = "Compact";
      Trace2[Trace2["Verbose"] = 3] = "Verbose";
    })(Trace || (exports.Trace = Trace = {}));
    var TraceValues;
    (function(TraceValues2) {
      TraceValues2.Off = "off";
      TraceValues2.Messages = "messages";
      TraceValues2.Compact = "compact";
      TraceValues2.Verbose = "verbose";
    })(TraceValues || (exports.TraceValues = TraceValues = {}));
    (function(Trace2) {
      function fromString(value) {
        if (!Is.string(value)) {
          return Trace2.Off;
        }
        value = value.toLowerCase();
        switch (value) {
          case "off":
            return Trace2.Off;
          case "messages":
            return Trace2.Messages;
          case "compact":
            return Trace2.Compact;
          case "verbose":
            return Trace2.Verbose;
          default:
            return Trace2.Off;
        }
      }
      Trace2.fromString = fromString;
      function toString(value) {
        switch (value) {
          case Trace2.Off:
            return "off";
          case Trace2.Messages:
            return "messages";
          case Trace2.Compact:
            return "compact";
          case Trace2.Verbose:
            return "verbose";
          default:
            return "off";
        }
      }
      Trace2.toString = toString;
    })(Trace || (exports.Trace = Trace = {}));
    var TraceFormat;
    (function(TraceFormat2) {
      TraceFormat2["Text"] = "text";
      TraceFormat2["JSON"] = "json";
    })(TraceFormat || (exports.TraceFormat = TraceFormat = {}));
    (function(TraceFormat2) {
      function fromString(value) {
        if (!Is.string(value)) {
          return TraceFormat2.Text;
        }
        value = value.toLowerCase();
        if (value === "json") {
          return TraceFormat2.JSON;
        } else {
          return TraceFormat2.Text;
        }
      }
      TraceFormat2.fromString = fromString;
    })(TraceFormat || (exports.TraceFormat = TraceFormat = {}));
    var SetTraceNotification;
    (function(SetTraceNotification2) {
      SetTraceNotification2.type = new messages_1.NotificationType("$/setTrace");
    })(SetTraceNotification || (exports.SetTraceNotification = SetTraceNotification = {}));
    var LogTraceNotification;
    (function(LogTraceNotification2) {
      LogTraceNotification2.type = new messages_1.NotificationType("$/logTrace");
    })(LogTraceNotification || (exports.LogTraceNotification = LogTraceNotification = {}));
    var ConnectionErrors;
    (function(ConnectionErrors2) {
      ConnectionErrors2[ConnectionErrors2["Closed"] = 1] = "Closed";
      ConnectionErrors2[ConnectionErrors2["Disposed"] = 2] = "Disposed";
      ConnectionErrors2[ConnectionErrors2["AlreadyListening"] = 3] = "AlreadyListening";
    })(ConnectionErrors || (exports.ConnectionErrors = ConnectionErrors = {}));
    var ConnectionError = class extends Error {
      constructor(code, message) {
        super(message);
        this.code = code;
        Object.setPrototypeOf(this, ConnectionError.prototype);
      }
    };
    exports.ConnectionError = ConnectionError;
    var ConnectionStrategy;
    (function(ConnectionStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.cancelUndispatched);
      }
      ConnectionStrategy2.is = is;
    })(ConnectionStrategy || (exports.ConnectionStrategy = ConnectionStrategy = {}));
    var IdCancellationReceiverStrategy;
    (function(IdCancellationReceiverStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && (candidate.kind === void 0 || candidate.kind === "id") && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === void 0 || Is.func(candidate.dispose));
      }
      IdCancellationReceiverStrategy2.is = is;
    })(IdCancellationReceiverStrategy || (exports.IdCancellationReceiverStrategy = IdCancellationReceiverStrategy = {}));
    var RequestCancellationReceiverStrategy;
    (function(RequestCancellationReceiverStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && candidate.kind === "request" && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === void 0 || Is.func(candidate.dispose));
      }
      RequestCancellationReceiverStrategy2.is = is;
    })(RequestCancellationReceiverStrategy || (exports.RequestCancellationReceiverStrategy = RequestCancellationReceiverStrategy = {}));
    var CancellationReceiverStrategy;
    (function(CancellationReceiverStrategy2) {
      CancellationReceiverStrategy2.Message = Object.freeze({
        createCancellationTokenSource(_) {
          return new cancellation_1.CancellationTokenSource();
        }
      });
      function is(value) {
        return IdCancellationReceiverStrategy.is(value) || RequestCancellationReceiverStrategy.is(value);
      }
      CancellationReceiverStrategy2.is = is;
    })(CancellationReceiverStrategy || (exports.CancellationReceiverStrategy = CancellationReceiverStrategy = {}));
    var CancellationSenderStrategy;
    (function(CancellationSenderStrategy2) {
      CancellationSenderStrategy2.Message = Object.freeze({
        sendCancellation(conn, id) {
          return conn.sendNotification(CancelNotification.type, { id });
        },
        cleanup(_) {
        }
      });
      function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.sendCancellation) && Is.func(candidate.cleanup);
      }
      CancellationSenderStrategy2.is = is;
    })(CancellationSenderStrategy || (exports.CancellationSenderStrategy = CancellationSenderStrategy = {}));
    var CancellationStrategy;
    (function(CancellationStrategy2) {
      CancellationStrategy2.Message = Object.freeze({
        receiver: CancellationReceiverStrategy.Message,
        sender: CancellationSenderStrategy.Message
      });
      function is(value) {
        const candidate = value;
        return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
      }
      CancellationStrategy2.is = is;
    })(CancellationStrategy || (exports.CancellationStrategy = CancellationStrategy = {}));
    var MessageStrategy;
    (function(MessageStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.handleMessage);
      }
      MessageStrategy2.is = is;
    })(MessageStrategy || (exports.MessageStrategy = MessageStrategy = {}));
    var ConnectionOptions;
    (function(ConnectionOptions2) {
      function is(value) {
        const candidate = value;
        return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy) || MessageStrategy.is(candidate.messageStrategy));
      }
      ConnectionOptions2.is = is;
    })(ConnectionOptions || (exports.ConnectionOptions = ConnectionOptions = {}));
    var ConnectionState;
    (function(ConnectionState2) {
      ConnectionState2[ConnectionState2["New"] = 1] = "New";
      ConnectionState2[ConnectionState2["Listening"] = 2] = "Listening";
      ConnectionState2[ConnectionState2["Closed"] = 3] = "Closed";
      ConnectionState2[ConnectionState2["Disposed"] = 4] = "Disposed";
    })(ConnectionState || (ConnectionState = {}));
    function createMessageConnection(messageReader, messageWriter, _logger, options) {
      const logger = _logger !== void 0 ? _logger : exports.NullLogger;
      let sequenceNumber = 0;
      let notificationSequenceNumber = 0;
      let unknownResponseSequenceNumber = 0;
      const version = "2.0";
      let starRequestHandler = void 0;
      const requestHandlers = /* @__PURE__ */ new Map();
      let starNotificationHandler = void 0;
      const notificationHandlers = /* @__PURE__ */ new Map();
      const progressHandlers = /* @__PURE__ */ new Map();
      let timer;
      let messageQueue = new linkedMap_1.LinkedMap();
      let responsePromises = /* @__PURE__ */ new Map();
      let knownCanceledRequests = /* @__PURE__ */ new Set();
      let requestTokens = /* @__PURE__ */ new Map();
      let trace = Trace.Off;
      let traceFormat = TraceFormat.Text;
      let tracer;
      let state = ConnectionState.New;
      const errorEmitter = new events_1.Emitter();
      const closeEmitter = new events_1.Emitter();
      const unhandledNotificationEmitter = new events_1.Emitter();
      const unhandledProgressEmitter = new events_1.Emitter();
      const disposeEmitter = new events_1.Emitter();
      const cancellationStrategy = options && options.cancellationStrategy ? options.cancellationStrategy : CancellationStrategy.Message;
      function createRequestQueueKey(id) {
        if (id === null) {
          throw new Error(`Can't send requests with id null since the response can't be correlated.`);
        }
        return "req-" + id.toString();
      }
      function createResponseQueueKey(id) {
        if (id === null) {
          return "res-unknown-" + (++unknownResponseSequenceNumber).toString();
        } else {
          return "res-" + id.toString();
        }
      }
      function createNotificationQueueKey() {
        return "not-" + (++notificationSequenceNumber).toString();
      }
      function addMessageToQueue(queue, message) {
        if (messages_1.Message.isRequest(message)) {
          queue.set(createRequestQueueKey(message.id), message);
        } else if (messages_1.Message.isResponse(message)) {
          queue.set(createResponseQueueKey(message.id), message);
        } else {
          queue.set(createNotificationQueueKey(), message);
        }
      }
      function cancelUndispatched(_message) {
        return void 0;
      }
      function isListening() {
        return state === ConnectionState.Listening;
      }
      function isClosed() {
        return state === ConnectionState.Closed;
      }
      function isDisposed() {
        return state === ConnectionState.Disposed;
      }
      function closeHandler() {
        if (state === ConnectionState.New || state === ConnectionState.Listening) {
          state = ConnectionState.Closed;
          closeEmitter.fire(void 0);
        }
      }
      function readErrorHandler(error) {
        errorEmitter.fire([error, void 0, void 0]);
      }
      function writeErrorHandler(data) {
        errorEmitter.fire(data);
      }
      messageReader.onClose(closeHandler);
      messageReader.onError(readErrorHandler);
      messageWriter.onClose(closeHandler);
      messageWriter.onError(writeErrorHandler);
      function triggerMessageQueue() {
        if (timer || messageQueue.size === 0) {
          return;
        }
        timer = (0, ral_1.default)().timer.setImmediate(() => {
          timer = void 0;
          processMessageQueue();
        });
      }
      function handleMessage(message) {
        if (messages_1.Message.isRequest(message)) {
          handleRequest(message);
        } else if (messages_1.Message.isNotification(message)) {
          handleNotification(message);
        } else if (messages_1.Message.isResponse(message)) {
          handleResponse(message);
        } else {
          handleInvalidMessage(message);
        }
      }
      function processMessageQueue() {
        if (messageQueue.size === 0) {
          return;
        }
        const message = messageQueue.shift();
        try {
          const messageStrategy = options?.messageStrategy;
          if (MessageStrategy.is(messageStrategy)) {
            messageStrategy.handleMessage(message, handleMessage);
          } else {
            handleMessage(message);
          }
        } finally {
          triggerMessageQueue();
        }
      }
      const callback = (message) => {
        try {
          if (messages_1.Message.isNotification(message) && message.method === CancelNotification.type.method) {
            const cancelId = message.params.id;
            const key = createRequestQueueKey(cancelId);
            const toCancel = messageQueue.get(key);
            if (messages_1.Message.isRequest(toCancel)) {
              const strategy = options?.connectionStrategy;
              const response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
              if (response && (response.error !== void 0 || response.result !== void 0)) {
                messageQueue.delete(key);
                requestTokens.delete(cancelId);
                response.id = toCancel.id;
                traceSendingResponse(response, message.method, Date.now());
                messageWriter.write(response).catch(() => logger.error(`Sending response for canceled message failed.`));
                return;
              }
            }
            const cancellationToken = requestTokens.get(cancelId);
            if (cancellationToken !== void 0) {
              cancellationToken.cancel();
              traceReceivedNotification(message);
              return;
            } else {
              knownCanceledRequests.add(cancelId);
            }
          }
          addMessageToQueue(messageQueue, message);
        } finally {
          triggerMessageQueue();
        }
      };
      function handleRequest(requestMessage) {
        if (isDisposed()) {
          return;
        }
        function reply(resultOrError, method, startTime2) {
          const message = {
            jsonrpc: version,
            id: requestMessage.id
          };
          if (resultOrError instanceof messages_1.ResponseError) {
            message.error = resultOrError.toJson();
          } else {
            message.result = resultOrError === void 0 ? null : resultOrError;
          }
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        function replyError(error, method, startTime2) {
          const message = {
            jsonrpc: version,
            id: requestMessage.id,
            error: error.toJson()
          };
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        function replySuccess(result, method, startTime2) {
          if (result === void 0) {
            result = null;
          }
          const message = {
            jsonrpc: version,
            id: requestMessage.id,
            result
          };
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        traceReceivedRequest(requestMessage);
        const element = requestHandlers.get(requestMessage.method);
        let type;
        let requestHandler;
        if (element) {
          type = element.type;
          requestHandler = element.handler;
        }
        const startTime = Date.now();
        if (requestHandler || starRequestHandler) {
          const tokenKey = requestMessage.id ?? String(Date.now());
          const cancellationSource = IdCancellationReceiverStrategy.is(cancellationStrategy.receiver) ? cancellationStrategy.receiver.createCancellationTokenSource(tokenKey) : cancellationStrategy.receiver.createCancellationTokenSource(requestMessage);
          if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {
            cancellationSource.cancel();
          }
          if (requestMessage.id !== null) {
            requestTokens.set(tokenKey, cancellationSource);
          }
          try {
            let handlerResult;
            if (requestHandler) {
              if (requestMessage.params === void 0) {
                if (type !== void 0 && type.numberOfParams !== 0) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(cancellationSource.token);
              } else if (Array.isArray(requestMessage.params)) {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byName) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
              } else {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
              }
            } else if (starRequestHandler) {
              handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
            }
            const promise = handlerResult;
            if (!handlerResult) {
              requestTokens.delete(tokenKey);
              replySuccess(handlerResult, requestMessage.method, startTime);
            } else if (promise.then) {
              promise.then((resultOrError) => {
                requestTokens.delete(tokenKey);
                reply(resultOrError, requestMessage.method, startTime);
              }, (error) => {
                requestTokens.delete(tokenKey);
                if (error instanceof messages_1.ResponseError) {
                  replyError(error, requestMessage.method, startTime);
                } else if (error && Is.string(error.message)) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                } else {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                }
              });
            } else {
              requestTokens.delete(tokenKey);
              reply(handlerResult, requestMessage.method, startTime);
            }
          } catch (error) {
            requestTokens.delete(tokenKey);
            if (error instanceof messages_1.ResponseError) {
              reply(error, requestMessage.method, startTime);
            } else if (error && Is.string(error.message)) {
              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
            } else {
              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
            }
          }
        } else {
          replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
        }
      }
      function handleResponse(responseMessage) {
        if (isDisposed()) {
          return;
        }
        if (responseMessage.id === null) {
          if (responseMessage.error) {
            logger.error(`Received response message without id: Error is: 
${JSON.stringify(responseMessage.error, void 0, 4)}`);
          } else {
            logger.error(`Received response message without id. No further error information provided.`);
          }
        } else {
          const key = responseMessage.id;
          const responsePromise = responsePromises.get(key);
          traceReceivedResponse(responseMessage, responsePromise);
          if (responsePromise !== void 0) {
            responsePromises.delete(key);
            try {
              if (responseMessage.error) {
                const error = responseMessage.error;
                responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
              } else if (responseMessage.result !== void 0) {
                responsePromise.resolve(responseMessage.result);
              } else {
                throw new Error("Should never happen.");
              }
            } catch (error) {
              if (error.message) {
                logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
              } else {
                logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
              }
            }
          }
        }
      }
      function handleNotification(message) {
        if (isDisposed()) {
          return;
        }
        let type = void 0;
        let notificationHandler;
        if (message.method === CancelNotification.type.method) {
          const cancelId = message.params.id;
          knownCanceledRequests.delete(cancelId);
          traceReceivedNotification(message);
          return;
        } else {
          const element = notificationHandlers.get(message.method);
          if (element) {
            notificationHandler = element.handler;
            type = element.type;
          }
        }
        if (notificationHandler || starNotificationHandler) {
          try {
            traceReceivedNotification(message);
            if (notificationHandler) {
              if (message.params === void 0) {
                if (type !== void 0) {
                  if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
                    logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`);
                  }
                }
                notificationHandler();
              } else if (Array.isArray(message.params)) {
                const params = message.params;
                if (message.method === ProgressNotification.type.method && params.length === 2 && ProgressToken.is(params[0])) {
                  notificationHandler({ token: params[0], value: params[1] });
                } else {
                  if (type !== void 0) {
                    if (type.parameterStructures === messages_1.ParameterStructures.byName) {
                      logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
                    }
                    if (type.numberOfParams !== message.params.length) {
                      logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${params.length} arguments`);
                    }
                  }
                  notificationHandler(...params);
                }
              } else {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                  logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
                }
                notificationHandler(message.params);
              }
            } else if (starNotificationHandler) {
              starNotificationHandler(message.method, message.params);
            }
          } catch (error) {
            if (error.message) {
              logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
            } else {
              logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
            }
          }
        } else {
          unhandledNotificationEmitter.fire(message);
        }
      }
      function handleInvalidMessage(message) {
        if (!message) {
          logger.error("Received empty message.");
          return;
        }
        logger.error(`Received message which is neither a response nor a notification message:
${JSON.stringify(message, null, 4)}`);
        const responseMessage = message;
        if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {
          const key = responseMessage.id;
          const responseHandler = responsePromises.get(key);
          if (responseHandler) {
            responseHandler.reject(new Error("The received response has neither a result nor an error property."));
          }
        }
      }
      function stringifyTrace(params) {
        if (params === void 0 || params === null) {
          return void 0;
        }
        switch (trace) {
          case Trace.Verbose:
            return JSON.stringify(params, null, 4);
          case Trace.Compact:
            return JSON.stringify(params);
          default:
            return void 0;
        }
      }
      function traceSendingRequest(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
            data = `Params: ${stringifyTrace(message.params)}

`;
          }
          tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
        } else {
          logLSPMessage("send-request", message);
        }
      }
      function traceSendingNotification(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.params) {
              data = `Params: ${stringifyTrace(message.params)}

`;
            } else {
              data = "No parameters provided.\n\n";
            }
          }
          tracer.log(`Sending notification '${message.method}'.`, data);
        } else {
          logLSPMessage("send-notification", message);
        }
      }
      function traceSendingResponse(message, method, startTime) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.error && message.error.data) {
              data = `Error data: ${stringifyTrace(message.error.data)}

`;
            } else {
              if (message.result) {
                data = `Result: ${stringifyTrace(message.result)}

`;
              } else if (message.error === void 0) {
                data = "No result returned.\n\n";
              }
            }
          }
          tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
        } else {
          logLSPMessage("send-response", message);
        }
      }
      function traceReceivedRequest(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
            data = `Params: ${stringifyTrace(message.params)}

`;
          }
          tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
        } else {
          logLSPMessage("receive-request", message);
        }
      }
      function traceReceivedNotification(message) {
        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.params) {
              data = `Params: ${stringifyTrace(message.params)}

`;
            } else {
              data = "No parameters provided.\n\n";
            }
          }
          tracer.log(`Received notification '${message.method}'.`, data);
        } else {
          logLSPMessage("receive-notification", message);
        }
      }
      function traceReceivedResponse(message, responsePromise) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.error && message.error.data) {
              data = `Error data: ${stringifyTrace(message.error.data)}

`;
            } else {
              if (message.result) {
                data = `Result: ${stringifyTrace(message.result)}

`;
              } else if (message.error === void 0) {
                data = "No result returned.\n\n";
              }
            }
          }
          if (responsePromise) {
            const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : "";
            tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
          } else {
            tracer.log(`Received response ${message.id} without active response promise.`, data);
          }
        } else {
          logLSPMessage("receive-response", message);
        }
      }
      function logLSPMessage(type, message) {
        if (!tracer || trace === Trace.Off) {
          return;
        }
        const lspMessage = {
          isLSPMessage: true,
          type,
          message,
          timestamp: Date.now()
        };
        tracer.log(lspMessage);
      }
      function throwIfClosedOrDisposed() {
        if (isClosed()) {
          throw new ConnectionError(ConnectionErrors.Closed, "Connection is closed.");
        }
        if (isDisposed()) {
          throw new ConnectionError(ConnectionErrors.Disposed, "Connection is disposed.");
        }
      }
      function throwIfListening() {
        if (isListening()) {
          throw new ConnectionError(ConnectionErrors.AlreadyListening, "Connection is already listening");
        }
      }
      function throwIfNotListening() {
        if (!isListening()) {
          throw new Error("Call listen() first.");
        }
      }
      function undefinedToNull(param) {
        if (param === void 0) {
          return null;
        } else {
          return param;
        }
      }
      function nullToUndefined(param) {
        if (param === null) {
          return void 0;
        } else {
          return param;
        }
      }
      function isNamedParam(param) {
        return param !== void 0 && param !== null && !Array.isArray(param) && typeof param === "object";
      }
      function computeSingleParam(parameterStructures, param) {
        switch (parameterStructures) {
          case messages_1.ParameterStructures.auto:
            if (isNamedParam(param)) {
              return nullToUndefined(param);
            } else {
              return [undefinedToNull(param)];
            }
          case messages_1.ParameterStructures.byName:
            if (!isNamedParam(param)) {
              throw new Error(`Received parameters by name but param is not an object literal.`);
            }
            return nullToUndefined(param);
          case messages_1.ParameterStructures.byPosition:
            return [undefinedToNull(param)];
          default:
            throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
        }
      }
      function computeMessageParams(type, params) {
        let result;
        const numberOfParams = type.numberOfParams;
        switch (numberOfParams) {
          case 0:
            result = void 0;
            break;
          case 1:
            result = computeSingleParam(type.parameterStructures, params[0]);
            break;
          default:
            result = [];
            for (let i = 0; i < params.length && i < numberOfParams; i++) {
              result.push(undefinedToNull(params[i]));
            }
            if (params.length < numberOfParams) {
              for (let i = params.length; i < numberOfParams; i++) {
                result.push(null);
              }
            }
            break;
        }
        return result;
      }
      const connection = {
        sendNotification: (type, ...args) => {
          throwIfClosedOrDisposed();
          let method;
          let messageParams;
          if (Is.string(type)) {
            method = type;
            const first = args[0];
            let paramStart = 0;
            let parameterStructures = messages_1.ParameterStructures.auto;
            if (messages_1.ParameterStructures.is(first)) {
              paramStart = 1;
              parameterStructures = first;
            }
            let paramEnd = args.length;
            const numberOfParams = paramEnd - paramStart;
            switch (numberOfParams) {
              case 0:
                messageParams = void 0;
                break;
              case 1:
                messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                break;
              default:
                if (parameterStructures === messages_1.ParameterStructures.byName) {
                  throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
                }
                messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                break;
            }
          } else {
            const params = args;
            method = type.method;
            messageParams = computeMessageParams(type, params);
          }
          const notificationMessage = {
            jsonrpc: version,
            method,
            params: messageParams
          };
          traceSendingNotification(notificationMessage);
          return messageWriter.write(notificationMessage).catch((error) => {
            logger.error(`Sending notification failed.`);
            throw error;
          });
        },
        onNotification: (type, handler) => {
          throwIfClosedOrDisposed();
          let method;
          if (Is.func(type)) {
            starNotificationHandler = type;
          } else if (handler) {
            if (Is.string(type)) {
              method = type;
              notificationHandlers.set(type, { type: void 0, handler });
            } else {
              method = type.method;
              notificationHandlers.set(type.method, { type, handler });
            }
          }
          return {
            dispose: () => {
              if (method !== void 0) {
                notificationHandlers.delete(method);
              } else {
                starNotificationHandler = void 0;
              }
            }
          };
        },
        onProgress: (_type, token, handler) => {
          if (progressHandlers.has(token)) {
            throw new Error(`Progress handler for token ${token} already registered`);
          }
          progressHandlers.set(token, handler);
          return {
            dispose: () => {
              progressHandlers.delete(token);
            }
          };
        },
        sendProgress: (_type, token, value) => {
          return connection.sendNotification(ProgressNotification.type, { token, value });
        },
        onUnhandledProgress: unhandledProgressEmitter.event,
        sendRequest: (type, ...args) => {
          throwIfClosedOrDisposed();
          throwIfNotListening();
          let method;
          let messageParams;
          let token = void 0;
          if (Is.string(type)) {
            method = type;
            const first = args[0];
            const last = args[args.length - 1];
            let paramStart = 0;
            let parameterStructures = messages_1.ParameterStructures.auto;
            if (messages_1.ParameterStructures.is(first)) {
              paramStart = 1;
              parameterStructures = first;
            }
            let paramEnd = args.length;
            if (cancellation_1.CancellationToken.is(last)) {
              paramEnd = paramEnd - 1;
              token = last;
            }
            const numberOfParams = paramEnd - paramStart;
            switch (numberOfParams) {
              case 0:
                messageParams = void 0;
                break;
              case 1:
                messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                break;
              default:
                if (parameterStructures === messages_1.ParameterStructures.byName) {
                  throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);
                }
                messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                break;
            }
          } else {
            const params = args;
            method = type.method;
            messageParams = computeMessageParams(type, params);
            const numberOfParams = type.numberOfParams;
            token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : void 0;
          }
          const id = sequenceNumber++;
          let disposable;
          if (token) {
            disposable = token.onCancellationRequested(() => {
              const p = cancellationStrategy.sender.sendCancellation(connection, id);
              if (p === void 0) {
                logger.log(`Received no promise from cancellation strategy when cancelling id ${id}`);
                return Promise.resolve();
              } else {
                return p.catch(() => {
                  logger.log(`Sending cancellation messages for id ${id} failed`);
                });
              }
            });
          }
          const requestMessage = {
            jsonrpc: version,
            id,
            method,
            params: messageParams
          };
          traceSendingRequest(requestMessage);
          if (typeof cancellationStrategy.sender.enableCancellation === "function") {
            cancellationStrategy.sender.enableCancellation(requestMessage);
          }
          return new Promise(async (resolve, reject) => {
            const resolveWithCleanup = (r) => {
              resolve(r);
              cancellationStrategy.sender.cleanup(id);
              disposable?.dispose();
            };
            const rejectWithCleanup = (r) => {
              reject(r);
              cancellationStrategy.sender.cleanup(id);
              disposable?.dispose();
            };
            const responsePromise = { method, timerStart: Date.now(), resolve: resolveWithCleanup, reject: rejectWithCleanup };
            try {
              await messageWriter.write(requestMessage);
              responsePromises.set(id, responsePromise);
            } catch (error) {
              logger.error(`Sending request failed.`);
              responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, error.message ? error.message : "Unknown reason"));
              throw error;
            }
          });
        },
        onRequest: (type, handler) => {
          throwIfClosedOrDisposed();
          let method = null;
          if (StarRequestHandler.is(type)) {
            method = void 0;
            starRequestHandler = type;
          } else if (Is.string(type)) {
            method = null;
            if (handler !== void 0) {
              method = type;
              requestHandlers.set(type, { handler, type: void 0 });
            }
          } else {
            if (handler !== void 0) {
              method = type.method;
              requestHandlers.set(type.method, { type, handler });
            }
          }
          return {
            dispose: () => {
              if (method === null) {
                return;
              }
              if (method !== void 0) {
                requestHandlers.delete(method);
              } else {
                starRequestHandler = void 0;
              }
            }
          };
        },
        hasPendingResponse: () => {
          return responsePromises.size > 0;
        },
        trace: async (_value, _tracer, sendNotificationOrTraceOptions) => {
          let _sendNotification = false;
          let _traceFormat = TraceFormat.Text;
          if (sendNotificationOrTraceOptions !== void 0) {
            if (Is.boolean(sendNotificationOrTraceOptions)) {
              _sendNotification = sendNotificationOrTraceOptions;
            } else {
              _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
              _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
            }
          }
          trace = _value;
          traceFormat = _traceFormat;
          if (trace === Trace.Off) {
            tracer = void 0;
          } else {
            tracer = _tracer;
          }
          if (_sendNotification && !isClosed() && !isDisposed()) {
            await connection.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });
          }
        },
        onError: errorEmitter.event,
        onClose: closeEmitter.event,
        onUnhandledNotification: unhandledNotificationEmitter.event,
        onDispose: disposeEmitter.event,
        end: () => {
          messageWriter.end();
        },
        dispose: () => {
          if (isDisposed()) {
            return;
          }
          state = ConnectionState.Disposed;
          disposeEmitter.fire(void 0);
          const error = new messages_1.ResponseError(messages_1.ErrorCodes.PendingResponseRejected, "Pending response rejected since connection got disposed");
          for (const promise of responsePromises.values()) {
            promise.reject(error);
          }
          responsePromises = /* @__PURE__ */ new Map();
          requestTokens = /* @__PURE__ */ new Map();
          knownCanceledRequests = /* @__PURE__ */ new Set();
          messageQueue = new linkedMap_1.LinkedMap();
          if (Is.func(messageWriter.dispose)) {
            messageWriter.dispose();
          }
          if (Is.func(messageReader.dispose)) {
            messageReader.dispose();
          }
        },
        listen: () => {
          throwIfClosedOrDisposed();
          throwIfListening();
          state = ConnectionState.Listening;
          messageReader.listen(callback);
        },
        inspect: () => {
          (0, ral_1.default)().console.log("inspect");
        }
      };
      connection.onNotification(LogTraceNotification.type, (params) => {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        const verbose = trace === Trace.Verbose || trace === Trace.Compact;
        tracer.log(params.message, verbose ? params.verbose : void 0);
      });
      connection.onNotification(ProgressNotification.type, (params) => {
        const handler = progressHandlers.get(params.token);
        if (handler) {
          handler(params.value);
        } else {
          unhandledProgressEmitter.fire(params);
        }
      });
      return connection;
    }
    exports.createMessageConnection = createMessageConnection;
  }
});

// node_modules/vscode-jsonrpc/lib/common/api.js
var require_api = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/api.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProgressType = exports.ProgressToken = exports.createMessageConnection = exports.NullLogger = exports.ConnectionOptions = exports.ConnectionStrategy = exports.AbstractMessageBuffer = exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = exports.SharedArrayReceiverStrategy = exports.SharedArraySenderStrategy = exports.CancellationToken = exports.CancellationTokenSource = exports.Emitter = exports.Event = exports.Disposable = exports.LRUCache = exports.Touch = exports.LinkedMap = exports.ParameterStructures = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.ErrorCodes = exports.ResponseError = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType0 = exports.RequestType = exports.Message = exports.RAL = void 0;
    exports.MessageStrategy = exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.TraceValues = exports.Trace = void 0;
    var messages_1 = require_messages();
    Object.defineProperty(exports, "Message", { enumerable: true, get: function() {
      return messages_1.Message;
    } });
    Object.defineProperty(exports, "RequestType", { enumerable: true, get: function() {
      return messages_1.RequestType;
    } });
    Object.defineProperty(exports, "RequestType0", { enumerable: true, get: function() {
      return messages_1.RequestType0;
    } });
    Object.defineProperty(exports, "RequestType1", { enumerable: true, get: function() {
      return messages_1.RequestType1;
    } });
    Object.defineProperty(exports, "RequestType2", { enumerable: true, get: function() {
      return messages_1.RequestType2;
    } });
    Object.defineProperty(exports, "RequestType3", { enumerable: true, get: function() {
      return messages_1.RequestType3;
    } });
    Object.defineProperty(exports, "RequestType4", { enumerable: true, get: function() {
      return messages_1.RequestType4;
    } });
    Object.defineProperty(exports, "RequestType5", { enumerable: true, get: function() {
      return messages_1.RequestType5;
    } });
    Object.defineProperty(exports, "RequestType6", { enumerable: true, get: function() {
      return messages_1.RequestType6;
    } });
    Object.defineProperty(exports, "RequestType7", { enumerable: true, get: function() {
      return messages_1.RequestType7;
    } });
    Object.defineProperty(exports, "RequestType8", { enumerable: true, get: function() {
      return messages_1.RequestType8;
    } });
    Object.defineProperty(exports, "RequestType9", { enumerable: true, get: function() {
      return messages_1.RequestType9;
    } });
    Object.defineProperty(exports, "ResponseError", { enumerable: true, get: function() {
      return messages_1.ResponseError;
    } });
    Object.defineProperty(exports, "ErrorCodes", { enumerable: true, get: function() {
      return messages_1.ErrorCodes;
    } });
    Object.defineProperty(exports, "NotificationType", { enumerable: true, get: function() {
      return messages_1.NotificationType;
    } });
    Object.defineProperty(exports, "NotificationType0", { enumerable: true, get: function() {
      return messages_1.NotificationType0;
    } });
    Object.defineProperty(exports, "NotificationType1", { enumerable: true, get: function() {
      return messages_1.NotificationType1;
    } });
    Object.defineProperty(exports, "NotificationType2", { enumerable: true, get: function() {
      return messages_1.NotificationType2;
    } });
    Object.defineProperty(exports, "NotificationType3", { enumerable: true, get: function() {
      return messages_1.NotificationType3;
    } });
    Object.defineProperty(exports, "NotificationType4", { enumerable: true, get: function() {
      return messages_1.NotificationType4;
    } });
    Object.defineProperty(exports, "NotificationType5", { enumerable: true, get: function() {
      return messages_1.NotificationType5;
    } });
    Object.defineProperty(exports, "NotificationType6", { enumerable: true, get: function() {
      return messages_1.NotificationType6;
    } });
    Object.defineProperty(exports, "NotificationType7", { enumerable: true, get: function() {
      return messages_1.NotificationType7;
    } });
    Object.defineProperty(exports, "NotificationType8", { enumerable: true, get: function() {
      return messages_1.NotificationType8;
    } });
    Object.defineProperty(exports, "NotificationType9", { enumerable: true, get: function() {
      return messages_1.NotificationType9;
    } });
    Object.defineProperty(exports, "ParameterStructures", { enumerable: true, get: function() {
      return messages_1.ParameterStructures;
    } });
    var linkedMap_1 = require_linkedMap();
    Object.defineProperty(exports, "LinkedMap", { enumerable: true, get: function() {
      return linkedMap_1.LinkedMap;
    } });
    Object.defineProperty(exports, "LRUCache", { enumerable: true, get: function() {
      return linkedMap_1.LRUCache;
    } });
    Object.defineProperty(exports, "Touch", { enumerable: true, get: function() {
      return linkedMap_1.Touch;
    } });
    var disposable_1 = require_disposable();
    Object.defineProperty(exports, "Disposable", { enumerable: true, get: function() {
      return disposable_1.Disposable;
    } });
    var events_1 = require_events();
    Object.defineProperty(exports, "Event", { enumerable: true, get: function() {
      return events_1.Event;
    } });
    Object.defineProperty(exports, "Emitter", { enumerable: true, get: function() {
      return events_1.Emitter;
    } });
    var cancellation_1 = require_cancellation();
    Object.defineProperty(exports, "CancellationTokenSource", { enumerable: true, get: function() {
      return cancellation_1.CancellationTokenSource;
    } });
    Object.defineProperty(exports, "CancellationToken", { enumerable: true, get: function() {
      return cancellation_1.CancellationToken;
    } });
    var sharedArrayCancellation_1 = require_sharedArrayCancellation();
    Object.defineProperty(exports, "SharedArraySenderStrategy", { enumerable: true, get: function() {
      return sharedArrayCancellation_1.SharedArraySenderStrategy;
    } });
    Object.defineProperty(exports, "SharedArrayReceiverStrategy", { enumerable: true, get: function() {
      return sharedArrayCancellation_1.SharedArrayReceiverStrategy;
    } });
    var messageReader_1 = require_messageReader();
    Object.defineProperty(exports, "MessageReader", { enumerable: true, get: function() {
      return messageReader_1.MessageReader;
    } });
    Object.defineProperty(exports, "AbstractMessageReader", { enumerable: true, get: function() {
      return messageReader_1.AbstractMessageReader;
    } });
    Object.defineProperty(exports, "ReadableStreamMessageReader", { enumerable: true, get: function() {
      return messageReader_1.ReadableStreamMessageReader;
    } });
    var messageWriter_1 = require_messageWriter();
    Object.defineProperty(exports, "MessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.MessageWriter;
    } });
    Object.defineProperty(exports, "AbstractMessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.AbstractMessageWriter;
    } });
    Object.defineProperty(exports, "WriteableStreamMessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.WriteableStreamMessageWriter;
    } });
    var messageBuffer_1 = require_messageBuffer();
    Object.defineProperty(exports, "AbstractMessageBuffer", { enumerable: true, get: function() {
      return messageBuffer_1.AbstractMessageBuffer;
    } });
    var connection_1 = require_connection();
    Object.defineProperty(exports, "ConnectionStrategy", { enumerable: true, get: function() {
      return connection_1.ConnectionStrategy;
    } });
    Object.defineProperty(exports, "ConnectionOptions", { enumerable: true, get: function() {
      return connection_1.ConnectionOptions;
    } });
    Object.defineProperty(exports, "NullLogger", { enumerable: true, get: function() {
      return connection_1.NullLogger;
    } });
    Object.defineProperty(exports, "createMessageConnection", { enumerable: true, get: function() {
      return connection_1.createMessageConnection;
    } });
    Object.defineProperty(exports, "ProgressToken", { enumerable: true, get: function() {
      return connection_1.ProgressToken;
    } });
    Object.defineProperty(exports, "ProgressType", { enumerable: true, get: function() {
      return connection_1.ProgressType;
    } });
    Object.defineProperty(exports, "Trace", { enumerable: true, get: function() {
      return connection_1.Trace;
    } });
    Object.defineProperty(exports, "TraceValues", { enumerable: true, get: function() {
      return connection_1.TraceValues;
    } });
    Object.defineProperty(exports, "TraceFormat", { enumerable: true, get: function() {
      return connection_1.TraceFormat;
    } });
    Object.defineProperty(exports, "SetTraceNotification", { enumerable: true, get: function() {
      return connection_1.SetTraceNotification;
    } });
    Object.defineProperty(exports, "LogTraceNotification", { enumerable: true, get: function() {
      return connection_1.LogTraceNotification;
    } });
    Object.defineProperty(exports, "ConnectionErrors", { enumerable: true, get: function() {
      return connection_1.ConnectionErrors;
    } });
    Object.defineProperty(exports, "ConnectionError", { enumerable: true, get: function() {
      return connection_1.ConnectionError;
    } });
    Object.defineProperty(exports, "CancellationReceiverStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationReceiverStrategy;
    } });
    Object.defineProperty(exports, "CancellationSenderStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationSenderStrategy;
    } });
    Object.defineProperty(exports, "CancellationStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationStrategy;
    } });
    Object.defineProperty(exports, "MessageStrategy", { enumerable: true, get: function() {
      return connection_1.MessageStrategy;
    } });
    var ral_1 = require_ral();
    exports.RAL = ral_1.default;
  }
});

// node_modules/vscode-jsonrpc/lib/node/ril.js
var require_ril = __commonJS({
  "node_modules/vscode-jsonrpc/lib/node/ril.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require("util");
    var api_1 = require_api();
    var MessageBuffer = class extends api_1.AbstractMessageBuffer {
      constructor(encoding = "utf-8") {
        super(encoding);
      }
      emptyBuffer() {
        return MessageBuffer.emptyBuffer;
      }
      fromString(value, encoding) {
        return Buffer.from(value, encoding);
      }
      toString(value, encoding) {
        if (value instanceof Buffer) {
          return value.toString(encoding);
        } else {
          return new util_1.TextDecoder(encoding).decode(value);
        }
      }
      asNative(buffer, length) {
        if (length === void 0) {
          return buffer instanceof Buffer ? buffer : Buffer.from(buffer);
        } else {
          return buffer instanceof Buffer ? buffer.slice(0, length) : Buffer.from(buffer, 0, length);
        }
      }
      allocNative(length) {
        return Buffer.allocUnsafe(length);
      }
    };
    MessageBuffer.emptyBuffer = Buffer.allocUnsafe(0);
    var ReadableStreamWrapper = class {
      constructor(stream) {
        this.stream = stream;
      }
      onClose(listener) {
        this.stream.on("close", listener);
        return api_1.Disposable.create(() => this.stream.off("close", listener));
      }
      onError(listener) {
        this.stream.on("error", listener);
        return api_1.Disposable.create(() => this.stream.off("error", listener));
      }
      onEnd(listener) {
        this.stream.on("end", listener);
        return api_1.Disposable.create(() => this.stream.off("end", listener));
      }
      onData(listener) {
        this.stream.on("data", listener);
        return api_1.Disposable.create(() => this.stream.off("data", listener));
      }
    };
    var WritableStreamWrapper = class {
      constructor(stream) {
        this.stream = stream;
      }
      onClose(listener) {
        this.stream.on("close", listener);
        return api_1.Disposable.create(() => this.stream.off("close", listener));
      }
      onError(listener) {
        this.stream.on("error", listener);
        return api_1.Disposable.create(() => this.stream.off("error", listener));
      }
      onEnd(listener) {
        this.stream.on("end", listener);
        return api_1.Disposable.create(() => this.stream.off("end", listener));
      }
      write(data, encoding) {
        return new Promise((resolve, reject) => {
          const callback = (error) => {
            if (error === void 0 || error === null) {
              resolve();
            } else {
              reject(error);
            }
          };
          if (typeof data === "string") {
            this.stream.write(data, encoding, callback);
          } else {
            this.stream.write(data, callback);
          }
        });
      }
      end() {
        this.stream.end();
      }
    };
    var _ril = Object.freeze({
      messageBuffer: Object.freeze({
        create: (encoding) => new MessageBuffer(encoding)
      }),
      applicationJson: Object.freeze({
        encoder: Object.freeze({
          name: "application/json",
          encode: (msg, options) => {
            try {
              return Promise.resolve(Buffer.from(JSON.stringify(msg, void 0, 0), options.charset));
            } catch (err) {
              return Promise.reject(err);
            }
          }
        }),
        decoder: Object.freeze({
          name: "application/json",
          decode: (buffer, options) => {
            try {
              if (buffer instanceof Buffer) {
                return Promise.resolve(JSON.parse(buffer.toString(options.charset)));
              } else {
                return Promise.resolve(JSON.parse(new util_1.TextDecoder(options.charset).decode(buffer)));
              }
            } catch (err) {
              return Promise.reject(err);
            }
          }
        })
      }),
      stream: Object.freeze({
        asReadableStream: (stream) => new ReadableStreamWrapper(stream),
        asWritableStream: (stream) => new WritableStreamWrapper(stream)
      }),
      console,
      timer: Object.freeze({
        setTimeout(callback, ms, ...args) {
          const handle = setTimeout(callback, ms, ...args);
          return { dispose: () => clearTimeout(handle) };
        },
        setImmediate(callback, ...args) {
          const handle = setImmediate(callback, ...args);
          return { dispose: () => clearImmediate(handle) };
        },
        setInterval(callback, ms, ...args) {
          const handle = setInterval(callback, ms, ...args);
          return { dispose: () => clearInterval(handle) };
        }
      })
    });
    function RIL() {
      return _ril;
    }
    (function(RIL2) {
      function install() {
        api_1.RAL.install(_ril);
      }
      RIL2.install = install;
    })(RIL || (RIL = {}));
    exports.default = RIL;
  }
});

// node_modules/vscode-jsonrpc/lib/node/main.js
var require_main = __commonJS({
  "node_modules/vscode-jsonrpc/lib/node/main.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createMessageConnection = exports.createServerSocketTransport = exports.createClientSocketTransport = exports.createServerPipeTransport = exports.createClientPipeTransport = exports.generateRandomPipeName = exports.StreamMessageWriter = exports.StreamMessageReader = exports.SocketMessageWriter = exports.SocketMessageReader = exports.PortMessageWriter = exports.PortMessageReader = exports.IPCMessageWriter = exports.IPCMessageReader = void 0;
    var ril_1 = require_ril();
    ril_1.default.install();
    var path = require("path");
    var os = require("os");
    var crypto_1 = require("crypto");
    var net_1 = require("net");
    var api_1 = require_api();
    __exportStar(require_api(), exports);
    var IPCMessageReader = class extends api_1.AbstractMessageReader {
      constructor(process2) {
        super();
        this.process = process2;
        let eventEmitter = this.process;
        eventEmitter.on("error", (error) => this.fireError(error));
        eventEmitter.on("close", () => this.fireClose());
      }
      listen(callback) {
        this.process.on("message", callback);
        return api_1.Disposable.create(() => this.process.off("message", callback));
      }
    };
    exports.IPCMessageReader = IPCMessageReader;
    var IPCMessageWriter = class extends api_1.AbstractMessageWriter {
      constructor(process2) {
        super();
        this.process = process2;
        this.errorCount = 0;
        const eventEmitter = this.process;
        eventEmitter.on("error", (error) => this.fireError(error));
        eventEmitter.on("close", () => this.fireClose);
      }
      write(msg) {
        try {
          if (typeof this.process.send === "function") {
            this.process.send(msg, void 0, void 0, (error) => {
              if (error) {
                this.errorCount++;
                this.handleError(error, msg);
              } else {
                this.errorCount = 0;
              }
            });
          }
          return Promise.resolve();
        } catch (error) {
          this.handleError(error, msg);
          return Promise.reject(error);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
      end() {
      }
    };
    exports.IPCMessageWriter = IPCMessageWriter;
    var PortMessageReader = class extends api_1.AbstractMessageReader {
      constructor(port) {
        super();
        this.onData = new api_1.Emitter();
        port.on("close", () => this.fireClose);
        port.on("error", (error) => this.fireError(error));
        port.on("message", (message) => {
          this.onData.fire(message);
        });
      }
      listen(callback) {
        return this.onData.event(callback);
      }
    };
    exports.PortMessageReader = PortMessageReader;
    var PortMessageWriter = class extends api_1.AbstractMessageWriter {
      constructor(port) {
        super();
        this.port = port;
        this.errorCount = 0;
        port.on("close", () => this.fireClose());
        port.on("error", (error) => this.fireError(error));
      }
      write(msg) {
        try {
          this.port.postMessage(msg);
          return Promise.resolve();
        } catch (error) {
          this.handleError(error, msg);
          return Promise.reject(error);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
      end() {
      }
    };
    exports.PortMessageWriter = PortMessageWriter;
    var SocketMessageReader = class extends api_1.ReadableStreamMessageReader {
      constructor(socket, encoding = "utf-8") {
        super((0, ril_1.default)().stream.asReadableStream(socket), encoding);
      }
    };
    exports.SocketMessageReader = SocketMessageReader;
    var SocketMessageWriter = class extends api_1.WriteableStreamMessageWriter {
      constructor(socket, options) {
        super((0, ril_1.default)().stream.asWritableStream(socket), options);
        this.socket = socket;
      }
      dispose() {
        super.dispose();
        this.socket.destroy();
      }
    };
    exports.SocketMessageWriter = SocketMessageWriter;
    var StreamMessageReader = class extends api_1.ReadableStreamMessageReader {
      constructor(readable, encoding) {
        super((0, ril_1.default)().stream.asReadableStream(readable), encoding);
      }
    };
    exports.StreamMessageReader = StreamMessageReader;
    var StreamMessageWriter = class extends api_1.WriteableStreamMessageWriter {
      constructor(writable, options) {
        super((0, ril_1.default)().stream.asWritableStream(writable), options);
      }
    };
    exports.StreamMessageWriter = StreamMessageWriter;
    var XDG_RUNTIME_DIR = process.env["XDG_RUNTIME_DIR"];
    var safeIpcPathLengths = /* @__PURE__ */ new Map([
      ["linux", 107],
      ["darwin", 103]
    ]);
    function generateRandomPipeName() {
      const randomSuffix = (0, crypto_1.randomBytes)(21).toString("hex");
      if (process.platform === "win32") {
        return `\\\\.\\pipe\\vscode-jsonrpc-${randomSuffix}-sock`;
      }
      let result;
      if (XDG_RUNTIME_DIR) {
        result = path.join(XDG_RUNTIME_DIR, `vscode-ipc-${randomSuffix}.sock`);
      } else {
        result = path.join(os.tmpdir(), `vscode-${randomSuffix}.sock`);
      }
      const limit = safeIpcPathLengths.get(process.platform);
      if (limit !== void 0 && result.length > limit) {
        (0, ril_1.default)().console.warn(`WARNING: IPC handle "${result}" is longer than ${limit} characters.`);
      }
      return result;
    }
    exports.generateRandomPipeName = generateRandomPipeName;
    function createClientPipeTransport(pipeName, encoding = "utf-8") {
      let connectResolve;
      const connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
      });
      return new Promise((resolve, reject) => {
        let server = (0, net_1.createServer)((socket) => {
          server.close();
          connectResolve([
            new SocketMessageReader(socket, encoding),
            new SocketMessageWriter(socket, encoding)
          ]);
        });
        server.on("error", reject);
        server.listen(pipeName, () => {
          server.removeListener("error", reject);
          resolve({
            onConnected: () => {
              return connected;
            }
          });
        });
      });
    }
    exports.createClientPipeTransport = createClientPipeTransport;
    function createServerPipeTransport(pipeName, encoding = "utf-8") {
      const socket = (0, net_1.createConnection)(pipeName);
      return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
      ];
    }
    exports.createServerPipeTransport = createServerPipeTransport;
    function createClientSocketTransport(port, encoding = "utf-8") {
      let connectResolve;
      const connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
      });
      return new Promise((resolve, reject) => {
        const server = (0, net_1.createServer)((socket) => {
          server.close();
          connectResolve([
            new SocketMessageReader(socket, encoding),
            new SocketMessageWriter(socket, encoding)
          ]);
        });
        server.on("error", reject);
        server.listen(port, "127.0.0.1", () => {
          server.removeListener("error", reject);
          resolve({
            onConnected: () => {
              return connected;
            }
          });
        });
      });
    }
    exports.createClientSocketTransport = createClientSocketTransport;
    function createServerSocketTransport(port, encoding = "utf-8") {
      const socket = (0, net_1.createConnection)(port, "127.0.0.1");
      return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
      ];
    }
    exports.createServerSocketTransport = createServerSocketTransport;
    function isReadableStream(value) {
      const candidate = value;
      return candidate.read !== void 0 && candidate.addListener !== void 0;
    }
    function isWritableStream(value) {
      const candidate = value;
      return candidate.write !== void 0 && candidate.addListener !== void 0;
    }
    function createMessageConnection(input, output, logger, options) {
      if (!logger) {
        logger = api_1.NullLogger;
      }
      const reader = isReadableStream(input) ? new StreamMessageReader(input) : input;
      const writer = isWritableStream(output) ? new StreamMessageWriter(output) : output;
      if (api_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
      }
      return (0, api_1.createMessageConnection)(reader, writer, logger, options);
    }
    exports.createMessageConnection = createMessageConnection;
  }
});

// node_modules/vscode-jsonrpc/node.js
var require_node = __commonJS({
  "node_modules/vscode-jsonrpc/node.js"(exports, module2) {
    "use strict";
    module2.exports = require_main();
  }
});

// node_modules/vscode-languageserver-types/lib/umd/main.js
var require_main2 = __commonJS({
  "node_modules/vscode-languageserver-types/lib/umd/main.js"(exports, module2) {
    (function(factory) {
      if (typeof module2 === "object" && typeof module2.exports === "object") {
        var v = factory(require, exports);
        if (v !== void 0)
          module2.exports = v;
      } else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
      }
    })(function(require2, exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.TextDocument = exports2.EOL = exports2.WorkspaceFolder = exports2.InlineCompletionContext = exports2.SelectedCompletionInfo = exports2.InlineCompletionTriggerKind = exports2.InlineCompletionList = exports2.InlineCompletionItem = exports2.StringValue = exports2.InlayHint = exports2.InlayHintLabelPart = exports2.InlayHintKind = exports2.InlineValueContext = exports2.InlineValueEvaluatableExpression = exports2.InlineValueVariableLookup = exports2.InlineValueText = exports2.SemanticTokens = exports2.SemanticTokenModifiers = exports2.SemanticTokenTypes = exports2.SelectionRange = exports2.DocumentLink = exports2.FormattingOptions = exports2.CodeLens = exports2.CodeAction = exports2.CodeActionContext = exports2.CodeActionTriggerKind = exports2.CodeActionKind = exports2.DocumentSymbol = exports2.WorkspaceSymbol = exports2.SymbolInformation = exports2.SymbolTag = exports2.SymbolKind = exports2.DocumentHighlight = exports2.DocumentHighlightKind = exports2.SignatureInformation = exports2.ParameterInformation = exports2.Hover = exports2.MarkedString = exports2.CompletionList = exports2.CompletionItem = exports2.CompletionItemLabelDetails = exports2.InsertTextMode = exports2.InsertReplaceEdit = exports2.CompletionItemTag = exports2.InsertTextFormat = exports2.CompletionItemKind = exports2.MarkupContent = exports2.MarkupKind = exports2.TextDocumentItem = exports2.OptionalVersionedTextDocumentIdentifier = exports2.VersionedTextDocumentIdentifier = exports2.TextDocumentIdentifier = exports2.WorkspaceChange = exports2.WorkspaceEdit = exports2.DeleteFile = exports2.RenameFile = exports2.CreateFile = exports2.TextDocumentEdit = exports2.AnnotatedTextEdit = exports2.ChangeAnnotationIdentifier = exports2.ChangeAnnotation = exports2.TextEdit = exports2.Command = exports2.Diagnostic = exports2.CodeDescription = exports2.DiagnosticTag = exports2.DiagnosticSeverity = exports2.DiagnosticRelatedInformation = exports2.FoldingRange = exports2.FoldingRangeKind = exports2.ColorPresentation = exports2.ColorInformation = exports2.Color = exports2.LocationLink = exports2.Location = exports2.Range = exports2.Position = exports2.uinteger = exports2.integer = exports2.URI = exports2.DocumentUri = void 0;
      var DocumentUri;
      (function(DocumentUri2) {
        function is(value) {
          return typeof value === "string";
        }
        DocumentUri2.is = is;
      })(DocumentUri || (exports2.DocumentUri = DocumentUri = {}));
      var URI;
      (function(URI2) {
        function is(value) {
          return typeof value === "string";
        }
        URI2.is = is;
      })(URI || (exports2.URI = URI = {}));
      var integer;
      (function(integer2) {
        integer2.MIN_VALUE = -2147483648;
        integer2.MAX_VALUE = 2147483647;
        function is(value) {
          return typeof value === "number" && integer2.MIN_VALUE <= value && value <= integer2.MAX_VALUE;
        }
        integer2.is = is;
      })(integer || (exports2.integer = integer = {}));
      var uinteger;
      (function(uinteger2) {
        uinteger2.MIN_VALUE = 0;
        uinteger2.MAX_VALUE = 2147483647;
        function is(value) {
          return typeof value === "number" && uinteger2.MIN_VALUE <= value && value <= uinteger2.MAX_VALUE;
        }
        uinteger2.is = is;
      })(uinteger || (exports2.uinteger = uinteger = {}));
      var Position;
      (function(Position2) {
        function create(line, character) {
          if (line === Number.MAX_VALUE) {
            line = uinteger.MAX_VALUE;
          }
          if (character === Number.MAX_VALUE) {
            character = uinteger.MAX_VALUE;
          }
          return { line, character };
        }
        Position2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
        }
        Position2.is = is;
      })(Position || (exports2.Position = Position = {}));
      var Range;
      (function(Range2) {
        function create(one, two, three, four) {
          if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
            return { start: Position.create(one, two), end: Position.create(three, four) };
          } else if (Position.is(one) && Position.is(two)) {
            return { start: one, end: two };
          } else {
            throw new Error("Range#create called with invalid arguments[".concat(one, ", ").concat(two, ", ").concat(three, ", ").concat(four, "]"));
          }
        }
        Range2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);
        }
        Range2.is = is;
      })(Range || (exports2.Range = Range = {}));
      var Location;
      (function(Location2) {
        function create(uri, range) {
          return { uri, range };
        }
        Location2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
        }
        Location2.is = is;
      })(Location || (exports2.Location = Location = {}));
      var LocationLink;
      (function(LocationLink2) {
        function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
          return { targetUri, targetRange, targetSelectionRange, originSelectionRange };
        }
        LocationLink2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri) && Range.is(candidate.targetSelectionRange) && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
        }
        LocationLink2.is = is;
      })(LocationLink || (exports2.LocationLink = LocationLink = {}));
      var Color;
      (function(Color2) {
        function create(red, green, blue, alpha) {
          return {
            red,
            green,
            blue,
            alpha
          };
        }
        Color2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1) && Is.numberRange(candidate.green, 0, 1) && Is.numberRange(candidate.blue, 0, 1) && Is.numberRange(candidate.alpha, 0, 1);
        }
        Color2.is = is;
      })(Color || (exports2.Color = Color = {}));
      var ColorInformation;
      (function(ColorInformation2) {
        function create(range, color) {
          return {
            range,
            color
          };
        }
        ColorInformation2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);
        }
        ColorInformation2.is = is;
      })(ColorInformation || (exports2.ColorInformation = ColorInformation = {}));
      var ColorPresentation;
      (function(ColorPresentation2) {
        function create(label, textEdit, additionalTextEdits) {
          return {
            label,
            textEdit,
            additionalTextEdits
          };
        }
        ColorPresentation2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate)) && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
        }
        ColorPresentation2.is = is;
      })(ColorPresentation || (exports2.ColorPresentation = ColorPresentation = {}));
      var FoldingRangeKind;
      (function(FoldingRangeKind2) {
        FoldingRangeKind2.Comment = "comment";
        FoldingRangeKind2.Imports = "imports";
        FoldingRangeKind2.Region = "region";
      })(FoldingRangeKind || (exports2.FoldingRangeKind = FoldingRangeKind = {}));
      var FoldingRange;
      (function(FoldingRange2) {
        function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {
          var result = {
            startLine,
            endLine
          };
          if (Is.defined(startCharacter)) {
            result.startCharacter = startCharacter;
          }
          if (Is.defined(endCharacter)) {
            result.endCharacter = endCharacter;
          }
          if (Is.defined(kind)) {
            result.kind = kind;
          }
          if (Is.defined(collapsedText)) {
            result.collapsedText = collapsedText;
          }
          return result;
        }
        FoldingRange2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine) && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter)) && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter)) && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
        }
        FoldingRange2.is = is;
      })(FoldingRange || (exports2.FoldingRange = FoldingRange = {}));
      var DiagnosticRelatedInformation;
      (function(DiagnosticRelatedInformation2) {
        function create(location, message) {
          return {
            location,
            message
          };
        }
        DiagnosticRelatedInformation2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
        }
        DiagnosticRelatedInformation2.is = is;
      })(DiagnosticRelatedInformation || (exports2.DiagnosticRelatedInformation = DiagnosticRelatedInformation = {}));
      var DiagnosticSeverity;
      (function(DiagnosticSeverity2) {
        DiagnosticSeverity2.Error = 1;
        DiagnosticSeverity2.Warning = 2;
        DiagnosticSeverity2.Information = 3;
        DiagnosticSeverity2.Hint = 4;
      })(DiagnosticSeverity || (exports2.DiagnosticSeverity = DiagnosticSeverity = {}));
      var DiagnosticTag;
      (function(DiagnosticTag2) {
        DiagnosticTag2.Unnecessary = 1;
        DiagnosticTag2.Deprecated = 2;
      })(DiagnosticTag || (exports2.DiagnosticTag = DiagnosticTag = {}));
      var CodeDescription;
      (function(CodeDescription2) {
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.string(candidate.href);
        }
        CodeDescription2.is = is;
      })(CodeDescription || (exports2.CodeDescription = CodeDescription = {}));
      var Diagnostic;
      (function(Diagnostic2) {
        function create(range, message, severity, code, source, relatedInformation) {
          var result = { range, message };
          if (Is.defined(severity)) {
            result.severity = severity;
          }
          if (Is.defined(code)) {
            result.code = code;
          }
          if (Is.defined(source)) {
            result.source = source;
          }
          if (Is.defined(relatedInformation)) {
            result.relatedInformation = relatedInformation;
          }
          return result;
        }
        Diagnostic2.create = create;
        function is(value) {
          var _a;
          var candidate = value;
          return Is.defined(candidate) && Range.is(candidate.range) && Is.string(candidate.message) && (Is.number(candidate.severity) || Is.undefined(candidate.severity)) && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) && (Is.undefined(candidate.codeDescription) || Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)) && (Is.string(candidate.source) || Is.undefined(candidate.source)) && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
        }
        Diagnostic2.is = is;
      })(Diagnostic || (exports2.Diagnostic = Diagnostic = {}));
      var Command;
      (function(Command2) {
        function create(title, command) {
          var args = [];
          for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
          }
          var result = { title, command };
          if (Is.defined(args) && args.length > 0) {
            result.arguments = args;
          }
          return result;
        }
        Command2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
        }
        Command2.is = is;
      })(Command || (exports2.Command = Command = {}));
      var TextEdit;
      (function(TextEdit2) {
        function replace(range, newText) {
          return { range, newText };
        }
        TextEdit2.replace = replace;
        function insert(position, newText) {
          return { range: { start: position, end: position }, newText };
        }
        TextEdit2.insert = insert;
        function del(range) {
          return { range, newText: "" };
        }
        TextEdit2.del = del;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.string(candidate.newText) && Range.is(candidate.range);
        }
        TextEdit2.is = is;
      })(TextEdit || (exports2.TextEdit = TextEdit = {}));
      var ChangeAnnotation;
      (function(ChangeAnnotation2) {
        function create(label, needsConfirmation, description) {
          var result = { label };
          if (needsConfirmation !== void 0) {
            result.needsConfirmation = needsConfirmation;
          }
          if (description !== void 0) {
            result.description = description;
          }
          return result;
        }
        ChangeAnnotation2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
        }
        ChangeAnnotation2.is = is;
      })(ChangeAnnotation || (exports2.ChangeAnnotation = ChangeAnnotation = {}));
      var ChangeAnnotationIdentifier;
      (function(ChangeAnnotationIdentifier2) {
        function is(value) {
          var candidate = value;
          return Is.string(candidate);
        }
        ChangeAnnotationIdentifier2.is = is;
      })(ChangeAnnotationIdentifier || (exports2.ChangeAnnotationIdentifier = ChangeAnnotationIdentifier = {}));
      var AnnotatedTextEdit;
      (function(AnnotatedTextEdit2) {
        function replace(range, newText, annotation) {
          return { range, newText, annotationId: annotation };
        }
        AnnotatedTextEdit2.replace = replace;
        function insert(position, newText, annotation) {
          return { range: { start: position, end: position }, newText, annotationId: annotation };
        }
        AnnotatedTextEdit2.insert = insert;
        function del(range, annotation) {
          return { range, newText: "", annotationId: annotation };
        }
        AnnotatedTextEdit2.del = del;
        function is(value) {
          var candidate = value;
          return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        AnnotatedTextEdit2.is = is;
      })(AnnotatedTextEdit || (exports2.AnnotatedTextEdit = AnnotatedTextEdit = {}));
      var TextDocumentEdit;
      (function(TextDocumentEdit2) {
        function create(textDocument, edits) {
          return { textDocument, edits };
        }
        TextDocumentEdit2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);
        }
        TextDocumentEdit2.is = is;
      })(TextDocumentEdit || (exports2.TextDocumentEdit = TextDocumentEdit = {}));
      var CreateFile;
      (function(CreateFile2) {
        function create(uri, options, annotation) {
          var result = {
            kind: "create",
            uri
          };
          if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
            result.options = options;
          }
          if (annotation !== void 0) {
            result.annotationId = annotation;
          }
          return result;
        }
        CreateFile2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && candidate.kind === "create" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        CreateFile2.is = is;
      })(CreateFile || (exports2.CreateFile = CreateFile = {}));
      var RenameFile;
      (function(RenameFile2) {
        function create(oldUri, newUri, options, annotation) {
          var result = {
            kind: "rename",
            oldUri,
            newUri
          };
          if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
            result.options = options;
          }
          if (annotation !== void 0) {
            result.annotationId = annotation;
          }
          return result;
        }
        RenameFile2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && candidate.kind === "rename" && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        RenameFile2.is = is;
      })(RenameFile || (exports2.RenameFile = RenameFile = {}));
      var DeleteFile;
      (function(DeleteFile2) {
        function create(uri, options, annotation) {
          var result = {
            kind: "delete",
            uri
          };
          if (options !== void 0 && (options.recursive !== void 0 || options.ignoreIfNotExists !== void 0)) {
            result.options = options;
          }
          if (annotation !== void 0) {
            result.annotationId = annotation;
          }
          return result;
        }
        DeleteFile2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && candidate.kind === "delete" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.recursive === void 0 || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || Is.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        DeleteFile2.is = is;
      })(DeleteFile || (exports2.DeleteFile = DeleteFile = {}));
      var WorkspaceEdit;
      (function(WorkspaceEdit2) {
        function is(value) {
          var candidate = value;
          return candidate && (candidate.changes !== void 0 || candidate.documentChanges !== void 0) && (candidate.documentChanges === void 0 || candidate.documentChanges.every(function(change) {
            if (Is.string(change.kind)) {
              return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
            } else {
              return TextDocumentEdit.is(change);
            }
          }));
        }
        WorkspaceEdit2.is = is;
      })(WorkspaceEdit || (exports2.WorkspaceEdit = WorkspaceEdit = {}));
      var TextEditChangeImpl = function() {
        function TextEditChangeImpl2(edits, changeAnnotations) {
          this.edits = edits;
          this.changeAnnotations = changeAnnotations;
        }
        TextEditChangeImpl2.prototype.insert = function(position, newText, annotation) {
          var edit;
          var id;
          if (annotation === void 0) {
            edit = TextEdit.insert(position, newText);
          } else if (ChangeAnnotationIdentifier.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit.insert(position, newText, annotation);
          } else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit.insert(position, newText, id);
          }
          this.edits.push(edit);
          if (id !== void 0) {
            return id;
          }
        };
        TextEditChangeImpl2.prototype.replace = function(range, newText, annotation) {
          var edit;
          var id;
          if (annotation === void 0) {
            edit = TextEdit.replace(range, newText);
          } else if (ChangeAnnotationIdentifier.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit.replace(range, newText, annotation);
          } else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit.replace(range, newText, id);
          }
          this.edits.push(edit);
          if (id !== void 0) {
            return id;
          }
        };
        TextEditChangeImpl2.prototype.delete = function(range, annotation) {
          var edit;
          var id;
          if (annotation === void 0) {
            edit = TextEdit.del(range);
          } else if (ChangeAnnotationIdentifier.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit.del(range, annotation);
          } else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit.del(range, id);
          }
          this.edits.push(edit);
          if (id !== void 0) {
            return id;
          }
        };
        TextEditChangeImpl2.prototype.add = function(edit) {
          this.edits.push(edit);
        };
        TextEditChangeImpl2.prototype.all = function() {
          return this.edits;
        };
        TextEditChangeImpl2.prototype.clear = function() {
          this.edits.splice(0, this.edits.length);
        };
        TextEditChangeImpl2.prototype.assertChangeAnnotations = function(value) {
          if (value === void 0) {
            throw new Error("Text edit change is not configured to manage change annotations.");
          }
        };
        return TextEditChangeImpl2;
      }();
      var ChangeAnnotations = function() {
        function ChangeAnnotations2(annotations) {
          this._annotations = annotations === void 0 ? /* @__PURE__ */ Object.create(null) : annotations;
          this._counter = 0;
          this._size = 0;
        }
        ChangeAnnotations2.prototype.all = function() {
          return this._annotations;
        };
        Object.defineProperty(ChangeAnnotations2.prototype, "size", {
          get: function() {
            return this._size;
          },
          enumerable: false,
          configurable: true
        });
        ChangeAnnotations2.prototype.manage = function(idOrAnnotation, annotation) {
          var id;
          if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
            id = idOrAnnotation;
          } else {
            id = this.nextId();
            annotation = idOrAnnotation;
          }
          if (this._annotations[id] !== void 0) {
            throw new Error("Id ".concat(id, " is already in use."));
          }
          if (annotation === void 0) {
            throw new Error("No annotation provided for id ".concat(id));
          }
          this._annotations[id] = annotation;
          this._size++;
          return id;
        };
        ChangeAnnotations2.prototype.nextId = function() {
          this._counter++;
          return this._counter.toString();
        };
        return ChangeAnnotations2;
      }();
      var WorkspaceChange = function() {
        function WorkspaceChange2(workspaceEdit) {
          var _this = this;
          this._textEditChanges = /* @__PURE__ */ Object.create(null);
          if (workspaceEdit !== void 0) {
            this._workspaceEdit = workspaceEdit;
            if (workspaceEdit.documentChanges) {
              this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
              workspaceEdit.changeAnnotations = this._changeAnnotations.all();
              workspaceEdit.documentChanges.forEach(function(change) {
                if (TextDocumentEdit.is(change)) {
                  var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);
                  _this._textEditChanges[change.textDocument.uri] = textEditChange;
                }
              });
            } else if (workspaceEdit.changes) {
              Object.keys(workspaceEdit.changes).forEach(function(key) {
                var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
                _this._textEditChanges[key] = textEditChange;
              });
            }
          } else {
            this._workspaceEdit = {};
          }
        }
        Object.defineProperty(WorkspaceChange2.prototype, "edit", {
          get: function() {
            this.initDocumentChanges();
            if (this._changeAnnotations !== void 0) {
              if (this._changeAnnotations.size === 0) {
                this._workspaceEdit.changeAnnotations = void 0;
              } else {
                this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
              }
            }
            return this._workspaceEdit;
          },
          enumerable: false,
          configurable: true
        });
        WorkspaceChange2.prototype.getTextEditChange = function(key) {
          if (OptionalVersionedTextDocumentIdentifier.is(key)) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === void 0) {
              throw new Error("Workspace edit is not configured for document changes.");
            }
            var textDocument = { uri: key.uri, version: key.version };
            var result = this._textEditChanges[textDocument.uri];
            if (!result) {
              var edits = [];
              var textDocumentEdit = {
                textDocument,
                edits
              };
              this._workspaceEdit.documentChanges.push(textDocumentEdit);
              result = new TextEditChangeImpl(edits, this._changeAnnotations);
              this._textEditChanges[textDocument.uri] = result;
            }
            return result;
          } else {
            this.initChanges();
            if (this._workspaceEdit.changes === void 0) {
              throw new Error("Workspace edit is not configured for normal text edit changes.");
            }
            var result = this._textEditChanges[key];
            if (!result) {
              var edits = [];
              this._workspaceEdit.changes[key] = edits;
              result = new TextEditChangeImpl(edits);
              this._textEditChanges[key] = result;
            }
            return result;
          }
        };
        WorkspaceChange2.prototype.initDocumentChanges = function() {
          if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
            this._changeAnnotations = new ChangeAnnotations();
            this._workspaceEdit.documentChanges = [];
            this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
          }
        };
        WorkspaceChange2.prototype.initChanges = function() {
          if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
            this._workspaceEdit.changes = /* @__PURE__ */ Object.create(null);
          }
        };
        WorkspaceChange2.prototype.createFile = function(uri, optionsOrAnnotation, options) {
          this.initDocumentChanges();
          if (this._workspaceEdit.documentChanges === void 0) {
            throw new Error("Workspace edit is not configured for document changes.");
          }
          var annotation;
          if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
          } else {
            options = optionsOrAnnotation;
          }
          var operation;
          var id;
          if (annotation === void 0) {
            operation = CreateFile.create(uri, options);
          } else {
            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = CreateFile.create(uri, options, id);
          }
          this._workspaceEdit.documentChanges.push(operation);
          if (id !== void 0) {
            return id;
          }
        };
        WorkspaceChange2.prototype.renameFile = function(oldUri, newUri, optionsOrAnnotation, options) {
          this.initDocumentChanges();
          if (this._workspaceEdit.documentChanges === void 0) {
            throw new Error("Workspace edit is not configured for document changes.");
          }
          var annotation;
          if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
          } else {
            options = optionsOrAnnotation;
          }
          var operation;
          var id;
          if (annotation === void 0) {
            operation = RenameFile.create(oldUri, newUri, options);
          } else {
            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = RenameFile.create(oldUri, newUri, options, id);
          }
          this._workspaceEdit.documentChanges.push(operation);
          if (id !== void 0) {
            return id;
          }
        };
        WorkspaceChange2.prototype.deleteFile = function(uri, optionsOrAnnotation, options) {
          this.initDocumentChanges();
          if (this._workspaceEdit.documentChanges === void 0) {
            throw new Error("Workspace edit is not configured for document changes.");
          }
          var annotation;
          if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
          } else {
            options = optionsOrAnnotation;
          }
          var operation;
          var id;
          if (annotation === void 0) {
            operation = DeleteFile.create(uri, options);
          } else {
            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = DeleteFile.create(uri, options, id);
          }
          this._workspaceEdit.documentChanges.push(operation);
          if (id !== void 0) {
            return id;
          }
        };
        return WorkspaceChange2;
      }();
      exports2.WorkspaceChange = WorkspaceChange;
      var TextDocumentIdentifier;
      (function(TextDocumentIdentifier2) {
        function create(uri) {
          return { uri };
        }
        TextDocumentIdentifier2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri);
        }
        TextDocumentIdentifier2.is = is;
      })(TextDocumentIdentifier || (exports2.TextDocumentIdentifier = TextDocumentIdentifier = {}));
      var VersionedTextDocumentIdentifier;
      (function(VersionedTextDocumentIdentifier2) {
        function create(uri, version) {
          return { uri, version };
        }
        VersionedTextDocumentIdentifier2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
        }
        VersionedTextDocumentIdentifier2.is = is;
      })(VersionedTextDocumentIdentifier || (exports2.VersionedTextDocumentIdentifier = VersionedTextDocumentIdentifier = {}));
      var OptionalVersionedTextDocumentIdentifier;
      (function(OptionalVersionedTextDocumentIdentifier2) {
        function create(uri, version) {
          return { uri, version };
        }
        OptionalVersionedTextDocumentIdentifier2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
        }
        OptionalVersionedTextDocumentIdentifier2.is = is;
      })(OptionalVersionedTextDocumentIdentifier || (exports2.OptionalVersionedTextDocumentIdentifier = OptionalVersionedTextDocumentIdentifier = {}));
      var TextDocumentItem;
      (function(TextDocumentItem2) {
        function create(uri, languageId, version, text) {
          return { uri, languageId, version, text };
        }
        TextDocumentItem2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
        }
        TextDocumentItem2.is = is;
      })(TextDocumentItem || (exports2.TextDocumentItem = TextDocumentItem = {}));
      var MarkupKind;
      (function(MarkupKind2) {
        MarkupKind2.PlainText = "plaintext";
        MarkupKind2.Markdown = "markdown";
        function is(value) {
          var candidate = value;
          return candidate === MarkupKind2.PlainText || candidate === MarkupKind2.Markdown;
        }
        MarkupKind2.is = is;
      })(MarkupKind || (exports2.MarkupKind = MarkupKind = {}));
      var MarkupContent;
      (function(MarkupContent2) {
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
        }
        MarkupContent2.is = is;
      })(MarkupContent || (exports2.MarkupContent = MarkupContent = {}));
      var CompletionItemKind;
      (function(CompletionItemKind2) {
        CompletionItemKind2.Text = 1;
        CompletionItemKind2.Method = 2;
        CompletionItemKind2.Function = 3;
        CompletionItemKind2.Constructor = 4;
        CompletionItemKind2.Field = 5;
        CompletionItemKind2.Variable = 6;
        CompletionItemKind2.Class = 7;
        CompletionItemKind2.Interface = 8;
        CompletionItemKind2.Module = 9;
        CompletionItemKind2.Property = 10;
        CompletionItemKind2.Unit = 11;
        CompletionItemKind2.Value = 12;
        CompletionItemKind2.Enum = 13;
        CompletionItemKind2.Keyword = 14;
        CompletionItemKind2.Snippet = 15;
        CompletionItemKind2.Color = 16;
        CompletionItemKind2.File = 17;
        CompletionItemKind2.Reference = 18;
        CompletionItemKind2.Folder = 19;
        CompletionItemKind2.EnumMember = 20;
        CompletionItemKind2.Constant = 21;
        CompletionItemKind2.Struct = 22;
        CompletionItemKind2.Event = 23;
        CompletionItemKind2.Operator = 24;
        CompletionItemKind2.TypeParameter = 25;
      })(CompletionItemKind || (exports2.CompletionItemKind = CompletionItemKind = {}));
      var InsertTextFormat;
      (function(InsertTextFormat2) {
        InsertTextFormat2.PlainText = 1;
        InsertTextFormat2.Snippet = 2;
      })(InsertTextFormat || (exports2.InsertTextFormat = InsertTextFormat = {}));
      var CompletionItemTag;
      (function(CompletionItemTag2) {
        CompletionItemTag2.Deprecated = 1;
      })(CompletionItemTag || (exports2.CompletionItemTag = CompletionItemTag = {}));
      var InsertReplaceEdit;
      (function(InsertReplaceEdit2) {
        function create(newText, insert, replace) {
          return { newText, insert, replace };
        }
        InsertReplaceEdit2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);
        }
        InsertReplaceEdit2.is = is;
      })(InsertReplaceEdit || (exports2.InsertReplaceEdit = InsertReplaceEdit = {}));
      var InsertTextMode;
      (function(InsertTextMode2) {
        InsertTextMode2.asIs = 1;
        InsertTextMode2.adjustIndentation = 2;
      })(InsertTextMode || (exports2.InsertTextMode = InsertTextMode = {}));
      var CompletionItemLabelDetails;
      (function(CompletionItemLabelDetails2) {
        function is(value) {
          var candidate = value;
          return candidate && (Is.string(candidate.detail) || candidate.detail === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
        }
        CompletionItemLabelDetails2.is = is;
      })(CompletionItemLabelDetails || (exports2.CompletionItemLabelDetails = CompletionItemLabelDetails = {}));
      var CompletionItem;
      (function(CompletionItem2) {
        function create(label) {
          return { label };
        }
        CompletionItem2.create = create;
      })(CompletionItem || (exports2.CompletionItem = CompletionItem = {}));
      var CompletionList;
      (function(CompletionList2) {
        function create(items, isIncomplete) {
          return { items: items ? items : [], isIncomplete: !!isIncomplete };
        }
        CompletionList2.create = create;
      })(CompletionList || (exports2.CompletionList = CompletionList = {}));
      var MarkedString;
      (function(MarkedString2) {
        function fromPlainText(plainText) {
          return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
        }
        MarkedString2.fromPlainText = fromPlainText;
        function is(value) {
          var candidate = value;
          return Is.string(candidate) || Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value);
        }
        MarkedString2.is = is;
      })(MarkedString || (exports2.MarkedString = MarkedString = {}));
      var Hover;
      (function(Hover2) {
        function is(value) {
          var candidate = value;
          return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) || MarkedString.is(candidate.contents) || Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === void 0 || Range.is(value.range));
        }
        Hover2.is = is;
      })(Hover || (exports2.Hover = Hover = {}));
      var ParameterInformation;
      (function(ParameterInformation2) {
        function create(label, documentation) {
          return documentation ? { label, documentation } : { label };
        }
        ParameterInformation2.create = create;
      })(ParameterInformation || (exports2.ParameterInformation = ParameterInformation = {}));
      var SignatureInformation;
      (function(SignatureInformation2) {
        function create(label, documentation) {
          var parameters = [];
          for (var _i = 2; _i < arguments.length; _i++) {
            parameters[_i - 2] = arguments[_i];
          }
          var result = { label };
          if (Is.defined(documentation)) {
            result.documentation = documentation;
          }
          if (Is.defined(parameters)) {
            result.parameters = parameters;
          } else {
            result.parameters = [];
          }
          return result;
        }
        SignatureInformation2.create = create;
      })(SignatureInformation || (exports2.SignatureInformation = SignatureInformation = {}));
      var DocumentHighlightKind;
      (function(DocumentHighlightKind2) {
        DocumentHighlightKind2.Text = 1;
        DocumentHighlightKind2.Read = 2;
        DocumentHighlightKind2.Write = 3;
      })(DocumentHighlightKind || (exports2.DocumentHighlightKind = DocumentHighlightKind = {}));
      var DocumentHighlight;
      (function(DocumentHighlight2) {
        function create(range, kind) {
          var result = { range };
          if (Is.number(kind)) {
            result.kind = kind;
          }
          return result;
        }
        DocumentHighlight2.create = create;
      })(DocumentHighlight || (exports2.DocumentHighlight = DocumentHighlight = {}));
      var SymbolKind;
      (function(SymbolKind2) {
        SymbolKind2.File = 1;
        SymbolKind2.Module = 2;
        SymbolKind2.Namespace = 3;
        SymbolKind2.Package = 4;
        SymbolKind2.Class = 5;
        SymbolKind2.Method = 6;
        SymbolKind2.Property = 7;
        SymbolKind2.Field = 8;
        SymbolKind2.Constructor = 9;
        SymbolKind2.Enum = 10;
        SymbolKind2.Interface = 11;
        SymbolKind2.Function = 12;
        SymbolKind2.Variable = 13;
        SymbolKind2.Constant = 14;
        SymbolKind2.String = 15;
        SymbolKind2.Number = 16;
        SymbolKind2.Boolean = 17;
        SymbolKind2.Array = 18;
        SymbolKind2.Object = 19;
        SymbolKind2.Key = 20;
        SymbolKind2.Null = 21;
        SymbolKind2.EnumMember = 22;
        SymbolKind2.Struct = 23;
        SymbolKind2.Event = 24;
        SymbolKind2.Operator = 25;
        SymbolKind2.TypeParameter = 26;
      })(SymbolKind || (exports2.SymbolKind = SymbolKind = {}));
      var SymbolTag;
      (function(SymbolTag2) {
        SymbolTag2.Deprecated = 1;
      })(SymbolTag || (exports2.SymbolTag = SymbolTag = {}));
      var SymbolInformation;
      (function(SymbolInformation2) {
        function create(name, kind, range, uri, containerName) {
          var result = {
            name,
            kind,
            location: { uri, range }
          };
          if (containerName) {
            result.containerName = containerName;
          }
          return result;
        }
        SymbolInformation2.create = create;
      })(SymbolInformation || (exports2.SymbolInformation = SymbolInformation = {}));
      var WorkspaceSymbol;
      (function(WorkspaceSymbol2) {
        function create(name, kind, uri, range) {
          return range !== void 0 ? { name, kind, location: { uri, range } } : { name, kind, location: { uri } };
        }
        WorkspaceSymbol2.create = create;
      })(WorkspaceSymbol || (exports2.WorkspaceSymbol = WorkspaceSymbol = {}));
      var DocumentSymbol;
      (function(DocumentSymbol2) {
        function create(name, detail, kind, range, selectionRange, children) {
          var result = {
            name,
            detail,
            kind,
            range,
            selectionRange
          };
          if (children !== void 0) {
            result.children = children;
          }
          return result;
        }
        DocumentSymbol2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && Is.string(candidate.name) && Is.number(candidate.kind) && Range.is(candidate.range) && Range.is(candidate.selectionRange) && (candidate.detail === void 0 || Is.string(candidate.detail)) && (candidate.deprecated === void 0 || Is.boolean(candidate.deprecated)) && (candidate.children === void 0 || Array.isArray(candidate.children)) && (candidate.tags === void 0 || Array.isArray(candidate.tags));
        }
        DocumentSymbol2.is = is;
      })(DocumentSymbol || (exports2.DocumentSymbol = DocumentSymbol = {}));
      var CodeActionKind;
      (function(CodeActionKind2) {
        CodeActionKind2.Empty = "";
        CodeActionKind2.QuickFix = "quickfix";
        CodeActionKind2.Refactor = "refactor";
        CodeActionKind2.RefactorExtract = "refactor.extract";
        CodeActionKind2.RefactorInline = "refactor.inline";
        CodeActionKind2.RefactorRewrite = "refactor.rewrite";
        CodeActionKind2.Source = "source";
        CodeActionKind2.SourceOrganizeImports = "source.organizeImports";
        CodeActionKind2.SourceFixAll = "source.fixAll";
      })(CodeActionKind || (exports2.CodeActionKind = CodeActionKind = {}));
      var CodeActionTriggerKind;
      (function(CodeActionTriggerKind2) {
        CodeActionTriggerKind2.Invoked = 1;
        CodeActionTriggerKind2.Automatic = 2;
      })(CodeActionTriggerKind || (exports2.CodeActionTriggerKind = CodeActionTriggerKind = {}));
      var CodeActionContext;
      (function(CodeActionContext2) {
        function create(diagnostics, only, triggerKind) {
          var result = { diagnostics };
          if (only !== void 0 && only !== null) {
            result.only = only;
          }
          if (triggerKind !== void 0 && triggerKind !== null) {
            result.triggerKind = triggerKind;
          }
          return result;
        }
        CodeActionContext2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === void 0 || Is.typedArray(candidate.only, Is.string)) && (candidate.triggerKind === void 0 || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);
        }
        CodeActionContext2.is = is;
      })(CodeActionContext || (exports2.CodeActionContext = CodeActionContext = {}));
      var CodeAction;
      (function(CodeAction2) {
        function create(title, kindOrCommandOrEdit, kind) {
          var result = { title };
          var checkKind = true;
          if (typeof kindOrCommandOrEdit === "string") {
            checkKind = false;
            result.kind = kindOrCommandOrEdit;
          } else if (Command.is(kindOrCommandOrEdit)) {
            result.command = kindOrCommandOrEdit;
          } else {
            result.edit = kindOrCommandOrEdit;
          }
          if (checkKind && kind !== void 0) {
            result.kind = kind;
          }
          return result;
        }
        CodeAction2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && Is.string(candidate.title) && (candidate.diagnostics === void 0 || Is.typedArray(candidate.diagnostics, Diagnostic.is)) && (candidate.kind === void 0 || Is.string(candidate.kind)) && (candidate.edit !== void 0 || candidate.command !== void 0) && (candidate.command === void 0 || Command.is(candidate.command)) && (candidate.isPreferred === void 0 || Is.boolean(candidate.isPreferred)) && (candidate.edit === void 0 || WorkspaceEdit.is(candidate.edit));
        }
        CodeAction2.is = is;
      })(CodeAction || (exports2.CodeAction = CodeAction = {}));
      var CodeLens;
      (function(CodeLens2) {
        function create(range, data) {
          var result = { range };
          if (Is.defined(data)) {
            result.data = data;
          }
          return result;
        }
        CodeLens2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
        }
        CodeLens2.is = is;
      })(CodeLens || (exports2.CodeLens = CodeLens = {}));
      var FormattingOptions;
      (function(FormattingOptions2) {
        function create(tabSize, insertSpaces) {
          return { tabSize, insertSpaces };
        }
        FormattingOptions2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
        }
        FormattingOptions2.is = is;
      })(FormattingOptions || (exports2.FormattingOptions = FormattingOptions = {}));
      var DocumentLink;
      (function(DocumentLink2) {
        function create(range, target, data) {
          return { range, target, data };
        }
        DocumentLink2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
        }
        DocumentLink2.is = is;
      })(DocumentLink || (exports2.DocumentLink = DocumentLink = {}));
      var SelectionRange;
      (function(SelectionRange2) {
        function create(range, parent) {
          return { range, parent };
        }
        SelectionRange2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === void 0 || SelectionRange2.is(candidate.parent));
        }
        SelectionRange2.is = is;
      })(SelectionRange || (exports2.SelectionRange = SelectionRange = {}));
      var SemanticTokenTypes;
      (function(SemanticTokenTypes2) {
        SemanticTokenTypes2["namespace"] = "namespace";
        SemanticTokenTypes2["type"] = "type";
        SemanticTokenTypes2["class"] = "class";
        SemanticTokenTypes2["enum"] = "enum";
        SemanticTokenTypes2["interface"] = "interface";
        SemanticTokenTypes2["struct"] = "struct";
        SemanticTokenTypes2["typeParameter"] = "typeParameter";
        SemanticTokenTypes2["parameter"] = "parameter";
        SemanticTokenTypes2["variable"] = "variable";
        SemanticTokenTypes2["property"] = "property";
        SemanticTokenTypes2["enumMember"] = "enumMember";
        SemanticTokenTypes2["event"] = "event";
        SemanticTokenTypes2["function"] = "function";
        SemanticTokenTypes2["method"] = "method";
        SemanticTokenTypes2["macro"] = "macro";
        SemanticTokenTypes2["keyword"] = "keyword";
        SemanticTokenTypes2["modifier"] = "modifier";
        SemanticTokenTypes2["comment"] = "comment";
        SemanticTokenTypes2["string"] = "string";
        SemanticTokenTypes2["number"] = "number";
        SemanticTokenTypes2["regexp"] = "regexp";
        SemanticTokenTypes2["operator"] = "operator";
        SemanticTokenTypes2["decorator"] = "decorator";
      })(SemanticTokenTypes || (exports2.SemanticTokenTypes = SemanticTokenTypes = {}));
      var SemanticTokenModifiers;
      (function(SemanticTokenModifiers2) {
        SemanticTokenModifiers2["declaration"] = "declaration";
        SemanticTokenModifiers2["definition"] = "definition";
        SemanticTokenModifiers2["readonly"] = "readonly";
        SemanticTokenModifiers2["static"] = "static";
        SemanticTokenModifiers2["deprecated"] = "deprecated";
        SemanticTokenModifiers2["abstract"] = "abstract";
        SemanticTokenModifiers2["async"] = "async";
        SemanticTokenModifiers2["modification"] = "modification";
        SemanticTokenModifiers2["documentation"] = "documentation";
        SemanticTokenModifiers2["defaultLibrary"] = "defaultLibrary";
      })(SemanticTokenModifiers || (exports2.SemanticTokenModifiers = SemanticTokenModifiers = {}));
      var SemanticTokens;
      (function(SemanticTokens2) {
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && (candidate.resultId === void 0 || typeof candidate.resultId === "string") && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === "number");
        }
        SemanticTokens2.is = is;
      })(SemanticTokens || (exports2.SemanticTokens = SemanticTokens = {}));
      var InlineValueText;
      (function(InlineValueText2) {
        function create(range, text) {
          return { range, text };
        }
        InlineValueText2.create = create;
        function is(value) {
          var candidate = value;
          return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);
        }
        InlineValueText2.is = is;
      })(InlineValueText || (exports2.InlineValueText = InlineValueText = {}));
      var InlineValueVariableLookup;
      (function(InlineValueVariableLookup2) {
        function create(range, variableName, caseSensitiveLookup) {
          return { range, variableName, caseSensitiveLookup };
        }
        InlineValueVariableLookup2.create = create;
        function is(value) {
          var candidate = value;
          return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup) && (Is.string(candidate.variableName) || candidate.variableName === void 0);
        }
        InlineValueVariableLookup2.is = is;
      })(InlineValueVariableLookup || (exports2.InlineValueVariableLookup = InlineValueVariableLookup = {}));
      var InlineValueEvaluatableExpression;
      (function(InlineValueEvaluatableExpression2) {
        function create(range, expression) {
          return { range, expression };
        }
        InlineValueEvaluatableExpression2.create = create;
        function is(value) {
          var candidate = value;
          return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && (Is.string(candidate.expression) || candidate.expression === void 0);
        }
        InlineValueEvaluatableExpression2.is = is;
      })(InlineValueEvaluatableExpression || (exports2.InlineValueEvaluatableExpression = InlineValueEvaluatableExpression = {}));
      var InlineValueContext;
      (function(InlineValueContext2) {
        function create(frameId, stoppedLocation) {
          return { frameId, stoppedLocation };
        }
        InlineValueContext2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Range.is(value.stoppedLocation);
        }
        InlineValueContext2.is = is;
      })(InlineValueContext || (exports2.InlineValueContext = InlineValueContext = {}));
      var InlayHintKind;
      (function(InlayHintKind2) {
        InlayHintKind2.Type = 1;
        InlayHintKind2.Parameter = 2;
        function is(value) {
          return value === 1 || value === 2;
        }
        InlayHintKind2.is = is;
      })(InlayHintKind || (exports2.InlayHintKind = InlayHintKind = {}));
      var InlayHintLabelPart;
      (function(InlayHintLabelPart2) {
        function create(value) {
          return { value };
        }
        InlayHintLabelPart2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.location === void 0 || Location.is(candidate.location)) && (candidate.command === void 0 || Command.is(candidate.command));
        }
        InlayHintLabelPart2.is = is;
      })(InlayHintLabelPart || (exports2.InlayHintLabelPart = InlayHintLabelPart = {}));
      var InlayHint;
      (function(InlayHint2) {
        function create(position, label, kind) {
          var result = { position, label };
          if (kind !== void 0) {
            result.kind = kind;
          }
          return result;
        }
        InlayHint2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Position.is(candidate.position) && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is)) && (candidate.kind === void 0 || InlayHintKind.is(candidate.kind)) && candidate.textEdits === void 0 || Is.typedArray(candidate.textEdits, TextEdit.is) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.paddingLeft === void 0 || Is.boolean(candidate.paddingLeft)) && (candidate.paddingRight === void 0 || Is.boolean(candidate.paddingRight));
        }
        InlayHint2.is = is;
      })(InlayHint || (exports2.InlayHint = InlayHint = {}));
      var StringValue;
      (function(StringValue2) {
        function createSnippet(value) {
          return { kind: "snippet", value };
        }
        StringValue2.createSnippet = createSnippet;
      })(StringValue || (exports2.StringValue = StringValue = {}));
      var InlineCompletionItem;
      (function(InlineCompletionItem2) {
        function create(insertText, filterText, range, command) {
          return { insertText, filterText, range, command };
        }
        InlineCompletionItem2.create = create;
      })(InlineCompletionItem || (exports2.InlineCompletionItem = InlineCompletionItem = {}));
      var InlineCompletionList;
      (function(InlineCompletionList2) {
        function create(items) {
          return { items };
        }
        InlineCompletionList2.create = create;
      })(InlineCompletionList || (exports2.InlineCompletionList = InlineCompletionList = {}));
      var InlineCompletionTriggerKind;
      (function(InlineCompletionTriggerKind2) {
        InlineCompletionTriggerKind2.Invoked = 0;
        InlineCompletionTriggerKind2.Automatic = 1;
      })(InlineCompletionTriggerKind || (exports2.InlineCompletionTriggerKind = InlineCompletionTriggerKind = {}));
      var SelectedCompletionInfo;
      (function(SelectedCompletionInfo2) {
        function create(range, text) {
          return { range, text };
        }
        SelectedCompletionInfo2.create = create;
      })(SelectedCompletionInfo || (exports2.SelectedCompletionInfo = SelectedCompletionInfo = {}));
      var InlineCompletionContext;
      (function(InlineCompletionContext2) {
        function create(triggerKind, selectedCompletionInfo) {
          return { triggerKind, selectedCompletionInfo };
        }
        InlineCompletionContext2.create = create;
      })(InlineCompletionContext || (exports2.InlineCompletionContext = InlineCompletionContext = {}));
      var WorkspaceFolder;
      (function(WorkspaceFolder2) {
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && URI.is(candidate.uri) && Is.string(candidate.name);
        }
        WorkspaceFolder2.is = is;
      })(WorkspaceFolder || (exports2.WorkspaceFolder = WorkspaceFolder = {}));
      exports2.EOL = ["\n", "\r\n", "\r"];
      var TextDocument;
      (function(TextDocument2) {
        function create(uri, languageId, version, content) {
          return new FullTextDocument(uri, languageId, version, content);
        }
        TextDocument2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount) && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
        }
        TextDocument2.is = is;
        function applyEdits(document, edits) {
          var text = document.getText();
          var sortedEdits = mergeSort(edits, function(a, b) {
            var diff = a.range.start.line - b.range.start.line;
            if (diff === 0) {
              return a.range.start.character - b.range.start.character;
            }
            return diff;
          });
          var lastModifiedOffset = text.length;
          for (var i = sortedEdits.length - 1; i >= 0; i--) {
            var e = sortedEdits[i];
            var startOffset = document.offsetAt(e.range.start);
            var endOffset = document.offsetAt(e.range.end);
            if (endOffset <= lastModifiedOffset) {
              text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
            } else {
              throw new Error("Overlapping edit");
            }
            lastModifiedOffset = startOffset;
          }
          return text;
        }
        TextDocument2.applyEdits = applyEdits;
        function mergeSort(data, compare) {
          if (data.length <= 1) {
            return data;
          }
          var p = data.length / 2 | 0;
          var left = data.slice(0, p);
          var right = data.slice(p);
          mergeSort(left, compare);
          mergeSort(right, compare);
          var leftIdx = 0;
          var rightIdx = 0;
          var i = 0;
          while (leftIdx < left.length && rightIdx < right.length) {
            var ret = compare(left[leftIdx], right[rightIdx]);
            if (ret <= 0) {
              data[i++] = left[leftIdx++];
            } else {
              data[i++] = right[rightIdx++];
            }
          }
          while (leftIdx < left.length) {
            data[i++] = left[leftIdx++];
          }
          while (rightIdx < right.length) {
            data[i++] = right[rightIdx++];
          }
          return data;
        }
      })(TextDocument || (exports2.TextDocument = TextDocument = {}));
      var FullTextDocument = function() {
        function FullTextDocument2(uri, languageId, version, content) {
          this._uri = uri;
          this._languageId = languageId;
          this._version = version;
          this._content = content;
          this._lineOffsets = void 0;
        }
        Object.defineProperty(FullTextDocument2.prototype, "uri", {
          get: function() {
            return this._uri;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(FullTextDocument2.prototype, "languageId", {
          get: function() {
            return this._languageId;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(FullTextDocument2.prototype, "version", {
          get: function() {
            return this._version;
          },
          enumerable: false,
          configurable: true
        });
        FullTextDocument2.prototype.getText = function(range) {
          if (range) {
            var start = this.offsetAt(range.start);
            var end = this.offsetAt(range.end);
            return this._content.substring(start, end);
          }
          return this._content;
        };
        FullTextDocument2.prototype.update = function(event, version) {
          this._content = event.text;
          this._version = version;
          this._lineOffsets = void 0;
        };
        FullTextDocument2.prototype.getLineOffsets = function() {
          if (this._lineOffsets === void 0) {
            var lineOffsets = [];
            var text = this._content;
            var isLineStart = true;
            for (var i = 0; i < text.length; i++) {
              if (isLineStart) {
                lineOffsets.push(i);
                isLineStart = false;
              }
              var ch = text.charAt(i);
              isLineStart = ch === "\r" || ch === "\n";
              if (ch === "\r" && i + 1 < text.length && text.charAt(i + 1) === "\n") {
                i++;
              }
            }
            if (isLineStart && text.length > 0) {
              lineOffsets.push(text.length);
            }
            this._lineOffsets = lineOffsets;
          }
          return this._lineOffsets;
        };
        FullTextDocument2.prototype.positionAt = function(offset) {
          offset = Math.max(Math.min(offset, this._content.length), 0);
          var lineOffsets = this.getLineOffsets();
          var low = 0, high = lineOffsets.length;
          if (high === 0) {
            return Position.create(0, offset);
          }
          while (low < high) {
            var mid = Math.floor((low + high) / 2);
            if (lineOffsets[mid] > offset) {
              high = mid;
            } else {
              low = mid + 1;
            }
          }
          var line = low - 1;
          return Position.create(line, offset - lineOffsets[line]);
        };
        FullTextDocument2.prototype.offsetAt = function(position) {
          var lineOffsets = this.getLineOffsets();
          if (position.line >= lineOffsets.length) {
            return this._content.length;
          } else if (position.line < 0) {
            return 0;
          }
          var lineOffset = lineOffsets[position.line];
          var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
          return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
        };
        Object.defineProperty(FullTextDocument2.prototype, "lineCount", {
          get: function() {
            return this.getLineOffsets().length;
          },
          enumerable: false,
          configurable: true
        });
        return FullTextDocument2;
      }();
      var Is;
      (function(Is2) {
        var toString = Object.prototype.toString;
        function defined(value) {
          return typeof value !== "undefined";
        }
        Is2.defined = defined;
        function undefined2(value) {
          return typeof value === "undefined";
        }
        Is2.undefined = undefined2;
        function boolean(value) {
          return value === true || value === false;
        }
        Is2.boolean = boolean;
        function string(value) {
          return toString.call(value) === "[object String]";
        }
        Is2.string = string;
        function number(value) {
          return toString.call(value) === "[object Number]";
        }
        Is2.number = number;
        function numberRange(value, min, max) {
          return toString.call(value) === "[object Number]" && min <= value && value <= max;
        }
        Is2.numberRange = numberRange;
        function integer2(value) {
          return toString.call(value) === "[object Number]" && -2147483648 <= value && value <= 2147483647;
        }
        Is2.integer = integer2;
        function uinteger2(value) {
          return toString.call(value) === "[object Number]" && 0 <= value && value <= 2147483647;
        }
        Is2.uinteger = uinteger2;
        function func(value) {
          return toString.call(value) === "[object Function]";
        }
        Is2.func = func;
        function objectLiteral(value) {
          return value !== null && typeof value === "object";
        }
        Is2.objectLiteral = objectLiteral;
        function typedArray(value, check) {
          return Array.isArray(value) && value.every(check);
        }
        Is2.typedArray = typedArray;
      })(Is || (Is = {}));
    });
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/messages.js
var require_messages2 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/messages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProtocolNotificationType = exports.ProtocolNotificationType0 = exports.ProtocolRequestType = exports.ProtocolRequestType0 = exports.RegistrationType = exports.MessageDirection = void 0;
    var vscode_jsonrpc_1 = require_main();
    var MessageDirection;
    (function(MessageDirection2) {
      MessageDirection2["clientToServer"] = "clientToServer";
      MessageDirection2["serverToClient"] = "serverToClient";
      MessageDirection2["both"] = "both";
    })(MessageDirection || (exports.MessageDirection = MessageDirection = {}));
    var RegistrationType = class {
      constructor(method) {
        this.method = method;
      }
    };
    exports.RegistrationType = RegistrationType;
    var ProtocolRequestType0 = class extends vscode_jsonrpc_1.RequestType0 {
      constructor(method) {
        super(method);
      }
    };
    exports.ProtocolRequestType0 = ProtocolRequestType0;
    var ProtocolRequestType = class extends vscode_jsonrpc_1.RequestType {
      constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
      }
    };
    exports.ProtocolRequestType = ProtocolRequestType;
    var ProtocolNotificationType0 = class extends vscode_jsonrpc_1.NotificationType0 {
      constructor(method) {
        super(method);
      }
    };
    exports.ProtocolNotificationType0 = ProtocolNotificationType0;
    var ProtocolNotificationType = class extends vscode_jsonrpc_1.NotificationType {
      constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
      }
    };
    exports.ProtocolNotificationType = ProtocolNotificationType;
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/utils/is.js
var require_is2 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/utils/is.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.objectLiteral = exports.typedArray = exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
    function boolean(value) {
      return value === true || value === false;
    }
    exports.boolean = boolean;
    function string(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports.string = string;
    function number(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports.number = number;
    function error(value) {
      return value instanceof Error;
    }
    exports.error = error;
    function func(value) {
      return typeof value === "function";
    }
    exports.func = func;
    function array(value) {
      return Array.isArray(value);
    }
    exports.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string(elem));
    }
    exports.stringArray = stringArray;
    function typedArray(value, check) {
      return Array.isArray(value) && value.every(check);
    }
    exports.typedArray = typedArray;
    function objectLiteral(value) {
      return value !== null && typeof value === "object";
    }
    exports.objectLiteral = objectLiteral;
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js
var require_protocol_implementation = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ImplementationRequest = void 0;
    var messages_1 = require_messages2();
    var ImplementationRequest;
    (function(ImplementationRequest2) {
      ImplementationRequest2.method = "textDocument/implementation";
      ImplementationRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ImplementationRequest2.type = new messages_1.ProtocolRequestType(ImplementationRequest2.method);
    })(ImplementationRequest || (exports.ImplementationRequest = ImplementationRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js
var require_protocol_typeDefinition = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TypeDefinitionRequest = void 0;
    var messages_1 = require_messages2();
    var TypeDefinitionRequest;
    (function(TypeDefinitionRequest2) {
      TypeDefinitionRequest2.method = "textDocument/typeDefinition";
      TypeDefinitionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeDefinitionRequest2.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest2.method);
    })(TypeDefinitionRequest || (exports.TypeDefinitionRequest = TypeDefinitionRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolder.js
var require_protocol_workspaceFolder = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DidChangeWorkspaceFoldersNotification = exports.WorkspaceFoldersRequest = void 0;
    var messages_1 = require_messages2();
    var WorkspaceFoldersRequest;
    (function(WorkspaceFoldersRequest2) {
      WorkspaceFoldersRequest2.method = "workspace/workspaceFolders";
      WorkspaceFoldersRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      WorkspaceFoldersRequest2.type = new messages_1.ProtocolRequestType0(WorkspaceFoldersRequest2.method);
    })(WorkspaceFoldersRequest || (exports.WorkspaceFoldersRequest = WorkspaceFoldersRequest = {}));
    var DidChangeWorkspaceFoldersNotification;
    (function(DidChangeWorkspaceFoldersNotification2) {
      DidChangeWorkspaceFoldersNotification2.method = "workspace/didChangeWorkspaceFolders";
      DidChangeWorkspaceFoldersNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeWorkspaceFoldersNotification2.type = new messages_1.ProtocolNotificationType(DidChangeWorkspaceFoldersNotification2.method);
    })(DidChangeWorkspaceFoldersNotification || (exports.DidChangeWorkspaceFoldersNotification = DidChangeWorkspaceFoldersNotification = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js
var require_protocol_configuration = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConfigurationRequest = void 0;
    var messages_1 = require_messages2();
    var ConfigurationRequest;
    (function(ConfigurationRequest2) {
      ConfigurationRequest2.method = "workspace/configuration";
      ConfigurationRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      ConfigurationRequest2.type = new messages_1.ProtocolRequestType(ConfigurationRequest2.method);
    })(ConfigurationRequest || (exports.ConfigurationRequest = ConfigurationRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js
var require_protocol_colorProvider = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ColorPresentationRequest = exports.DocumentColorRequest = void 0;
    var messages_1 = require_messages2();
    var DocumentColorRequest;
    (function(DocumentColorRequest2) {
      DocumentColorRequest2.method = "textDocument/documentColor";
      DocumentColorRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentColorRequest2.type = new messages_1.ProtocolRequestType(DocumentColorRequest2.method);
    })(DocumentColorRequest || (exports.DocumentColorRequest = DocumentColorRequest = {}));
    var ColorPresentationRequest;
    (function(ColorPresentationRequest2) {
      ColorPresentationRequest2.method = "textDocument/colorPresentation";
      ColorPresentationRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ColorPresentationRequest2.type = new messages_1.ProtocolRequestType(ColorPresentationRequest2.method);
    })(ColorPresentationRequest || (exports.ColorPresentationRequest = ColorPresentationRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js
var require_protocol_foldingRange = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FoldingRangeRefreshRequest = exports.FoldingRangeRequest = void 0;
    var messages_1 = require_messages2();
    var FoldingRangeRequest;
    (function(FoldingRangeRequest2) {
      FoldingRangeRequest2.method = "textDocument/foldingRange";
      FoldingRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      FoldingRangeRequest2.type = new messages_1.ProtocolRequestType(FoldingRangeRequest2.method);
    })(FoldingRangeRequest || (exports.FoldingRangeRequest = FoldingRangeRequest = {}));
    var FoldingRangeRefreshRequest;
    (function(FoldingRangeRefreshRequest2) {
      FoldingRangeRefreshRequest2.method = `workspace/foldingRange/refresh`;
      FoldingRangeRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      FoldingRangeRefreshRequest2.type = new messages_1.ProtocolRequestType0(FoldingRangeRefreshRequest2.method);
    })(FoldingRangeRefreshRequest || (exports.FoldingRangeRefreshRequest = FoldingRangeRefreshRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js
var require_protocol_declaration = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DeclarationRequest = void 0;
    var messages_1 = require_messages2();
    var DeclarationRequest;
    (function(DeclarationRequest2) {
      DeclarationRequest2.method = "textDocument/declaration";
      DeclarationRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DeclarationRequest2.type = new messages_1.ProtocolRequestType(DeclarationRequest2.method);
    })(DeclarationRequest || (exports.DeclarationRequest = DeclarationRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js
var require_protocol_selectionRange = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SelectionRangeRequest = void 0;
    var messages_1 = require_messages2();
    var SelectionRangeRequest;
    (function(SelectionRangeRequest2) {
      SelectionRangeRequest2.method = "textDocument/selectionRange";
      SelectionRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SelectionRangeRequest2.type = new messages_1.ProtocolRequestType(SelectionRangeRequest2.method);
    })(SelectionRangeRequest || (exports.SelectionRangeRequest = SelectionRangeRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js
var require_protocol_progress = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WorkDoneProgressCancelNotification = exports.WorkDoneProgressCreateRequest = exports.WorkDoneProgress = void 0;
    var vscode_jsonrpc_1 = require_main();
    var messages_1 = require_messages2();
    var WorkDoneProgress;
    (function(WorkDoneProgress2) {
      WorkDoneProgress2.type = new vscode_jsonrpc_1.ProgressType();
      function is(value) {
        return value === WorkDoneProgress2.type;
      }
      WorkDoneProgress2.is = is;
    })(WorkDoneProgress || (exports.WorkDoneProgress = WorkDoneProgress = {}));
    var WorkDoneProgressCreateRequest;
    (function(WorkDoneProgressCreateRequest2) {
      WorkDoneProgressCreateRequest2.method = "window/workDoneProgress/create";
      WorkDoneProgressCreateRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      WorkDoneProgressCreateRequest2.type = new messages_1.ProtocolRequestType(WorkDoneProgressCreateRequest2.method);
    })(WorkDoneProgressCreateRequest || (exports.WorkDoneProgressCreateRequest = WorkDoneProgressCreateRequest = {}));
    var WorkDoneProgressCancelNotification;
    (function(WorkDoneProgressCancelNotification2) {
      WorkDoneProgressCancelNotification2.method = "window/workDoneProgress/cancel";
      WorkDoneProgressCancelNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkDoneProgressCancelNotification2.type = new messages_1.ProtocolNotificationType(WorkDoneProgressCancelNotification2.method);
    })(WorkDoneProgressCancelNotification || (exports.WorkDoneProgressCancelNotification = WorkDoneProgressCancelNotification = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js
var require_protocol_callHierarchy = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CallHierarchyOutgoingCallsRequest = exports.CallHierarchyIncomingCallsRequest = exports.CallHierarchyPrepareRequest = void 0;
    var messages_1 = require_messages2();
    var CallHierarchyPrepareRequest;
    (function(CallHierarchyPrepareRequest2) {
      CallHierarchyPrepareRequest2.method = "textDocument/prepareCallHierarchy";
      CallHierarchyPrepareRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CallHierarchyPrepareRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest2.method);
    })(CallHierarchyPrepareRequest || (exports.CallHierarchyPrepareRequest = CallHierarchyPrepareRequest = {}));
    var CallHierarchyIncomingCallsRequest;
    (function(CallHierarchyIncomingCallsRequest2) {
      CallHierarchyIncomingCallsRequest2.method = "callHierarchy/incomingCalls";
      CallHierarchyIncomingCallsRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CallHierarchyIncomingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest2.method);
    })(CallHierarchyIncomingCallsRequest || (exports.CallHierarchyIncomingCallsRequest = CallHierarchyIncomingCallsRequest = {}));
    var CallHierarchyOutgoingCallsRequest;
    (function(CallHierarchyOutgoingCallsRequest2) {
      CallHierarchyOutgoingCallsRequest2.method = "callHierarchy/outgoingCalls";
      CallHierarchyOutgoingCallsRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CallHierarchyOutgoingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest2.method);
    })(CallHierarchyOutgoingCallsRequest || (exports.CallHierarchyOutgoingCallsRequest = CallHierarchyOutgoingCallsRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js
var require_protocol_semanticTokens = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SemanticTokensRefreshRequest = exports.SemanticTokensRangeRequest = exports.SemanticTokensDeltaRequest = exports.SemanticTokensRequest = exports.SemanticTokensRegistrationType = exports.TokenFormat = void 0;
    var messages_1 = require_messages2();
    var TokenFormat;
    (function(TokenFormat2) {
      TokenFormat2.Relative = "relative";
    })(TokenFormat || (exports.TokenFormat = TokenFormat = {}));
    var SemanticTokensRegistrationType;
    (function(SemanticTokensRegistrationType2) {
      SemanticTokensRegistrationType2.method = "textDocument/semanticTokens";
      SemanticTokensRegistrationType2.type = new messages_1.RegistrationType(SemanticTokensRegistrationType2.method);
    })(SemanticTokensRegistrationType || (exports.SemanticTokensRegistrationType = SemanticTokensRegistrationType = {}));
    var SemanticTokensRequest;
    (function(SemanticTokensRequest2) {
      SemanticTokensRequest2.method = "textDocument/semanticTokens/full";
      SemanticTokensRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SemanticTokensRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRequest2.method);
      SemanticTokensRequest2.registrationMethod = SemanticTokensRegistrationType.method;
    })(SemanticTokensRequest || (exports.SemanticTokensRequest = SemanticTokensRequest = {}));
    var SemanticTokensDeltaRequest;
    (function(SemanticTokensDeltaRequest2) {
      SemanticTokensDeltaRequest2.method = "textDocument/semanticTokens/full/delta";
      SemanticTokensDeltaRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SemanticTokensDeltaRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensDeltaRequest2.method);
      SemanticTokensDeltaRequest2.registrationMethod = SemanticTokensRegistrationType.method;
    })(SemanticTokensDeltaRequest || (exports.SemanticTokensDeltaRequest = SemanticTokensDeltaRequest = {}));
    var SemanticTokensRangeRequest;
    (function(SemanticTokensRangeRequest2) {
      SemanticTokensRangeRequest2.method = "textDocument/semanticTokens/range";
      SemanticTokensRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SemanticTokensRangeRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest2.method);
      SemanticTokensRangeRequest2.registrationMethod = SemanticTokensRegistrationType.method;
    })(SemanticTokensRangeRequest || (exports.SemanticTokensRangeRequest = SemanticTokensRangeRequest = {}));
    var SemanticTokensRefreshRequest;
    (function(SemanticTokensRefreshRequest2) {
      SemanticTokensRefreshRequest2.method = `workspace/semanticTokens/refresh`;
      SemanticTokensRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      SemanticTokensRefreshRequest2.type = new messages_1.ProtocolRequestType0(SemanticTokensRefreshRequest2.method);
    })(SemanticTokensRefreshRequest || (exports.SemanticTokensRefreshRequest = SemanticTokensRefreshRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js
var require_protocol_showDocument = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ShowDocumentRequest = void 0;
    var messages_1 = require_messages2();
    var ShowDocumentRequest;
    (function(ShowDocumentRequest2) {
      ShowDocumentRequest2.method = "window/showDocument";
      ShowDocumentRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      ShowDocumentRequest2.type = new messages_1.ProtocolRequestType(ShowDocumentRequest2.method);
    })(ShowDocumentRequest || (exports.ShowDocumentRequest = ShowDocumentRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js
var require_protocol_linkedEditingRange = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LinkedEditingRangeRequest = void 0;
    var messages_1 = require_messages2();
    var LinkedEditingRangeRequest;
    (function(LinkedEditingRangeRequest2) {
      LinkedEditingRangeRequest2.method = "textDocument/linkedEditingRange";
      LinkedEditingRangeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      LinkedEditingRangeRequest2.type = new messages_1.ProtocolRequestType(LinkedEditingRangeRequest2.method);
    })(LinkedEditingRangeRequest || (exports.LinkedEditingRangeRequest = LinkedEditingRangeRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js
var require_protocol_fileOperations = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WillDeleteFilesRequest = exports.DidDeleteFilesNotification = exports.DidRenameFilesNotification = exports.WillRenameFilesRequest = exports.DidCreateFilesNotification = exports.WillCreateFilesRequest = exports.FileOperationPatternKind = void 0;
    var messages_1 = require_messages2();
    var FileOperationPatternKind;
    (function(FileOperationPatternKind2) {
      FileOperationPatternKind2.file = "file";
      FileOperationPatternKind2.folder = "folder";
    })(FileOperationPatternKind || (exports.FileOperationPatternKind = FileOperationPatternKind = {}));
    var WillCreateFilesRequest;
    (function(WillCreateFilesRequest2) {
      WillCreateFilesRequest2.method = "workspace/willCreateFiles";
      WillCreateFilesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillCreateFilesRequest2.type = new messages_1.ProtocolRequestType(WillCreateFilesRequest2.method);
    })(WillCreateFilesRequest || (exports.WillCreateFilesRequest = WillCreateFilesRequest = {}));
    var DidCreateFilesNotification;
    (function(DidCreateFilesNotification2) {
      DidCreateFilesNotification2.method = "workspace/didCreateFiles";
      DidCreateFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidCreateFilesNotification2.type = new messages_1.ProtocolNotificationType(DidCreateFilesNotification2.method);
    })(DidCreateFilesNotification || (exports.DidCreateFilesNotification = DidCreateFilesNotification = {}));
    var WillRenameFilesRequest;
    (function(WillRenameFilesRequest2) {
      WillRenameFilesRequest2.method = "workspace/willRenameFiles";
      WillRenameFilesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillRenameFilesRequest2.type = new messages_1.ProtocolRequestType(WillRenameFilesRequest2.method);
    })(WillRenameFilesRequest || (exports.WillRenameFilesRequest = WillRenameFilesRequest = {}));
    var DidRenameFilesNotification;
    (function(DidRenameFilesNotification2) {
      DidRenameFilesNotification2.method = "workspace/didRenameFiles";
      DidRenameFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidRenameFilesNotification2.type = new messages_1.ProtocolNotificationType(DidRenameFilesNotification2.method);
    })(DidRenameFilesNotification || (exports.DidRenameFilesNotification = DidRenameFilesNotification = {}));
    var DidDeleteFilesNotification;
    (function(DidDeleteFilesNotification2) {
      DidDeleteFilesNotification2.method = "workspace/didDeleteFiles";
      DidDeleteFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidDeleteFilesNotification2.type = new messages_1.ProtocolNotificationType(DidDeleteFilesNotification2.method);
    })(DidDeleteFilesNotification || (exports.DidDeleteFilesNotification = DidDeleteFilesNotification = {}));
    var WillDeleteFilesRequest;
    (function(WillDeleteFilesRequest2) {
      WillDeleteFilesRequest2.method = "workspace/willDeleteFiles";
      WillDeleteFilesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillDeleteFilesRequest2.type = new messages_1.ProtocolRequestType(WillDeleteFilesRequest2.method);
    })(WillDeleteFilesRequest || (exports.WillDeleteFilesRequest = WillDeleteFilesRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js
var require_protocol_moniker = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MonikerRequest = exports.MonikerKind = exports.UniquenessLevel = void 0;
    var messages_1 = require_messages2();
    var UniquenessLevel;
    (function(UniquenessLevel2) {
      UniquenessLevel2.document = "document";
      UniquenessLevel2.project = "project";
      UniquenessLevel2.group = "group";
      UniquenessLevel2.scheme = "scheme";
      UniquenessLevel2.global = "global";
    })(UniquenessLevel || (exports.UniquenessLevel = UniquenessLevel = {}));
    var MonikerKind;
    (function(MonikerKind2) {
      MonikerKind2.$import = "import";
      MonikerKind2.$export = "export";
      MonikerKind2.local = "local";
    })(MonikerKind || (exports.MonikerKind = MonikerKind = {}));
    var MonikerRequest;
    (function(MonikerRequest2) {
      MonikerRequest2.method = "textDocument/moniker";
      MonikerRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      MonikerRequest2.type = new messages_1.ProtocolRequestType(MonikerRequest2.method);
    })(MonikerRequest || (exports.MonikerRequest = MonikerRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.typeHierarchy.js
var require_protocol_typeHierarchy = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.typeHierarchy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TypeHierarchySubtypesRequest = exports.TypeHierarchySupertypesRequest = exports.TypeHierarchyPrepareRequest = void 0;
    var messages_1 = require_messages2();
    var TypeHierarchyPrepareRequest;
    (function(TypeHierarchyPrepareRequest2) {
      TypeHierarchyPrepareRequest2.method = "textDocument/prepareTypeHierarchy";
      TypeHierarchyPrepareRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeHierarchyPrepareRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchyPrepareRequest2.method);
    })(TypeHierarchyPrepareRequest || (exports.TypeHierarchyPrepareRequest = TypeHierarchyPrepareRequest = {}));
    var TypeHierarchySupertypesRequest;
    (function(TypeHierarchySupertypesRequest2) {
      TypeHierarchySupertypesRequest2.method = "typeHierarchy/supertypes";
      TypeHierarchySupertypesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeHierarchySupertypesRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchySupertypesRequest2.method);
    })(TypeHierarchySupertypesRequest || (exports.TypeHierarchySupertypesRequest = TypeHierarchySupertypesRequest = {}));
    var TypeHierarchySubtypesRequest;
    (function(TypeHierarchySubtypesRequest2) {
      TypeHierarchySubtypesRequest2.method = "typeHierarchy/subtypes";
      TypeHierarchySubtypesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeHierarchySubtypesRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchySubtypesRequest2.method);
    })(TypeHierarchySubtypesRequest || (exports.TypeHierarchySubtypesRequest = TypeHierarchySubtypesRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineValue.js
var require_protocol_inlineValue = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineValue.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InlineValueRefreshRequest = exports.InlineValueRequest = void 0;
    var messages_1 = require_messages2();
    var InlineValueRequest;
    (function(InlineValueRequest2) {
      InlineValueRequest2.method = "textDocument/inlineValue";
      InlineValueRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InlineValueRequest2.type = new messages_1.ProtocolRequestType(InlineValueRequest2.method);
    })(InlineValueRequest || (exports.InlineValueRequest = InlineValueRequest = {}));
    var InlineValueRefreshRequest;
    (function(InlineValueRefreshRequest2) {
      InlineValueRefreshRequest2.method = `workspace/inlineValue/refresh`;
      InlineValueRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      InlineValueRefreshRequest2.type = new messages_1.ProtocolRequestType0(InlineValueRefreshRequest2.method);
    })(InlineValueRefreshRequest || (exports.InlineValueRefreshRequest = InlineValueRefreshRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.inlayHint.js
var require_protocol_inlayHint = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.inlayHint.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InlayHintRefreshRequest = exports.InlayHintResolveRequest = exports.InlayHintRequest = void 0;
    var messages_1 = require_messages2();
    var InlayHintRequest;
    (function(InlayHintRequest2) {
      InlayHintRequest2.method = "textDocument/inlayHint";
      InlayHintRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InlayHintRequest2.type = new messages_1.ProtocolRequestType(InlayHintRequest2.method);
    })(InlayHintRequest || (exports.InlayHintRequest = InlayHintRequest = {}));
    var InlayHintResolveRequest;
    (function(InlayHintResolveRequest2) {
      InlayHintResolveRequest2.method = "inlayHint/resolve";
      InlayHintResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InlayHintResolveRequest2.type = new messages_1.ProtocolRequestType(InlayHintResolveRequest2.method);
    })(InlayHintResolveRequest || (exports.InlayHintResolveRequest = InlayHintResolveRequest = {}));
    var InlayHintRefreshRequest;
    (function(InlayHintRefreshRequest2) {
      InlayHintRefreshRequest2.method = `workspace/inlayHint/refresh`;
      InlayHintRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      InlayHintRefreshRequest2.type = new messages_1.ProtocolRequestType0(InlayHintRefreshRequest2.method);
    })(InlayHintRefreshRequest || (exports.InlayHintRefreshRequest = InlayHintRefreshRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.diagnostic.js
var require_protocol_diagnostic = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.diagnostic.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DiagnosticRefreshRequest = exports.WorkspaceDiagnosticRequest = exports.DocumentDiagnosticRequest = exports.DocumentDiagnosticReportKind = exports.DiagnosticServerCancellationData = void 0;
    var vscode_jsonrpc_1 = require_main();
    var Is = require_is2();
    var messages_1 = require_messages2();
    var DiagnosticServerCancellationData;
    (function(DiagnosticServerCancellationData2) {
      function is(value) {
        const candidate = value;
        return candidate && Is.boolean(candidate.retriggerRequest);
      }
      DiagnosticServerCancellationData2.is = is;
    })(DiagnosticServerCancellationData || (exports.DiagnosticServerCancellationData = DiagnosticServerCancellationData = {}));
    var DocumentDiagnosticReportKind;
    (function(DocumentDiagnosticReportKind2) {
      DocumentDiagnosticReportKind2.Full = "full";
      DocumentDiagnosticReportKind2.Unchanged = "unchanged";
    })(DocumentDiagnosticReportKind || (exports.DocumentDiagnosticReportKind = DocumentDiagnosticReportKind = {}));
    var DocumentDiagnosticRequest;
    (function(DocumentDiagnosticRequest2) {
      DocumentDiagnosticRequest2.method = "textDocument/diagnostic";
      DocumentDiagnosticRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentDiagnosticRequest2.type = new messages_1.ProtocolRequestType(DocumentDiagnosticRequest2.method);
      DocumentDiagnosticRequest2.partialResult = new vscode_jsonrpc_1.ProgressType();
    })(DocumentDiagnosticRequest || (exports.DocumentDiagnosticRequest = DocumentDiagnosticRequest = {}));
    var WorkspaceDiagnosticRequest;
    (function(WorkspaceDiagnosticRequest2) {
      WorkspaceDiagnosticRequest2.method = "workspace/diagnostic";
      WorkspaceDiagnosticRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkspaceDiagnosticRequest2.type = new messages_1.ProtocolRequestType(WorkspaceDiagnosticRequest2.method);
      WorkspaceDiagnosticRequest2.partialResult = new vscode_jsonrpc_1.ProgressType();
    })(WorkspaceDiagnosticRequest || (exports.WorkspaceDiagnosticRequest = WorkspaceDiagnosticRequest = {}));
    var DiagnosticRefreshRequest;
    (function(DiagnosticRefreshRequest2) {
      DiagnosticRefreshRequest2.method = `workspace/diagnostic/refresh`;
      DiagnosticRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      DiagnosticRefreshRequest2.type = new messages_1.ProtocolRequestType0(DiagnosticRefreshRequest2.method);
    })(DiagnosticRefreshRequest || (exports.DiagnosticRefreshRequest = DiagnosticRefreshRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.notebook.js
var require_protocol_notebook = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.notebook.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DidCloseNotebookDocumentNotification = exports.DidSaveNotebookDocumentNotification = exports.DidChangeNotebookDocumentNotification = exports.NotebookCellArrayChange = exports.DidOpenNotebookDocumentNotification = exports.NotebookDocumentSyncRegistrationType = exports.NotebookDocument = exports.NotebookCell = exports.ExecutionSummary = exports.NotebookCellKind = void 0;
    var vscode_languageserver_types_1 = require_main2();
    var Is = require_is2();
    var messages_1 = require_messages2();
    var NotebookCellKind;
    (function(NotebookCellKind2) {
      NotebookCellKind2.Markup = 1;
      NotebookCellKind2.Code = 2;
      function is(value) {
        return value === 1 || value === 2;
      }
      NotebookCellKind2.is = is;
    })(NotebookCellKind || (exports.NotebookCellKind = NotebookCellKind = {}));
    var ExecutionSummary;
    (function(ExecutionSummary2) {
      function create(executionOrder, success) {
        const result = { executionOrder };
        if (success === true || success === false) {
          result.success = success;
        }
        return result;
      }
      ExecutionSummary2.create = create;
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.executionOrder) && (candidate.success === void 0 || Is.boolean(candidate.success));
      }
      ExecutionSummary2.is = is;
      function equals(one, other) {
        if (one === other) {
          return true;
        }
        if (one === null || one === void 0 || other === null || other === void 0) {
          return false;
        }
        return one.executionOrder === other.executionOrder && one.success === other.success;
      }
      ExecutionSummary2.equals = equals;
    })(ExecutionSummary || (exports.ExecutionSummary = ExecutionSummary = {}));
    var NotebookCell;
    (function(NotebookCell2) {
      function create(kind, document) {
        return { kind, document };
      }
      NotebookCell2.create = create;
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && NotebookCellKind.is(candidate.kind) && vscode_languageserver_types_1.DocumentUri.is(candidate.document) && (candidate.metadata === void 0 || Is.objectLiteral(candidate.metadata));
      }
      NotebookCell2.is = is;
      function diff(one, two) {
        const result = /* @__PURE__ */ new Set();
        if (one.document !== two.document) {
          result.add("document");
        }
        if (one.kind !== two.kind) {
          result.add("kind");
        }
        if (one.executionSummary !== two.executionSummary) {
          result.add("executionSummary");
        }
        if ((one.metadata !== void 0 || two.metadata !== void 0) && !equalsMetadata(one.metadata, two.metadata)) {
          result.add("metadata");
        }
        if ((one.executionSummary !== void 0 || two.executionSummary !== void 0) && !ExecutionSummary.equals(one.executionSummary, two.executionSummary)) {
          result.add("executionSummary");
        }
        return result;
      }
      NotebookCell2.diff = diff;
      function equalsMetadata(one, other) {
        if (one === other) {
          return true;
        }
        if (one === null || one === void 0 || other === null || other === void 0) {
          return false;
        }
        if (typeof one !== typeof other) {
          return false;
        }
        if (typeof one !== "object") {
          return false;
        }
        const oneArray = Array.isArray(one);
        const otherArray = Array.isArray(other);
        if (oneArray !== otherArray) {
          return false;
        }
        if (oneArray && otherArray) {
          if (one.length !== other.length) {
            return false;
          }
          for (let i = 0; i < one.length; i++) {
            if (!equalsMetadata(one[i], other[i])) {
              return false;
            }
          }
        }
        if (Is.objectLiteral(one) && Is.objectLiteral(other)) {
          const oneKeys = Object.keys(one);
          const otherKeys = Object.keys(other);
          if (oneKeys.length !== otherKeys.length) {
            return false;
          }
          oneKeys.sort();
          otherKeys.sort();
          if (!equalsMetadata(oneKeys, otherKeys)) {
            return false;
          }
          for (let i = 0; i < oneKeys.length; i++) {
            const prop = oneKeys[i];
            if (!equalsMetadata(one[prop], other[prop])) {
              return false;
            }
          }
        }
        return true;
      }
    })(NotebookCell || (exports.NotebookCell = NotebookCell = {}));
    var NotebookDocument;
    (function(NotebookDocument2) {
      function create(uri, notebookType, version, cells) {
        return { uri, notebookType, version, cells };
      }
      NotebookDocument2.create = create;
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.uri) && vscode_languageserver_types_1.integer.is(candidate.version) && Is.typedArray(candidate.cells, NotebookCell.is);
      }
      NotebookDocument2.is = is;
    })(NotebookDocument || (exports.NotebookDocument = NotebookDocument = {}));
    var NotebookDocumentSyncRegistrationType;
    (function(NotebookDocumentSyncRegistrationType2) {
      NotebookDocumentSyncRegistrationType2.method = "notebookDocument/sync";
      NotebookDocumentSyncRegistrationType2.messageDirection = messages_1.MessageDirection.clientToServer;
      NotebookDocumentSyncRegistrationType2.type = new messages_1.RegistrationType(NotebookDocumentSyncRegistrationType2.method);
    })(NotebookDocumentSyncRegistrationType || (exports.NotebookDocumentSyncRegistrationType = NotebookDocumentSyncRegistrationType = {}));
    var DidOpenNotebookDocumentNotification;
    (function(DidOpenNotebookDocumentNotification2) {
      DidOpenNotebookDocumentNotification2.method = "notebookDocument/didOpen";
      DidOpenNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidOpenNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidOpenNotebookDocumentNotification2.method);
      DidOpenNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidOpenNotebookDocumentNotification || (exports.DidOpenNotebookDocumentNotification = DidOpenNotebookDocumentNotification = {}));
    var NotebookCellArrayChange;
    (function(NotebookCellArrayChange2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.start) && vscode_languageserver_types_1.uinteger.is(candidate.deleteCount) && (candidate.cells === void 0 || Is.typedArray(candidate.cells, NotebookCell.is));
      }
      NotebookCellArrayChange2.is = is;
      function create(start, deleteCount, cells) {
        const result = { start, deleteCount };
        if (cells !== void 0) {
          result.cells = cells;
        }
        return result;
      }
      NotebookCellArrayChange2.create = create;
    })(NotebookCellArrayChange || (exports.NotebookCellArrayChange = NotebookCellArrayChange = {}));
    var DidChangeNotebookDocumentNotification;
    (function(DidChangeNotebookDocumentNotification2) {
      DidChangeNotebookDocumentNotification2.method = "notebookDocument/didChange";
      DidChangeNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidChangeNotebookDocumentNotification2.method);
      DidChangeNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidChangeNotebookDocumentNotification || (exports.DidChangeNotebookDocumentNotification = DidChangeNotebookDocumentNotification = {}));
    var DidSaveNotebookDocumentNotification;
    (function(DidSaveNotebookDocumentNotification2) {
      DidSaveNotebookDocumentNotification2.method = "notebookDocument/didSave";
      DidSaveNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidSaveNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidSaveNotebookDocumentNotification2.method);
      DidSaveNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidSaveNotebookDocumentNotification || (exports.DidSaveNotebookDocumentNotification = DidSaveNotebookDocumentNotification = {}));
    var DidCloseNotebookDocumentNotification;
    (function(DidCloseNotebookDocumentNotification2) {
      DidCloseNotebookDocumentNotification2.method = "notebookDocument/didClose";
      DidCloseNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidCloseNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidCloseNotebookDocumentNotification2.method);
      DidCloseNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidCloseNotebookDocumentNotification || (exports.DidCloseNotebookDocumentNotification = DidCloseNotebookDocumentNotification = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineCompletion.js
var require_protocol_inlineCompletion = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineCompletion.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InlineCompletionRequest = void 0;
    var messages_1 = require_messages2();
    var InlineCompletionRequest;
    (function(InlineCompletionRequest2) {
      InlineCompletionRequest2.method = "textDocument/inlineCompletion";
      InlineCompletionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InlineCompletionRequest2.type = new messages_1.ProtocolRequestType(InlineCompletionRequest2.method);
    })(InlineCompletionRequest || (exports.InlineCompletionRequest = InlineCompletionRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.js
var require_protocol = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WorkspaceSymbolRequest = exports.CodeActionResolveRequest = exports.CodeActionRequest = exports.DocumentSymbolRequest = exports.DocumentHighlightRequest = exports.ReferencesRequest = exports.DefinitionRequest = exports.SignatureHelpRequest = exports.SignatureHelpTriggerKind = exports.HoverRequest = exports.CompletionResolveRequest = exports.CompletionRequest = exports.CompletionTriggerKind = exports.PublishDiagnosticsNotification = exports.WatchKind = exports.RelativePattern = exports.FileChangeType = exports.DidChangeWatchedFilesNotification = exports.WillSaveTextDocumentWaitUntilRequest = exports.WillSaveTextDocumentNotification = exports.TextDocumentSaveReason = exports.DidSaveTextDocumentNotification = exports.DidCloseTextDocumentNotification = exports.DidChangeTextDocumentNotification = exports.TextDocumentContentChangeEvent = exports.DidOpenTextDocumentNotification = exports.TextDocumentSyncKind = exports.TelemetryEventNotification = exports.LogMessageNotification = exports.ShowMessageRequest = exports.ShowMessageNotification = exports.MessageType = exports.DidChangeConfigurationNotification = exports.ExitNotification = exports.ShutdownRequest = exports.InitializedNotification = exports.InitializeErrorCodes = exports.InitializeRequest = exports.WorkDoneProgressOptions = exports.TextDocumentRegistrationOptions = exports.StaticRegistrationOptions = exports.PositionEncodingKind = exports.FailureHandlingKind = exports.ResourceOperationKind = exports.UnregistrationRequest = exports.RegistrationRequest = exports.DocumentSelector = exports.NotebookCellTextDocumentFilter = exports.NotebookDocumentFilter = exports.TextDocumentFilter = void 0;
    exports.MonikerRequest = exports.MonikerKind = exports.UniquenessLevel = exports.WillDeleteFilesRequest = exports.DidDeleteFilesNotification = exports.WillRenameFilesRequest = exports.DidRenameFilesNotification = exports.WillCreateFilesRequest = exports.DidCreateFilesNotification = exports.FileOperationPatternKind = exports.LinkedEditingRangeRequest = exports.ShowDocumentRequest = exports.SemanticTokensRegistrationType = exports.SemanticTokensRefreshRequest = exports.SemanticTokensRangeRequest = exports.SemanticTokensDeltaRequest = exports.SemanticTokensRequest = exports.TokenFormat = exports.CallHierarchyPrepareRequest = exports.CallHierarchyOutgoingCallsRequest = exports.CallHierarchyIncomingCallsRequest = exports.WorkDoneProgressCancelNotification = exports.WorkDoneProgressCreateRequest = exports.WorkDoneProgress = exports.SelectionRangeRequest = exports.DeclarationRequest = exports.FoldingRangeRefreshRequest = exports.FoldingRangeRequest = exports.ColorPresentationRequest = exports.DocumentColorRequest = exports.ConfigurationRequest = exports.DidChangeWorkspaceFoldersNotification = exports.WorkspaceFoldersRequest = exports.TypeDefinitionRequest = exports.ImplementationRequest = exports.ApplyWorkspaceEditRequest = exports.ExecuteCommandRequest = exports.PrepareRenameRequest = exports.RenameRequest = exports.PrepareSupportDefaultBehavior = exports.DocumentOnTypeFormattingRequest = exports.DocumentRangesFormattingRequest = exports.DocumentRangeFormattingRequest = exports.DocumentFormattingRequest = exports.DocumentLinkResolveRequest = exports.DocumentLinkRequest = exports.CodeLensRefreshRequest = exports.CodeLensResolveRequest = exports.CodeLensRequest = exports.WorkspaceSymbolResolveRequest = void 0;
    exports.InlineCompletionRequest = exports.DidCloseNotebookDocumentNotification = exports.DidSaveNotebookDocumentNotification = exports.DidChangeNotebookDocumentNotification = exports.NotebookCellArrayChange = exports.DidOpenNotebookDocumentNotification = exports.NotebookDocumentSyncRegistrationType = exports.NotebookDocument = exports.NotebookCell = exports.ExecutionSummary = exports.NotebookCellKind = exports.DiagnosticRefreshRequest = exports.WorkspaceDiagnosticRequest = exports.DocumentDiagnosticRequest = exports.DocumentDiagnosticReportKind = exports.DiagnosticServerCancellationData = exports.InlayHintRefreshRequest = exports.InlayHintResolveRequest = exports.InlayHintRequest = exports.InlineValueRefreshRequest = exports.InlineValueRequest = exports.TypeHierarchySupertypesRequest = exports.TypeHierarchySubtypesRequest = exports.TypeHierarchyPrepareRequest = void 0;
    var messages_1 = require_messages2();
    var vscode_languageserver_types_1 = require_main2();
    var Is = require_is2();
    var protocol_implementation_1 = require_protocol_implementation();
    Object.defineProperty(exports, "ImplementationRequest", { enumerable: true, get: function() {
      return protocol_implementation_1.ImplementationRequest;
    } });
    var protocol_typeDefinition_1 = require_protocol_typeDefinition();
    Object.defineProperty(exports, "TypeDefinitionRequest", { enumerable: true, get: function() {
      return protocol_typeDefinition_1.TypeDefinitionRequest;
    } });
    var protocol_workspaceFolder_1 = require_protocol_workspaceFolder();
    Object.defineProperty(exports, "WorkspaceFoldersRequest", { enumerable: true, get: function() {
      return protocol_workspaceFolder_1.WorkspaceFoldersRequest;
    } });
    Object.defineProperty(exports, "DidChangeWorkspaceFoldersNotification", { enumerable: true, get: function() {
      return protocol_workspaceFolder_1.DidChangeWorkspaceFoldersNotification;
    } });
    var protocol_configuration_1 = require_protocol_configuration();
    Object.defineProperty(exports, "ConfigurationRequest", { enumerable: true, get: function() {
      return protocol_configuration_1.ConfigurationRequest;
    } });
    var protocol_colorProvider_1 = require_protocol_colorProvider();
    Object.defineProperty(exports, "DocumentColorRequest", { enumerable: true, get: function() {
      return protocol_colorProvider_1.DocumentColorRequest;
    } });
    Object.defineProperty(exports, "ColorPresentationRequest", { enumerable: true, get: function() {
      return protocol_colorProvider_1.ColorPresentationRequest;
    } });
    var protocol_foldingRange_1 = require_protocol_foldingRange();
    Object.defineProperty(exports, "FoldingRangeRequest", { enumerable: true, get: function() {
      return protocol_foldingRange_1.FoldingRangeRequest;
    } });
    Object.defineProperty(exports, "FoldingRangeRefreshRequest", { enumerable: true, get: function() {
      return protocol_foldingRange_1.FoldingRangeRefreshRequest;
    } });
    var protocol_declaration_1 = require_protocol_declaration();
    Object.defineProperty(exports, "DeclarationRequest", { enumerable: true, get: function() {
      return protocol_declaration_1.DeclarationRequest;
    } });
    var protocol_selectionRange_1 = require_protocol_selectionRange();
    Object.defineProperty(exports, "SelectionRangeRequest", { enumerable: true, get: function() {
      return protocol_selectionRange_1.SelectionRangeRequest;
    } });
    var protocol_progress_1 = require_protocol_progress();
    Object.defineProperty(exports, "WorkDoneProgress", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgress;
    } });
    Object.defineProperty(exports, "WorkDoneProgressCreateRequest", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgressCreateRequest;
    } });
    Object.defineProperty(exports, "WorkDoneProgressCancelNotification", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgressCancelNotification;
    } });
    var protocol_callHierarchy_1 = require_protocol_callHierarchy();
    Object.defineProperty(exports, "CallHierarchyIncomingCallsRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyIncomingCallsRequest;
    } });
    Object.defineProperty(exports, "CallHierarchyOutgoingCallsRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyOutgoingCallsRequest;
    } });
    Object.defineProperty(exports, "CallHierarchyPrepareRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyPrepareRequest;
    } });
    var protocol_semanticTokens_1 = require_protocol_semanticTokens();
    Object.defineProperty(exports, "TokenFormat", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.TokenFormat;
    } });
    Object.defineProperty(exports, "SemanticTokensRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRequest;
    } });
    Object.defineProperty(exports, "SemanticTokensDeltaRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensDeltaRequest;
    } });
    Object.defineProperty(exports, "SemanticTokensRangeRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRangeRequest;
    } });
    Object.defineProperty(exports, "SemanticTokensRefreshRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRefreshRequest;
    } });
    Object.defineProperty(exports, "SemanticTokensRegistrationType", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRegistrationType;
    } });
    var protocol_showDocument_1 = require_protocol_showDocument();
    Object.defineProperty(exports, "ShowDocumentRequest", { enumerable: true, get: function() {
      return protocol_showDocument_1.ShowDocumentRequest;
    } });
    var protocol_linkedEditingRange_1 = require_protocol_linkedEditingRange();
    Object.defineProperty(exports, "LinkedEditingRangeRequest", { enumerable: true, get: function() {
      return protocol_linkedEditingRange_1.LinkedEditingRangeRequest;
    } });
    var protocol_fileOperations_1 = require_protocol_fileOperations();
    Object.defineProperty(exports, "FileOperationPatternKind", { enumerable: true, get: function() {
      return protocol_fileOperations_1.FileOperationPatternKind;
    } });
    Object.defineProperty(exports, "DidCreateFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidCreateFilesNotification;
    } });
    Object.defineProperty(exports, "WillCreateFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillCreateFilesRequest;
    } });
    Object.defineProperty(exports, "DidRenameFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidRenameFilesNotification;
    } });
    Object.defineProperty(exports, "WillRenameFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillRenameFilesRequest;
    } });
    Object.defineProperty(exports, "DidDeleteFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidDeleteFilesNotification;
    } });
    Object.defineProperty(exports, "WillDeleteFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillDeleteFilesRequest;
    } });
    var protocol_moniker_1 = require_protocol_moniker();
    Object.defineProperty(exports, "UniquenessLevel", { enumerable: true, get: function() {
      return protocol_moniker_1.UniquenessLevel;
    } });
    Object.defineProperty(exports, "MonikerKind", { enumerable: true, get: function() {
      return protocol_moniker_1.MonikerKind;
    } });
    Object.defineProperty(exports, "MonikerRequest", { enumerable: true, get: function() {
      return protocol_moniker_1.MonikerRequest;
    } });
    var protocol_typeHierarchy_1 = require_protocol_typeHierarchy();
    Object.defineProperty(exports, "TypeHierarchyPrepareRequest", { enumerable: true, get: function() {
      return protocol_typeHierarchy_1.TypeHierarchyPrepareRequest;
    } });
    Object.defineProperty(exports, "TypeHierarchySubtypesRequest", { enumerable: true, get: function() {
      return protocol_typeHierarchy_1.TypeHierarchySubtypesRequest;
    } });
    Object.defineProperty(exports, "TypeHierarchySupertypesRequest", { enumerable: true, get: function() {
      return protocol_typeHierarchy_1.TypeHierarchySupertypesRequest;
    } });
    var protocol_inlineValue_1 = require_protocol_inlineValue();
    Object.defineProperty(exports, "InlineValueRequest", { enumerable: true, get: function() {
      return protocol_inlineValue_1.InlineValueRequest;
    } });
    Object.defineProperty(exports, "InlineValueRefreshRequest", { enumerable: true, get: function() {
      return protocol_inlineValue_1.InlineValueRefreshRequest;
    } });
    var protocol_inlayHint_1 = require_protocol_inlayHint();
    Object.defineProperty(exports, "InlayHintRequest", { enumerable: true, get: function() {
      return protocol_inlayHint_1.InlayHintRequest;
    } });
    Object.defineProperty(exports, "InlayHintResolveRequest", { enumerable: true, get: function() {
      return protocol_inlayHint_1.InlayHintResolveRequest;
    } });
    Object.defineProperty(exports, "InlayHintRefreshRequest", { enumerable: true, get: function() {
      return protocol_inlayHint_1.InlayHintRefreshRequest;
    } });
    var protocol_diagnostic_1 = require_protocol_diagnostic();
    Object.defineProperty(exports, "DiagnosticServerCancellationData", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DiagnosticServerCancellationData;
    } });
    Object.defineProperty(exports, "DocumentDiagnosticReportKind", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DocumentDiagnosticReportKind;
    } });
    Object.defineProperty(exports, "DocumentDiagnosticRequest", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DocumentDiagnosticRequest;
    } });
    Object.defineProperty(exports, "WorkspaceDiagnosticRequest", { enumerable: true, get: function() {
      return protocol_diagnostic_1.WorkspaceDiagnosticRequest;
    } });
    Object.defineProperty(exports, "DiagnosticRefreshRequest", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DiagnosticRefreshRequest;
    } });
    var protocol_notebook_1 = require_protocol_notebook();
    Object.defineProperty(exports, "NotebookCellKind", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookCellKind;
    } });
    Object.defineProperty(exports, "ExecutionSummary", { enumerable: true, get: function() {
      return protocol_notebook_1.ExecutionSummary;
    } });
    Object.defineProperty(exports, "NotebookCell", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookCell;
    } });
    Object.defineProperty(exports, "NotebookDocument", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookDocument;
    } });
    Object.defineProperty(exports, "NotebookDocumentSyncRegistrationType", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookDocumentSyncRegistrationType;
    } });
    Object.defineProperty(exports, "DidOpenNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidOpenNotebookDocumentNotification;
    } });
    Object.defineProperty(exports, "NotebookCellArrayChange", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookCellArrayChange;
    } });
    Object.defineProperty(exports, "DidChangeNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidChangeNotebookDocumentNotification;
    } });
    Object.defineProperty(exports, "DidSaveNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidSaveNotebookDocumentNotification;
    } });
    Object.defineProperty(exports, "DidCloseNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidCloseNotebookDocumentNotification;
    } });
    var protocol_inlineCompletion_1 = require_protocol_inlineCompletion();
    Object.defineProperty(exports, "InlineCompletionRequest", { enumerable: true, get: function() {
      return protocol_inlineCompletion_1.InlineCompletionRequest;
    } });
    var TextDocumentFilter;
    (function(TextDocumentFilter2) {
      function is(value) {
        const candidate = value;
        return Is.string(candidate) || (Is.string(candidate.language) || Is.string(candidate.scheme) || Is.string(candidate.pattern));
      }
      TextDocumentFilter2.is = is;
    })(TextDocumentFilter || (exports.TextDocumentFilter = TextDocumentFilter = {}));
    var NotebookDocumentFilter;
    (function(NotebookDocumentFilter2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (Is.string(candidate.notebookType) || Is.string(candidate.scheme) || Is.string(candidate.pattern));
      }
      NotebookDocumentFilter2.is = is;
    })(NotebookDocumentFilter || (exports.NotebookDocumentFilter = NotebookDocumentFilter = {}));
    var NotebookCellTextDocumentFilter;
    (function(NotebookCellTextDocumentFilter2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (Is.string(candidate.notebook) || NotebookDocumentFilter.is(candidate.notebook)) && (candidate.language === void 0 || Is.string(candidate.language));
      }
      NotebookCellTextDocumentFilter2.is = is;
    })(NotebookCellTextDocumentFilter || (exports.NotebookCellTextDocumentFilter = NotebookCellTextDocumentFilter = {}));
    var DocumentSelector;
    (function(DocumentSelector2) {
      function is(value) {
        if (!Array.isArray(value)) {
          return false;
        }
        for (let elem of value) {
          if (!Is.string(elem) && !TextDocumentFilter.is(elem) && !NotebookCellTextDocumentFilter.is(elem)) {
            return false;
          }
        }
        return true;
      }
      DocumentSelector2.is = is;
    })(DocumentSelector || (exports.DocumentSelector = DocumentSelector = {}));
    var RegistrationRequest;
    (function(RegistrationRequest2) {
      RegistrationRequest2.method = "client/registerCapability";
      RegistrationRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      RegistrationRequest2.type = new messages_1.ProtocolRequestType(RegistrationRequest2.method);
    })(RegistrationRequest || (exports.RegistrationRequest = RegistrationRequest = {}));
    var UnregistrationRequest;
    (function(UnregistrationRequest2) {
      UnregistrationRequest2.method = "client/unregisterCapability";
      UnregistrationRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      UnregistrationRequest2.type = new messages_1.ProtocolRequestType(UnregistrationRequest2.method);
    })(UnregistrationRequest || (exports.UnregistrationRequest = UnregistrationRequest = {}));
    var ResourceOperationKind;
    (function(ResourceOperationKind2) {
      ResourceOperationKind2.Create = "create";
      ResourceOperationKind2.Rename = "rename";
      ResourceOperationKind2.Delete = "delete";
    })(ResourceOperationKind || (exports.ResourceOperationKind = ResourceOperationKind = {}));
    var FailureHandlingKind;
    (function(FailureHandlingKind2) {
      FailureHandlingKind2.Abort = "abort";
      FailureHandlingKind2.Transactional = "transactional";
      FailureHandlingKind2.TextOnlyTransactional = "textOnlyTransactional";
      FailureHandlingKind2.Undo = "undo";
    })(FailureHandlingKind || (exports.FailureHandlingKind = FailureHandlingKind = {}));
    var PositionEncodingKind;
    (function(PositionEncodingKind2) {
      PositionEncodingKind2.UTF8 = "utf-8";
      PositionEncodingKind2.UTF16 = "utf-16";
      PositionEncodingKind2.UTF32 = "utf-32";
    })(PositionEncodingKind || (exports.PositionEncodingKind = PositionEncodingKind = {}));
    var StaticRegistrationOptions;
    (function(StaticRegistrationOptions2) {
      function hasId(value) {
        const candidate = value;
        return candidate && Is.string(candidate.id) && candidate.id.length > 0;
      }
      StaticRegistrationOptions2.hasId = hasId;
    })(StaticRegistrationOptions || (exports.StaticRegistrationOptions = StaticRegistrationOptions = {}));
    var TextDocumentRegistrationOptions;
    (function(TextDocumentRegistrationOptions2) {
      function is(value) {
        const candidate = value;
        return candidate && (candidate.documentSelector === null || DocumentSelector.is(candidate.documentSelector));
      }
      TextDocumentRegistrationOptions2.is = is;
    })(TextDocumentRegistrationOptions || (exports.TextDocumentRegistrationOptions = TextDocumentRegistrationOptions = {}));
    var WorkDoneProgressOptions;
    (function(WorkDoneProgressOptions2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (candidate.workDoneProgress === void 0 || Is.boolean(candidate.workDoneProgress));
      }
      WorkDoneProgressOptions2.is = is;
      function hasWorkDoneProgress(value) {
        const candidate = value;
        return candidate && Is.boolean(candidate.workDoneProgress);
      }
      WorkDoneProgressOptions2.hasWorkDoneProgress = hasWorkDoneProgress;
    })(WorkDoneProgressOptions || (exports.WorkDoneProgressOptions = WorkDoneProgressOptions = {}));
    var InitializeRequest;
    (function(InitializeRequest2) {
      InitializeRequest2.method = "initialize";
      InitializeRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      InitializeRequest2.type = new messages_1.ProtocolRequestType(InitializeRequest2.method);
    })(InitializeRequest || (exports.InitializeRequest = InitializeRequest = {}));
    var InitializeErrorCodes;
    (function(InitializeErrorCodes2) {
      InitializeErrorCodes2.unknownProtocolVersion = 1;
    })(InitializeErrorCodes || (exports.InitializeErrorCodes = InitializeErrorCodes = {}));
    var InitializedNotification;
    (function(InitializedNotification2) {
      InitializedNotification2.method = "initialized";
      InitializedNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      InitializedNotification2.type = new messages_1.ProtocolNotificationType(InitializedNotification2.method);
    })(InitializedNotification || (exports.InitializedNotification = InitializedNotification = {}));
    var ShutdownRequest;
    (function(ShutdownRequest2) {
      ShutdownRequest2.method = "shutdown";
      ShutdownRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ShutdownRequest2.type = new messages_1.ProtocolRequestType0(ShutdownRequest2.method);
    })(ShutdownRequest || (exports.ShutdownRequest = ShutdownRequest = {}));
    var ExitNotification;
    (function(ExitNotification2) {
      ExitNotification2.method = "exit";
      ExitNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      ExitNotification2.type = new messages_1.ProtocolNotificationType0(ExitNotification2.method);
    })(ExitNotification || (exports.ExitNotification = ExitNotification = {}));
    var DidChangeConfigurationNotification;
    (function(DidChangeConfigurationNotification2) {
      DidChangeConfigurationNotification2.method = "workspace/didChangeConfiguration";
      DidChangeConfigurationNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeConfigurationNotification2.type = new messages_1.ProtocolNotificationType(DidChangeConfigurationNotification2.method);
    })(DidChangeConfigurationNotification || (exports.DidChangeConfigurationNotification = DidChangeConfigurationNotification = {}));
    var MessageType;
    (function(MessageType2) {
      MessageType2.Error = 1;
      MessageType2.Warning = 2;
      MessageType2.Info = 3;
      MessageType2.Log = 4;
      MessageType2.Debug = 5;
    })(MessageType || (exports.MessageType = MessageType = {}));
    var ShowMessageNotification;
    (function(ShowMessageNotification2) {
      ShowMessageNotification2.method = "window/showMessage";
      ShowMessageNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
      ShowMessageNotification2.type = new messages_1.ProtocolNotificationType(ShowMessageNotification2.method);
    })(ShowMessageNotification || (exports.ShowMessageNotification = ShowMessageNotification = {}));
    var ShowMessageRequest;
    (function(ShowMessageRequest2) {
      ShowMessageRequest2.method = "window/showMessageRequest";
      ShowMessageRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      ShowMessageRequest2.type = new messages_1.ProtocolRequestType(ShowMessageRequest2.method);
    })(ShowMessageRequest || (exports.ShowMessageRequest = ShowMessageRequest = {}));
    var LogMessageNotification;
    (function(LogMessageNotification2) {
      LogMessageNotification2.method = "window/logMessage";
      LogMessageNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
      LogMessageNotification2.type = new messages_1.ProtocolNotificationType(LogMessageNotification2.method);
    })(LogMessageNotification || (exports.LogMessageNotification = LogMessageNotification = {}));
    var TelemetryEventNotification;
    (function(TelemetryEventNotification2) {
      TelemetryEventNotification2.method = "telemetry/event";
      TelemetryEventNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
      TelemetryEventNotification2.type = new messages_1.ProtocolNotificationType(TelemetryEventNotification2.method);
    })(TelemetryEventNotification || (exports.TelemetryEventNotification = TelemetryEventNotification = {}));
    var TextDocumentSyncKind;
    (function(TextDocumentSyncKind2) {
      TextDocumentSyncKind2.None = 0;
      TextDocumentSyncKind2.Full = 1;
      TextDocumentSyncKind2.Incremental = 2;
    })(TextDocumentSyncKind || (exports.TextDocumentSyncKind = TextDocumentSyncKind = {}));
    var DidOpenTextDocumentNotification;
    (function(DidOpenTextDocumentNotification2) {
      DidOpenTextDocumentNotification2.method = "textDocument/didOpen";
      DidOpenTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidOpenTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification2.method);
    })(DidOpenTextDocumentNotification || (exports.DidOpenTextDocumentNotification = DidOpenTextDocumentNotification = {}));
    var TextDocumentContentChangeEvent;
    (function(TextDocumentContentChangeEvent2) {
      function isIncremental(event) {
        let candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === "number");
      }
      TextDocumentContentChangeEvent2.isIncremental = isIncremental;
      function isFull(event) {
        let candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range === void 0 && candidate.rangeLength === void 0;
      }
      TextDocumentContentChangeEvent2.isFull = isFull;
    })(TextDocumentContentChangeEvent || (exports.TextDocumentContentChangeEvent = TextDocumentContentChangeEvent = {}));
    var DidChangeTextDocumentNotification;
    (function(DidChangeTextDocumentNotification2) {
      DidChangeTextDocumentNotification2.method = "textDocument/didChange";
      DidChangeTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification2.method);
    })(DidChangeTextDocumentNotification || (exports.DidChangeTextDocumentNotification = DidChangeTextDocumentNotification = {}));
    var DidCloseTextDocumentNotification;
    (function(DidCloseTextDocumentNotification2) {
      DidCloseTextDocumentNotification2.method = "textDocument/didClose";
      DidCloseTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidCloseTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification2.method);
    })(DidCloseTextDocumentNotification || (exports.DidCloseTextDocumentNotification = DidCloseTextDocumentNotification = {}));
    var DidSaveTextDocumentNotification;
    (function(DidSaveTextDocumentNotification2) {
      DidSaveTextDocumentNotification2.method = "textDocument/didSave";
      DidSaveTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidSaveTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification2.method);
    })(DidSaveTextDocumentNotification || (exports.DidSaveTextDocumentNotification = DidSaveTextDocumentNotification = {}));
    var TextDocumentSaveReason;
    (function(TextDocumentSaveReason2) {
      TextDocumentSaveReason2.Manual = 1;
      TextDocumentSaveReason2.AfterDelay = 2;
      TextDocumentSaveReason2.FocusOut = 3;
    })(TextDocumentSaveReason || (exports.TextDocumentSaveReason = TextDocumentSaveReason = {}));
    var WillSaveTextDocumentNotification;
    (function(WillSaveTextDocumentNotification2) {
      WillSaveTextDocumentNotification2.method = "textDocument/willSave";
      WillSaveTextDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillSaveTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification2.method);
    })(WillSaveTextDocumentNotification || (exports.WillSaveTextDocumentNotification = WillSaveTextDocumentNotification = {}));
    var WillSaveTextDocumentWaitUntilRequest;
    (function(WillSaveTextDocumentWaitUntilRequest2) {
      WillSaveTextDocumentWaitUntilRequest2.method = "textDocument/willSaveWaitUntil";
      WillSaveTextDocumentWaitUntilRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WillSaveTextDocumentWaitUntilRequest2.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest2.method);
    })(WillSaveTextDocumentWaitUntilRequest || (exports.WillSaveTextDocumentWaitUntilRequest = WillSaveTextDocumentWaitUntilRequest = {}));
    var DidChangeWatchedFilesNotification;
    (function(DidChangeWatchedFilesNotification2) {
      DidChangeWatchedFilesNotification2.method = "workspace/didChangeWatchedFiles";
      DidChangeWatchedFilesNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeWatchedFilesNotification2.type = new messages_1.ProtocolNotificationType(DidChangeWatchedFilesNotification2.method);
    })(DidChangeWatchedFilesNotification || (exports.DidChangeWatchedFilesNotification = DidChangeWatchedFilesNotification = {}));
    var FileChangeType;
    (function(FileChangeType2) {
      FileChangeType2.Created = 1;
      FileChangeType2.Changed = 2;
      FileChangeType2.Deleted = 3;
    })(FileChangeType || (exports.FileChangeType = FileChangeType = {}));
    var RelativePattern;
    (function(RelativePattern2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (vscode_languageserver_types_1.URI.is(candidate.baseUri) || vscode_languageserver_types_1.WorkspaceFolder.is(candidate.baseUri)) && Is.string(candidate.pattern);
      }
      RelativePattern2.is = is;
    })(RelativePattern || (exports.RelativePattern = RelativePattern = {}));
    var WatchKind;
    (function(WatchKind2) {
      WatchKind2.Create = 1;
      WatchKind2.Change = 2;
      WatchKind2.Delete = 4;
    })(WatchKind || (exports.WatchKind = WatchKind = {}));
    var PublishDiagnosticsNotification;
    (function(PublishDiagnosticsNotification2) {
      PublishDiagnosticsNotification2.method = "textDocument/publishDiagnostics";
      PublishDiagnosticsNotification2.messageDirection = messages_1.MessageDirection.serverToClient;
      PublishDiagnosticsNotification2.type = new messages_1.ProtocolNotificationType(PublishDiagnosticsNotification2.method);
    })(PublishDiagnosticsNotification || (exports.PublishDiagnosticsNotification = PublishDiagnosticsNotification = {}));
    var CompletionTriggerKind;
    (function(CompletionTriggerKind2) {
      CompletionTriggerKind2.Invoked = 1;
      CompletionTriggerKind2.TriggerCharacter = 2;
      CompletionTriggerKind2.TriggerForIncompleteCompletions = 3;
    })(CompletionTriggerKind || (exports.CompletionTriggerKind = CompletionTriggerKind = {}));
    var CompletionRequest;
    (function(CompletionRequest2) {
      CompletionRequest2.method = "textDocument/completion";
      CompletionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CompletionRequest2.type = new messages_1.ProtocolRequestType(CompletionRequest2.method);
    })(CompletionRequest || (exports.CompletionRequest = CompletionRequest = {}));
    var CompletionResolveRequest;
    (function(CompletionResolveRequest2) {
      CompletionResolveRequest2.method = "completionItem/resolve";
      CompletionResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CompletionResolveRequest2.type = new messages_1.ProtocolRequestType(CompletionResolveRequest2.method);
    })(CompletionResolveRequest || (exports.CompletionResolveRequest = CompletionResolveRequest = {}));
    var HoverRequest;
    (function(HoverRequest2) {
      HoverRequest2.method = "textDocument/hover";
      HoverRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      HoverRequest2.type = new messages_1.ProtocolRequestType(HoverRequest2.method);
    })(HoverRequest || (exports.HoverRequest = HoverRequest = {}));
    var SignatureHelpTriggerKind;
    (function(SignatureHelpTriggerKind2) {
      SignatureHelpTriggerKind2.Invoked = 1;
      SignatureHelpTriggerKind2.TriggerCharacter = 2;
      SignatureHelpTriggerKind2.ContentChange = 3;
    })(SignatureHelpTriggerKind || (exports.SignatureHelpTriggerKind = SignatureHelpTriggerKind = {}));
    var SignatureHelpRequest;
    (function(SignatureHelpRequest2) {
      SignatureHelpRequest2.method = "textDocument/signatureHelp";
      SignatureHelpRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      SignatureHelpRequest2.type = new messages_1.ProtocolRequestType(SignatureHelpRequest2.method);
    })(SignatureHelpRequest || (exports.SignatureHelpRequest = SignatureHelpRequest = {}));
    var DefinitionRequest;
    (function(DefinitionRequest2) {
      DefinitionRequest2.method = "textDocument/definition";
      DefinitionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DefinitionRequest2.type = new messages_1.ProtocolRequestType(DefinitionRequest2.method);
    })(DefinitionRequest || (exports.DefinitionRequest = DefinitionRequest = {}));
    var ReferencesRequest;
    (function(ReferencesRequest2) {
      ReferencesRequest2.method = "textDocument/references";
      ReferencesRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ReferencesRequest2.type = new messages_1.ProtocolRequestType(ReferencesRequest2.method);
    })(ReferencesRequest || (exports.ReferencesRequest = ReferencesRequest = {}));
    var DocumentHighlightRequest;
    (function(DocumentHighlightRequest2) {
      DocumentHighlightRequest2.method = "textDocument/documentHighlight";
      DocumentHighlightRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentHighlightRequest2.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest2.method);
    })(DocumentHighlightRequest || (exports.DocumentHighlightRequest = DocumentHighlightRequest = {}));
    var DocumentSymbolRequest;
    (function(DocumentSymbolRequest2) {
      DocumentSymbolRequest2.method = "textDocument/documentSymbol";
      DocumentSymbolRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentSymbolRequest2.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest2.method);
    })(DocumentSymbolRequest || (exports.DocumentSymbolRequest = DocumentSymbolRequest = {}));
    var CodeActionRequest;
    (function(CodeActionRequest2) {
      CodeActionRequest2.method = "textDocument/codeAction";
      CodeActionRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeActionRequest2.type = new messages_1.ProtocolRequestType(CodeActionRequest2.method);
    })(CodeActionRequest || (exports.CodeActionRequest = CodeActionRequest = {}));
    var CodeActionResolveRequest;
    (function(CodeActionResolveRequest2) {
      CodeActionResolveRequest2.method = "codeAction/resolve";
      CodeActionResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeActionResolveRequest2.type = new messages_1.ProtocolRequestType(CodeActionResolveRequest2.method);
    })(CodeActionResolveRequest || (exports.CodeActionResolveRequest = CodeActionResolveRequest = {}));
    var WorkspaceSymbolRequest;
    (function(WorkspaceSymbolRequest2) {
      WorkspaceSymbolRequest2.method = "workspace/symbol";
      WorkspaceSymbolRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkspaceSymbolRequest2.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest2.method);
    })(WorkspaceSymbolRequest || (exports.WorkspaceSymbolRequest = WorkspaceSymbolRequest = {}));
    var WorkspaceSymbolResolveRequest;
    (function(WorkspaceSymbolResolveRequest2) {
      WorkspaceSymbolResolveRequest2.method = "workspaceSymbol/resolve";
      WorkspaceSymbolResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkspaceSymbolResolveRequest2.type = new messages_1.ProtocolRequestType(WorkspaceSymbolResolveRequest2.method);
    })(WorkspaceSymbolResolveRequest || (exports.WorkspaceSymbolResolveRequest = WorkspaceSymbolResolveRequest = {}));
    var CodeLensRequest;
    (function(CodeLensRequest2) {
      CodeLensRequest2.method = "textDocument/codeLens";
      CodeLensRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeLensRequest2.type = new messages_1.ProtocolRequestType(CodeLensRequest2.method);
    })(CodeLensRequest || (exports.CodeLensRequest = CodeLensRequest = {}));
    var CodeLensResolveRequest;
    (function(CodeLensResolveRequest2) {
      CodeLensResolveRequest2.method = "codeLens/resolve";
      CodeLensResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeLensResolveRequest2.type = new messages_1.ProtocolRequestType(CodeLensResolveRequest2.method);
    })(CodeLensResolveRequest || (exports.CodeLensResolveRequest = CodeLensResolveRequest = {}));
    var CodeLensRefreshRequest;
    (function(CodeLensRefreshRequest2) {
      CodeLensRefreshRequest2.method = `workspace/codeLens/refresh`;
      CodeLensRefreshRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      CodeLensRefreshRequest2.type = new messages_1.ProtocolRequestType0(CodeLensRefreshRequest2.method);
    })(CodeLensRefreshRequest || (exports.CodeLensRefreshRequest = CodeLensRefreshRequest = {}));
    var DocumentLinkRequest;
    (function(DocumentLinkRequest2) {
      DocumentLinkRequest2.method = "textDocument/documentLink";
      DocumentLinkRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentLinkRequest2.type = new messages_1.ProtocolRequestType(DocumentLinkRequest2.method);
    })(DocumentLinkRequest || (exports.DocumentLinkRequest = DocumentLinkRequest = {}));
    var DocumentLinkResolveRequest;
    (function(DocumentLinkResolveRequest2) {
      DocumentLinkResolveRequest2.method = "documentLink/resolve";
      DocumentLinkResolveRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentLinkResolveRequest2.type = new messages_1.ProtocolRequestType(DocumentLinkResolveRequest2.method);
    })(DocumentLinkResolveRequest || (exports.DocumentLinkResolveRequest = DocumentLinkResolveRequest = {}));
    var DocumentFormattingRequest;
    (function(DocumentFormattingRequest2) {
      DocumentFormattingRequest2.method = "textDocument/formatting";
      DocumentFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest2.method);
    })(DocumentFormattingRequest || (exports.DocumentFormattingRequest = DocumentFormattingRequest = {}));
    var DocumentRangeFormattingRequest;
    (function(DocumentRangeFormattingRequest2) {
      DocumentRangeFormattingRequest2.method = "textDocument/rangeFormatting";
      DocumentRangeFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentRangeFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest2.method);
    })(DocumentRangeFormattingRequest || (exports.DocumentRangeFormattingRequest = DocumentRangeFormattingRequest = {}));
    var DocumentRangesFormattingRequest;
    (function(DocumentRangesFormattingRequest2) {
      DocumentRangesFormattingRequest2.method = "textDocument/rangesFormatting";
      DocumentRangesFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentRangesFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentRangesFormattingRequest2.method);
    })(DocumentRangesFormattingRequest || (exports.DocumentRangesFormattingRequest = DocumentRangesFormattingRequest = {}));
    var DocumentOnTypeFormattingRequest;
    (function(DocumentOnTypeFormattingRequest2) {
      DocumentOnTypeFormattingRequest2.method = "textDocument/onTypeFormatting";
      DocumentOnTypeFormattingRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentOnTypeFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest2.method);
    })(DocumentOnTypeFormattingRequest || (exports.DocumentOnTypeFormattingRequest = DocumentOnTypeFormattingRequest = {}));
    var PrepareSupportDefaultBehavior;
    (function(PrepareSupportDefaultBehavior2) {
      PrepareSupportDefaultBehavior2.Identifier = 1;
    })(PrepareSupportDefaultBehavior || (exports.PrepareSupportDefaultBehavior = PrepareSupportDefaultBehavior = {}));
    var RenameRequest;
    (function(RenameRequest2) {
      RenameRequest2.method = "textDocument/rename";
      RenameRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      RenameRequest2.type = new messages_1.ProtocolRequestType(RenameRequest2.method);
    })(RenameRequest || (exports.RenameRequest = RenameRequest = {}));
    var PrepareRenameRequest;
    (function(PrepareRenameRequest2) {
      PrepareRenameRequest2.method = "textDocument/prepareRename";
      PrepareRenameRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      PrepareRenameRequest2.type = new messages_1.ProtocolRequestType(PrepareRenameRequest2.method);
    })(PrepareRenameRequest || (exports.PrepareRenameRequest = PrepareRenameRequest = {}));
    var ExecuteCommandRequest;
    (function(ExecuteCommandRequest2) {
      ExecuteCommandRequest2.method = "workspace/executeCommand";
      ExecuteCommandRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      ExecuteCommandRequest2.type = new messages_1.ProtocolRequestType(ExecuteCommandRequest2.method);
    })(ExecuteCommandRequest || (exports.ExecuteCommandRequest = ExecuteCommandRequest = {}));
    var ApplyWorkspaceEditRequest;
    (function(ApplyWorkspaceEditRequest2) {
      ApplyWorkspaceEditRequest2.method = "workspace/applyEdit";
      ApplyWorkspaceEditRequest2.messageDirection = messages_1.MessageDirection.serverToClient;
      ApplyWorkspaceEditRequest2.type = new messages_1.ProtocolRequestType("workspace/applyEdit");
    })(ApplyWorkspaceEditRequest || (exports.ApplyWorkspaceEditRequest = ApplyWorkspaceEditRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/connection.js
var require_connection2 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/connection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createProtocolConnection = void 0;
    var vscode_jsonrpc_1 = require_main();
    function createProtocolConnection(input, output, logger, options) {
      if (vscode_jsonrpc_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
      }
      return (0, vscode_jsonrpc_1.createMessageConnection)(input, output, logger, options);
    }
    exports.createProtocolConnection = createProtocolConnection;
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/api.js
var require_api2 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/api.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LSPErrorCodes = exports.createProtocolConnection = void 0;
    __exportStar(require_main(), exports);
    __exportStar(require_main2(), exports);
    __exportStar(require_messages2(), exports);
    __exportStar(require_protocol(), exports);
    var connection_1 = require_connection2();
    Object.defineProperty(exports, "createProtocolConnection", { enumerable: true, get: function() {
      return connection_1.createProtocolConnection;
    } });
    var LSPErrorCodes;
    (function(LSPErrorCodes2) {
      LSPErrorCodes2.lspReservedErrorRangeStart = -32899;
      LSPErrorCodes2.RequestFailed = -32803;
      LSPErrorCodes2.ServerCancelled = -32802;
      LSPErrorCodes2.ContentModified = -32801;
      LSPErrorCodes2.RequestCancelled = -32800;
      LSPErrorCodes2.lspReservedErrorRangeEnd = -32800;
    })(LSPErrorCodes || (exports.LSPErrorCodes = LSPErrorCodes = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/node/main.js
var require_main3 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/node/main.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createProtocolConnection = void 0;
    var node_1 = require_node();
    __exportStar(require_node(), exports);
    __exportStar(require_api2(), exports);
    function createProtocolConnection(input, output, logger, options) {
      return (0, node_1.createMessageConnection)(input, output, logger, options);
    }
    exports.createProtocolConnection = createProtocolConnection;
  }
});

// node_modules/vscode-languageserver/lib/utils/is.js
var require_is3 = __commonJS({
  "node_modules/vscode-languageserver/lib/utils/is.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function boolean(value) {
      return value === true || value === false;
    }
    exports.boolean = boolean;
    function string(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports.string = string;
    function number(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports.number = number;
    function error(value) {
      return value instanceof Error;
    }
    exports.error = error;
    function func(value) {
      return typeof value === "function";
    }
    exports.func = func;
    function array(value) {
      return Array.isArray(value);
    }
    exports.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string(elem));
    }
    exports.stringArray = stringArray;
    function typedArray(value, check) {
      return Array.isArray(value) && value.every(check);
    }
    exports.typedArray = typedArray;
    function thenable(value) {
      return value && func(value.then);
    }
    exports.thenable = thenable;
  }
});

// node_modules/vscode-languageserver/lib/configuration.js
var require_configuration = __commonJS({
  "node_modules/vscode-languageserver/lib/configuration.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var vscode_languageserver_protocol_1 = require_main3();
    var Is = require_is3();
    exports.ConfigurationFeature = (Base) => {
      return class extends Base {
        getConfiguration(arg) {
          if (!arg) {
            return this._getConfiguration({});
          } else if (Is.string(arg)) {
            return this._getConfiguration({ section: arg });
          } else {
            return this._getConfiguration(arg);
          }
        }
        _getConfiguration(arg) {
          let params = {
            items: Array.isArray(arg) ? arg : [arg]
          };
          return this.connection.sendRequest(vscode_languageserver_protocol_1.ConfigurationRequest.type, params).then((result) => {
            return Array.isArray(arg) ? result : result[0];
          });
        }
      };
    };
  }
});

// node_modules/vscode-languageserver/lib/workspaceFolders.js
var require_workspaceFolders = __commonJS({
  "node_modules/vscode-languageserver/lib/workspaceFolders.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var vscode_languageserver_protocol_1 = require_main3();
    exports.WorkspaceFoldersFeature = (Base) => {
      return class extends Base {
        initialize(capabilities) {
          let workspaceCapabilities = capabilities.workspace;
          if (workspaceCapabilities && workspaceCapabilities.workspaceFolders) {
            this._onDidChangeWorkspaceFolders = new vscode_languageserver_protocol_1.Emitter();
            this.connection.onNotification(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type, (params) => {
              this._onDidChangeWorkspaceFolders.fire(params.event);
            });
          }
        }
        getWorkspaceFolders() {
          return this.connection.sendRequest(vscode_languageserver_protocol_1.WorkspaceFoldersRequest.type);
        }
        get onDidChangeWorkspaceFolders() {
          if (!this._onDidChangeWorkspaceFolders) {
            throw new Error("Client doesn't support sending workspace folder change events.");
          }
          if (!this._unregistration) {
            this._unregistration = this.connection.client.register(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type);
          }
          return this._onDidChangeWorkspaceFolders.event;
        }
      };
    };
  }
});

// node_modules/vscode-languageserver/lib/utils/uuid.js
var require_uuid = __commonJS({
  "node_modules/vscode-languageserver/lib/utils/uuid.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ValueUUID = class {
      constructor(_value) {
        this._value = _value;
      }
      asHex() {
        return this._value;
      }
      equals(other) {
        return this.asHex() === other.asHex();
      }
    };
    var V4UUID = class extends ValueUUID {
      constructor() {
        super([
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          "-",
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          "-",
          "4",
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          "-",
          V4UUID._oneOf(V4UUID._timeHighBits),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          "-",
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex()
        ].join(""));
      }
      static _oneOf(array) {
        return array[Math.floor(array.length * Math.random())];
      }
      static _randomHex() {
        return V4UUID._oneOf(V4UUID._chars);
      }
    };
    V4UUID._chars = ["0", "1", "2", "3", "4", "5", "6", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
    V4UUID._timeHighBits = ["8", "9", "a", "b"];
    exports.empty = new ValueUUID("00000000-0000-0000-0000-000000000000");
    function v4() {
      return new V4UUID();
    }
    exports.v4 = v4;
    var _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
    function isUUID(value) {
      return _UUIDPattern.test(value);
    }
    exports.isUUID = isUUID;
    function parse(value) {
      if (!isUUID(value)) {
        throw new Error("invalid uuid");
      }
      return new ValueUUID(value);
    }
    exports.parse = parse;
    function generateUuid() {
      return v4().asHex();
    }
    exports.generateUuid = generateUuid;
  }
});

// node_modules/vscode-languageserver/lib/progress.js
var require_progress = __commonJS({
  "node_modules/vscode-languageserver/lib/progress.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var vscode_languageserver_protocol_1 = require_main3();
    var uuid_1 = require_uuid();
    var WorkDoneProgressImpl = class {
      constructor(_connection, _token) {
        this._connection = _connection;
        this._token = _token;
        WorkDoneProgressImpl.Instances.set(this._token, this);
        this._source = new vscode_languageserver_protocol_1.CancellationTokenSource();
      }
      get token() {
        return this._source.token;
      }
      begin(title, percentage, message, cancellable) {
        let param = {
          kind: "begin",
          title,
          percentage,
          message,
          cancellable
        };
        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, param);
      }
      report(arg0, arg1) {
        let param = {
          kind: "report"
        };
        if (typeof arg0 === "number") {
          param.percentage = arg0;
          if (arg1 !== void 0) {
            param.message = arg1;
          }
        } else {
          param.message = arg0;
        }
        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, param);
      }
      done() {
        WorkDoneProgressImpl.Instances.delete(this._token);
        this._source.dispose();
        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, { kind: "end" });
      }
      cancel() {
        this._source.cancel();
      }
    };
    WorkDoneProgressImpl.Instances = /* @__PURE__ */ new Map();
    var NullProgress = class {
      constructor() {
        this._source = new vscode_languageserver_protocol_1.CancellationTokenSource();
      }
      get token() {
        return this._source.token;
      }
      begin() {
      }
      report() {
      }
      done() {
      }
    };
    function attachWorkDone(connection, params) {
      if (params === void 0 || params.workDoneToken === void 0) {
        return new NullProgress();
      }
      const token = params.workDoneToken;
      delete params.workDoneToken;
      return new WorkDoneProgressImpl(connection, token);
    }
    exports.attachWorkDone = attachWorkDone;
    exports.ProgressFeature = (Base) => {
      return class extends Base {
        initialize(capabilities) {
          var _a;
          if (((_a = capabilities === null || capabilities === void 0 ? void 0 : capabilities.window) === null || _a === void 0 ? void 0 : _a.workDoneProgress) === true) {
            this._progressSupported = true;
            this.connection.onNotification(vscode_languageserver_protocol_1.WorkDoneProgressCancelNotification.type, (params) => {
              let progress = WorkDoneProgressImpl.Instances.get(params.token);
              if (progress !== void 0) {
                progress.cancel();
              }
            });
          }
        }
        attachWorkDoneProgress(token) {
          if (token === void 0) {
            return new NullProgress();
          } else {
            return new WorkDoneProgressImpl(this.connection, token);
          }
        }
        createWorkDoneProgress() {
          if (this._progressSupported) {
            const token = uuid_1.generateUuid();
            return this.connection.sendRequest(vscode_languageserver_protocol_1.WorkDoneProgressCreateRequest.type, { token }).then(() => {
              const result = new WorkDoneProgressImpl(this.connection, token);
              return result;
            });
          } else {
            return Promise.resolve(new NullProgress());
          }
        }
      };
    };
    var ResultProgress;
    (function(ResultProgress2) {
      ResultProgress2.type = new vscode_languageserver_protocol_1.ProgressType();
    })(ResultProgress || (ResultProgress = {}));
    var ResultProgressImpl = class {
      constructor(_connection, _token) {
        this._connection = _connection;
        this._token = _token;
      }
      report(data) {
        this._connection.sendProgress(ResultProgress.type, this._token, data);
      }
    };
    function attachPartialResult(connection, params) {
      if (params === void 0 || params.partialResultToken === void 0) {
        return void 0;
      }
      const token = params.partialResultToken;
      delete params.partialResultToken;
      return new ResultProgressImpl(connection, token);
    }
    exports.attachPartialResult = attachPartialResult;
  }
});

// node_modules/vscode-languageserver/lib/files.js
var require_files = __commonJS({
  "node_modules/vscode-languageserver/lib/files.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var url = require("url");
    var path = require("path");
    var fs = require("fs");
    var child_process_1 = require("child_process");
    function uriToFilePath(uri) {
      let parsed = url.parse(uri);
      if (parsed.protocol !== "file:" || !parsed.path) {
        return void 0;
      }
      let segments = parsed.path.split("/");
      for (var i = 0, len = segments.length; i < len; i++) {
        segments[i] = decodeURIComponent(segments[i]);
      }
      if (process.platform === "win32" && segments.length > 1) {
        let first = segments[0];
        let second = segments[1];
        if (first.length === 0 && second.length > 1 && second[1] === ":") {
          segments.shift();
        }
      }
      return path.normalize(segments.join("/"));
    }
    exports.uriToFilePath = uriToFilePath;
    function isWindows() {
      return process.platform === "win32";
    }
    function resolve(moduleName, nodePath, cwd, tracer) {
      const nodePathKey = "NODE_PATH";
      const app = [
        "var p = process;",
        "p.on('message',function(m){",
        "if(m.c==='e'){",
        "p.exit(0);",
        "}",
        "else if(m.c==='rs'){",
        "try{",
        "var r=require.resolve(m.a);",
        "p.send({c:'r',s:true,r:r});",
        "}",
        "catch(err){",
        "p.send({c:'r',s:false});",
        "}",
        "}",
        "});"
      ].join("");
      return new Promise((resolve2, reject) => {
        let env = process.env;
        let newEnv = /* @__PURE__ */ Object.create(null);
        Object.keys(env).forEach((key) => newEnv[key] = env[key]);
        if (nodePath && fs.existsSync(nodePath)) {
          if (newEnv[nodePathKey]) {
            newEnv[nodePathKey] = nodePath + path.delimiter + newEnv[nodePathKey];
          } else {
            newEnv[nodePathKey] = nodePath;
          }
          if (tracer) {
            tracer(`NODE_PATH value is: ${newEnv[nodePathKey]}`);
          }
        }
        newEnv["ELECTRON_RUN_AS_NODE"] = "1";
        try {
          let cp = child_process_1.fork("", [], {
            cwd,
            env: newEnv,
            execArgv: ["-e", app]
          });
          if (cp.pid === void 0) {
            reject(new Error(`Starting process to resolve node module  ${moduleName} failed`));
            return;
          }
          cp.on("error", (error) => {
            reject(error);
          });
          cp.on("message", (message2) => {
            if (message2.c === "r") {
              cp.send({ c: "e" });
              if (message2.s) {
                resolve2(message2.r);
              } else {
                reject(new Error(`Failed to resolve module: ${moduleName}`));
              }
            }
          });
          let message = {
            c: "rs",
            a: moduleName
          };
          cp.send(message);
        } catch (error) {
          reject(error);
        }
      });
    }
    exports.resolve = resolve;
    function resolveGlobalNodePath(tracer) {
      let npmCommand = "npm";
      const env = /* @__PURE__ */ Object.create(null);
      Object.keys(process.env).forEach((key) => env[key] = process.env[key]);
      env["NO_UPDATE_NOTIFIER"] = "true";
      const options = {
        encoding: "utf8",
        env
      };
      if (isWindows()) {
        npmCommand = "npm.cmd";
        options.shell = true;
      }
      let handler = () => {
      };
      try {
        process.on("SIGPIPE", handler);
        let stdout = child_process_1.spawnSync(npmCommand, ["config", "get", "prefix"], options).stdout;
        if (!stdout) {
          if (tracer) {
            tracer(`'npm config get prefix' didn't return a value.`);
          }
          return void 0;
        }
        let prefix = stdout.trim();
        if (tracer) {
          tracer(`'npm config get prefix' value is: ${prefix}`);
        }
        if (prefix.length > 0) {
          if (isWindows()) {
            return path.join(prefix, "node_modules");
          } else {
            return path.join(prefix, "lib", "node_modules");
          }
        }
        return void 0;
      } catch (err) {
        return void 0;
      } finally {
        process.removeListener("SIGPIPE", handler);
      }
    }
    exports.resolveGlobalNodePath = resolveGlobalNodePath;
    function resolveGlobalYarnPath(tracer) {
      let yarnCommand = "yarn";
      let options = {
        encoding: "utf8"
      };
      if (isWindows()) {
        yarnCommand = "yarn.cmd";
        options.shell = true;
      }
      let handler = () => {
      };
      try {
        process.on("SIGPIPE", handler);
        let results = child_process_1.spawnSync(yarnCommand, ["global", "dir", "--json"], options);
        let stdout = results.stdout;
        if (!stdout) {
          if (tracer) {
            tracer(`'yarn global dir' didn't return a value.`);
            if (results.stderr) {
              tracer(results.stderr);
            }
          }
          return void 0;
        }
        let lines = stdout.trim().split(/\r?\n/);
        for (let line of lines) {
          try {
            let yarn = JSON.parse(line);
            if (yarn.type === "log") {
              return path.join(yarn.data, "node_modules");
            }
          } catch (e) {
          }
        }
        return void 0;
      } catch (err) {
        return void 0;
      } finally {
        process.removeListener("SIGPIPE", handler);
      }
    }
    exports.resolveGlobalYarnPath = resolveGlobalYarnPath;
    var FileSystem;
    (function(FileSystem2) {
      let _isCaseSensitive = void 0;
      function isCaseSensitive() {
        if (_isCaseSensitive !== void 0) {
          return _isCaseSensitive;
        }
        if (process.platform === "win32") {
          _isCaseSensitive = false;
        } else {
          _isCaseSensitive = !fs.existsSync(__filename.toUpperCase()) || !fs.existsSync(__filename.toLowerCase());
        }
        return _isCaseSensitive;
      }
      FileSystem2.isCaseSensitive = isCaseSensitive;
      function isParent(parent, child) {
        if (isCaseSensitive()) {
          return path.normalize(child).indexOf(path.normalize(parent)) === 0;
        } else {
          return path.normalize(child).toLowerCase().indexOf(path.normalize(parent).toLowerCase()) === 0;
        }
      }
      FileSystem2.isParent = isParent;
    })(FileSystem = exports.FileSystem || (exports.FileSystem = {}));
    function resolveModulePath(workspaceRoot, moduleName, nodePath, tracer) {
      if (nodePath) {
        if (!path.isAbsolute(nodePath)) {
          nodePath = path.join(workspaceRoot, nodePath);
        }
        return resolve(moduleName, nodePath, nodePath, tracer).then((value) => {
          if (FileSystem.isParent(nodePath, value)) {
            return value;
          } else {
            return Promise.reject(new Error(`Failed to load ${moduleName} from node path location.`));
          }
        }).then(void 0, (_error) => {
          return resolve(moduleName, resolveGlobalNodePath(tracer), workspaceRoot, tracer);
        });
      } else {
        return resolve(moduleName, resolveGlobalNodePath(tracer), workspaceRoot, tracer);
      }
    }
    exports.resolveModulePath = resolveModulePath;
  }
});

// node_modules/vscode-languageserver/lib/callHierarchy.proposed.js
var require_callHierarchy_proposed = __commonJS({
  "node_modules/vscode-languageserver/lib/callHierarchy.proposed.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var vscode_languageserver_protocol_1 = require_main3();
    exports.CallHierarchyFeature = (Base) => {
      return class extends Base {
        get callHierarchy() {
          return {
            onPrepare: (handler) => {
              this.connection.onRequest(vscode_languageserver_protocol_1.Proposed.CallHierarchyPrepareRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), void 0);
              });
            },
            onIncomingCalls: (handler) => {
              const type = vscode_languageserver_protocol_1.Proposed.CallHierarchyIncomingCallsRequest.type;
              this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            },
            onOutgoingCalls: (handler) => {
              const type = vscode_languageserver_protocol_1.Proposed.CallHierarchyOutgoingCallsRequest.type;
              this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            }
          };
        }
      };
    };
  }
});

// node_modules/vscode-languageserver/lib/sematicTokens.proposed.js
var require_sematicTokens_proposed = __commonJS({
  "node_modules/vscode-languageserver/lib/sematicTokens.proposed.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var vscode_languageserver_protocol_1 = require_main3();
    exports.SemanticTokensFeature = (Base) => {
      return class extends Base {
        get semanticTokens() {
          return {
            on: (handler) => {
              const type = vscode_languageserver_protocol_1.Proposed.SemanticTokensRequest.type;
              this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            },
            onEdits: (handler) => {
              const type = vscode_languageserver_protocol_1.Proposed.SemanticTokensEditsRequest.type;
              this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            },
            onRange: (handler) => {
              const type = vscode_languageserver_protocol_1.Proposed.SemanticTokensRangeRequest.type;
              this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            }
          };
        }
      };
    };
    var SemanticTokensBuilder = class {
      constructor() {
        this._prevData = void 0;
        this.initialize();
      }
      initialize() {
        this._id = Date.now();
        this._prevLine = 0;
        this._prevChar = 0;
        this._data = [];
        this._dataLen = 0;
      }
      push(line, char, length, tokenType, tokenModifiers) {
        let pushLine = line;
        let pushChar = char;
        if (this._dataLen > 0) {
          pushLine -= this._prevLine;
          if (pushLine === 0) {
            pushChar -= this._prevChar;
          }
        }
        this._data[this._dataLen++] = pushLine;
        this._data[this._dataLen++] = pushChar;
        this._data[this._dataLen++] = length;
        this._data[this._dataLen++] = tokenType;
        this._data[this._dataLen++] = tokenModifiers;
        this._prevLine = line;
        this._prevChar = char;
      }
      get id() {
        return this._id.toString();
      }
      previousResult(id) {
        if (this.id === id) {
          this._prevData = this._data;
        }
        this.initialize();
      }
      build() {
        this._prevData = void 0;
        return {
          resultId: this.id,
          data: this._data
        };
      }
      canBuildEdits() {
        return this._prevData !== void 0;
      }
      buildEdits() {
        if (this._prevData !== void 0) {
          const prevDataLength = this._prevData.length;
          const dataLength = this._data.length;
          let startIndex = 0;
          while (startIndex < dataLength && startIndex < prevDataLength && this._prevData[startIndex] === this._data[startIndex]) {
            startIndex++;
          }
          if (startIndex < dataLength && startIndex < prevDataLength) {
            let endIndex = 0;
            while (endIndex < dataLength && endIndex < prevDataLength && this._prevData[prevDataLength - 1 - endIndex] === this._data[dataLength - 1 - endIndex]) {
              endIndex++;
            }
            const newData = this._data.slice(startIndex, dataLength - endIndex);
            const result = {
              resultId: this.id,
              edits: [
                { start: startIndex, deleteCount: prevDataLength - endIndex - startIndex, data: newData }
              ]
            };
            return result;
          } else if (startIndex < dataLength) {
            return { resultId: this.id, edits: [
              { start: startIndex, deleteCount: 0, data: this._data.slice(startIndex) }
            ] };
          } else if (startIndex < prevDataLength) {
            return { resultId: this.id, edits: [
              { start: startIndex, deleteCount: prevDataLength - startIndex }
            ] };
          } else {
            return { resultId: this.id, edits: [] };
          }
        } else {
          return this.build();
        }
      }
    };
    exports.SemanticTokensBuilder = SemanticTokensBuilder;
  }
});

// node_modules/vscode-languageserver/lib/main.js
var require_main4 = __commonJS({
  "node_modules/vscode-languageserver/lib/main.js"(exports) {
    "use strict";
    function __export2(m) {
      for (var p in m)
        if (!exports.hasOwnProperty(p))
          exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    var vscode_languageserver_protocol_1 = require_main3();
    exports.Event = vscode_languageserver_protocol_1.Event;
    var configuration_1 = require_configuration();
    var workspaceFolders_1 = require_workspaceFolders();
    var progress_1 = require_progress();
    var Is = require_is3();
    var UUID = require_uuid();
    __export2(require_main3());
    var fm = require_files();
    var Files;
    (function(Files2) {
      Files2.uriToFilePath = fm.uriToFilePath;
      Files2.resolveGlobalNodePath = fm.resolveGlobalNodePath;
      Files2.resolveGlobalYarnPath = fm.resolveGlobalYarnPath;
      Files2.resolve = fm.resolve;
      Files2.resolveModulePath = fm.resolveModulePath;
    })(Files = exports.Files || (exports.Files = {}));
    var shutdownReceived = false;
    var exitTimer = void 0;
    function setupExitTimer() {
      const argName = "--clientProcessId";
      function runTimer(value) {
        try {
          let processId = parseInt(value);
          if (!isNaN(processId)) {
            exitTimer = setInterval(() => {
              try {
                process.kill(processId, 0);
              } catch (ex) {
                process.exit(shutdownReceived ? 0 : 1);
              }
            }, 3e3);
          }
        } catch (e) {
        }
      }
      for (let i = 2; i < process.argv.length; i++) {
        let arg = process.argv[i];
        if (arg === argName && i + 1 < process.argv.length) {
          runTimer(process.argv[i + 1]);
          return;
        } else {
          let args = arg.split("=");
          if (args[0] === argName) {
            runTimer(args[1]);
          }
        }
      }
    }
    setupExitTimer();
    function null2Undefined(value) {
      if (value === null) {
        return void 0;
      }
      return value;
    }
    var TextDocuments = class {
      constructor(configuration) {
        this._documents = /* @__PURE__ */ Object.create(null);
        this._configuration = configuration;
        this._onDidChangeContent = new vscode_languageserver_protocol_1.Emitter();
        this._onDidOpen = new vscode_languageserver_protocol_1.Emitter();
        this._onDidClose = new vscode_languageserver_protocol_1.Emitter();
        this._onDidSave = new vscode_languageserver_protocol_1.Emitter();
        this._onWillSave = new vscode_languageserver_protocol_1.Emitter();
      }
      get onDidChangeContent() {
        return this._onDidChangeContent.event;
      }
      get onDidOpen() {
        return this._onDidOpen.event;
      }
      get onWillSave() {
        return this._onWillSave.event;
      }
      onWillSaveWaitUntil(handler) {
        this._willSaveWaitUntil = handler;
      }
      get onDidSave() {
        return this._onDidSave.event;
      }
      get onDidClose() {
        return this._onDidClose.event;
      }
      get(uri) {
        return this._documents[uri];
      }
      all() {
        return Object.keys(this._documents).map((key) => this._documents[key]);
      }
      keys() {
        return Object.keys(this._documents);
      }
      listen(connection) {
        connection.__textDocumentSync = vscode_languageserver_protocol_1.TextDocumentSyncKind.Full;
        connection.onDidOpenTextDocument((event) => {
          let td = event.textDocument;
          let document = this._configuration.create(td.uri, td.languageId, td.version, td.text);
          this._documents[td.uri] = document;
          let toFire = Object.freeze({ document });
          this._onDidOpen.fire(toFire);
          this._onDidChangeContent.fire(toFire);
        });
        connection.onDidChangeTextDocument((event) => {
          let td = event.textDocument;
          let changes = event.contentChanges;
          if (changes.length === 0) {
            return;
          }
          let document = this._documents[td.uri];
          const { version } = td;
          if (version === null || version === void 0) {
            throw new Error(`Received document change event for ${td.uri} without valid version identifier`);
          }
          document = this._configuration.update(document, changes, version);
          this._documents[td.uri] = document;
          this._onDidChangeContent.fire(Object.freeze({ document }));
        });
        connection.onDidCloseTextDocument((event) => {
          let document = this._documents[event.textDocument.uri];
          if (document) {
            delete this._documents[event.textDocument.uri];
            this._onDidClose.fire(Object.freeze({ document }));
          }
        });
        connection.onWillSaveTextDocument((event) => {
          let document = this._documents[event.textDocument.uri];
          if (document) {
            this._onWillSave.fire(Object.freeze({ document, reason: event.reason }));
          }
        });
        connection.onWillSaveTextDocumentWaitUntil((event, token) => {
          let document = this._documents[event.textDocument.uri];
          if (document && this._willSaveWaitUntil) {
            return this._willSaveWaitUntil(Object.freeze({ document, reason: event.reason }), token);
          } else {
            return [];
          }
        });
        connection.onDidSaveTextDocument((event) => {
          let document = this._documents[event.textDocument.uri];
          if (document) {
            this._onDidSave.fire(Object.freeze({ document }));
          }
        });
      }
    };
    exports.TextDocuments = TextDocuments;
    var ErrorMessageTracker = class {
      constructor() {
        this._messages = /* @__PURE__ */ Object.create(null);
      }
      add(message) {
        let count = this._messages[message];
        if (!count) {
          count = 0;
        }
        count++;
        this._messages[message] = count;
      }
      sendErrors(connection) {
        Object.keys(this._messages).forEach((message) => {
          connection.window.showErrorMessage(message);
        });
      }
    };
    exports.ErrorMessageTracker = ErrorMessageTracker;
    var RemoteConsoleImpl = class {
      constructor() {
      }
      rawAttach(connection) {
        this._rawConnection = connection;
      }
      attach(connection) {
        this._connection = connection;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      fillServerCapabilities(_capabilities) {
      }
      initialize(_capabilities) {
      }
      error(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Error, message);
      }
      warn(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Warning, message);
      }
      info(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Info, message);
      }
      log(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Log, message);
      }
      send(type, message) {
        if (this._rawConnection) {
          this._rawConnection.sendNotification(vscode_languageserver_protocol_1.LogMessageNotification.type, { type, message });
        }
      }
    };
    var _RemoteWindowImpl = class {
      constructor() {
      }
      attach(connection) {
        this._connection = connection;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      showErrorMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Error, message, actions };
        return this._connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
      }
      showWarningMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Warning, message, actions };
        return this._connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
      }
      showInformationMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Info, message, actions };
        return this._connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
      }
    };
    var RemoteWindowImpl = progress_1.ProgressFeature(_RemoteWindowImpl);
    var BulkRegistration;
    (function(BulkRegistration2) {
      function create() {
        return new BulkRegistrationImpl();
      }
      BulkRegistration2.create = create;
    })(BulkRegistration = exports.BulkRegistration || (exports.BulkRegistration = {}));
    var BulkRegistrationImpl = class {
      constructor() {
        this._registrations = [];
        this._registered = /* @__PURE__ */ new Set();
      }
      add(type, registerOptions) {
        const method = Is.string(type) ? type : type.method;
        if (this._registered.has(method)) {
          throw new Error(`${method} is already added to this registration`);
        }
        const id = UUID.generateUuid();
        this._registrations.push({
          id,
          method,
          registerOptions: registerOptions || {}
        });
        this._registered.add(method);
      }
      asRegistrationParams() {
        return {
          registrations: this._registrations
        };
      }
    };
    var BulkUnregistration;
    (function(BulkUnregistration2) {
      function create() {
        return new BulkUnregistrationImpl(void 0, []);
      }
      BulkUnregistration2.create = create;
    })(BulkUnregistration = exports.BulkUnregistration || (exports.BulkUnregistration = {}));
    var BulkUnregistrationImpl = class {
      constructor(_connection, unregistrations) {
        this._connection = _connection;
        this._unregistrations = /* @__PURE__ */ new Map();
        unregistrations.forEach((unregistration) => {
          this._unregistrations.set(unregistration.method, unregistration);
        });
      }
      get isAttached() {
        return !!this._connection;
      }
      attach(connection) {
        this._connection = connection;
      }
      add(unregistration) {
        this._unregistrations.set(unregistration.method, unregistration);
      }
      dispose() {
        let unregistrations = [];
        for (let unregistration of this._unregistrations.values()) {
          unregistrations.push(unregistration);
        }
        let params = {
          unregisterations: unregistrations
        };
        this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).then(void 0, (_error) => {
          this._connection.console.info(`Bulk unregistration failed.`);
        });
      }
      disposeSingle(arg) {
        const method = Is.string(arg) ? arg : arg.method;
        const unregistration = this._unregistrations.get(method);
        if (!unregistration) {
          return false;
        }
        let params = {
          unregisterations: [unregistration]
        };
        this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).then(() => {
          this._unregistrations.delete(method);
        }, (_error) => {
          this._connection.console.info(`Unregistering request handler for ${unregistration.id} failed.`);
        });
        return true;
      }
    };
    var RemoteClientImpl = class {
      attach(connection) {
        this._connection = connection;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      register(typeOrRegistrations, registerOptionsOrType, registerOptions) {
        if (typeOrRegistrations instanceof BulkRegistrationImpl) {
          return this.registerMany(typeOrRegistrations);
        } else if (typeOrRegistrations instanceof BulkUnregistrationImpl) {
          return this.registerSingle1(typeOrRegistrations, registerOptionsOrType, registerOptions);
        } else {
          return this.registerSingle2(typeOrRegistrations, registerOptionsOrType);
        }
      }
      registerSingle1(unregistration, type, registerOptions) {
        const method = Is.string(type) ? type : type.method;
        const id = UUID.generateUuid();
        let params = {
          registrations: [{ id, method, registerOptions: registerOptions || {} }]
        };
        if (!unregistration.isAttached) {
          unregistration.attach(this._connection);
        }
        return this._connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {
          unregistration.add({ id, method });
          return unregistration;
        }, (_error) => {
          this.connection.console.info(`Registering request handler for ${method} failed.`);
          return Promise.reject(_error);
        });
      }
      registerSingle2(type, registerOptions) {
        const method = Is.string(type) ? type : type.method;
        const id = UUID.generateUuid();
        let params = {
          registrations: [{ id, method, registerOptions: registerOptions || {} }]
        };
        return this._connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {
          return vscode_languageserver_protocol_1.Disposable.create(() => {
            this.unregisterSingle(id, method);
          });
        }, (_error) => {
          this.connection.console.info(`Registering request handler for ${method} failed.`);
          return Promise.reject(_error);
        });
      }
      unregisterSingle(id, method) {
        let params = {
          unregisterations: [{ id, method }]
        };
        return this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).then(void 0, (_error) => {
          this.connection.console.info(`Unregistering request handler for ${id} failed.`);
        });
      }
      registerMany(registrations) {
        let params = registrations.asRegistrationParams();
        return this._connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then(() => {
          return new BulkUnregistrationImpl(this._connection, params.registrations.map((registration) => {
            return { id: registration.id, method: registration.method };
          }));
        }, (_error) => {
          this.connection.console.info(`Bulk registration failed.`);
          return Promise.reject(_error);
        });
      }
    };
    var _RemoteWorkspaceImpl = class {
      constructor() {
      }
      attach(connection) {
        this._connection = connection;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      applyEdit(paramOrEdit) {
        function isApplyWorkspaceEditParams(value) {
          return value && !!value.edit;
        }
        let params = isApplyWorkspaceEditParams(paramOrEdit) ? paramOrEdit : { edit: paramOrEdit };
        return this._connection.sendRequest(vscode_languageserver_protocol_1.ApplyWorkspaceEditRequest.type, params);
      }
    };
    var RemoteWorkspaceImpl = workspaceFolders_1.WorkspaceFoldersFeature(configuration_1.ConfigurationFeature(_RemoteWorkspaceImpl));
    var TelemetryImpl = class {
      constructor() {
      }
      attach(connection) {
        this._connection = connection;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      logEvent(data) {
        this._connection.sendNotification(vscode_languageserver_protocol_1.TelemetryEventNotification.type, data);
      }
    };
    var TracerImpl = class {
      constructor() {
        this._trace = vscode_languageserver_protocol_1.Trace.Off;
      }
      attach(connection) {
        this._connection = connection;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      set trace(value) {
        this._trace = value;
      }
      log(message, verbose) {
        if (this._trace === vscode_languageserver_protocol_1.Trace.Off) {
          return;
        }
        this._connection.sendNotification(vscode_languageserver_protocol_1.LogTraceNotification.type, {
          message,
          verbose: this._trace === vscode_languageserver_protocol_1.Trace.Verbose ? verbose : void 0
        });
      }
    };
    var LanguagesImpl = class {
      constructor() {
      }
      attach(connection) {
        this._connection = connection;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      attachWorkDoneProgress(params) {
        return progress_1.attachWorkDone(this.connection, params);
      }
      attachPartialResultProgress(_type, params) {
        return progress_1.attachPartialResult(this.connection, params);
      }
    };
    exports.LanguagesImpl = LanguagesImpl;
    function combineConsoleFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports.combineConsoleFeatures = combineConsoleFeatures;
    function combineTelemetryFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports.combineTelemetryFeatures = combineTelemetryFeatures;
    function combineTracerFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports.combineTracerFeatures = combineTracerFeatures;
    function combineClientFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports.combineClientFeatures = combineClientFeatures;
    function combineWindowFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports.combineWindowFeatures = combineWindowFeatures;
    function combineWorkspaceFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports.combineWorkspaceFeatures = combineWorkspaceFeatures;
    function combineLanguagesFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports.combineLanguagesFeatures = combineLanguagesFeatures;
    function combineFeatures(one, two) {
      function combine(one2, two2, func) {
        if (one2 && two2) {
          return func(one2, two2);
        } else if (one2) {
          return one2;
        } else {
          return two2;
        }
      }
      let result = {
        __brand: "features",
        console: combine(one.console, two.console, combineConsoleFeatures),
        tracer: combine(one.tracer, two.tracer, combineTracerFeatures),
        telemetry: combine(one.telemetry, two.telemetry, combineTelemetryFeatures),
        client: combine(one.client, two.client, combineClientFeatures),
        window: combine(one.window, two.window, combineWindowFeatures),
        workspace: combine(one.workspace, two.workspace, combineWorkspaceFeatures)
      };
      return result;
    }
    exports.combineFeatures = combineFeatures;
    function createConnection(arg1, arg2, arg3, arg4) {
      let factories;
      let input;
      let output;
      let strategy;
      if (arg1 !== void 0 && arg1.__brand === "features") {
        factories = arg1;
        arg1 = arg2;
        arg2 = arg3;
        arg3 = arg4;
      }
      if (vscode_languageserver_protocol_1.ConnectionStrategy.is(arg1)) {
        strategy = arg1;
      } else {
        input = arg1;
        output = arg2;
        strategy = arg3;
      }
      return _createConnection(input, output, strategy, factories);
    }
    exports.createConnection = createConnection;
    function _createConnection(input, output, strategy, factories) {
      if (!input && !output && process.argv.length > 2) {
        let port = void 0;
        let pipeName = void 0;
        let argv = process.argv.slice(2);
        for (let i = 0; i < argv.length; i++) {
          let arg = argv[i];
          if (arg === "--node-ipc") {
            input = new vscode_languageserver_protocol_1.IPCMessageReader(process);
            output = new vscode_languageserver_protocol_1.IPCMessageWriter(process);
            break;
          } else if (arg === "--stdio") {
            input = process.stdin;
            output = process.stdout;
            break;
          } else if (arg === "--socket") {
            port = parseInt(argv[i + 1]);
            break;
          } else if (arg === "--pipe") {
            pipeName = argv[i + 1];
            break;
          } else {
            var args = arg.split("=");
            if (args[0] === "--socket") {
              port = parseInt(args[1]);
              break;
            } else if (args[0] === "--pipe") {
              pipeName = args[1];
              break;
            }
          }
        }
        if (port) {
          let transport = vscode_languageserver_protocol_1.createServerSocketTransport(port);
          input = transport[0];
          output = transport[1];
        } else if (pipeName) {
          let transport = vscode_languageserver_protocol_1.createServerPipeTransport(pipeName);
          input = transport[0];
          output = transport[1];
        }
      }
      var commandLineMessage = "Use arguments of createConnection or set command line parameters: '--node-ipc', '--stdio' or '--socket={number}'";
      if (!input) {
        throw new Error("Connection input stream is not set. " + commandLineMessage);
      }
      if (!output) {
        throw new Error("Connection output stream is not set. " + commandLineMessage);
      }
      if (Is.func(input.read) && Is.func(input.on)) {
        let inputStream = input;
        inputStream.on("end", () => {
          process.exit(shutdownReceived ? 0 : 1);
        });
        inputStream.on("close", () => {
          process.exit(shutdownReceived ? 0 : 1);
        });
      }
      const logger = factories && factories.console ? new (factories.console(RemoteConsoleImpl))() : new RemoteConsoleImpl();
      const connection = vscode_languageserver_protocol_1.createProtocolConnection(input, output, logger, strategy);
      logger.rawAttach(connection);
      const tracer = factories && factories.tracer ? new (factories.tracer(TracerImpl))() : new TracerImpl();
      const telemetry = factories && factories.telemetry ? new (factories.telemetry(TelemetryImpl))() : new TelemetryImpl();
      const client = factories && factories.client ? new (factories.client(RemoteClientImpl))() : new RemoteClientImpl();
      const remoteWindow = factories && factories.window ? new (factories.window(RemoteWindowImpl))() : new RemoteWindowImpl();
      const workspace = factories && factories.workspace ? new (factories.workspace(RemoteWorkspaceImpl))() : new RemoteWorkspaceImpl();
      const languages = factories && factories.languages ? new (factories.languages(LanguagesImpl))() : new LanguagesImpl();
      const allRemotes = [logger, tracer, telemetry, client, remoteWindow, workspace, languages];
      function asPromise(value) {
        if (value instanceof Promise) {
          return value;
        } else if (Is.thenable(value)) {
          return new Promise((resolve, reject) => {
            value.then((resolved) => resolve(resolved), (error) => reject(error));
          });
        } else {
          return Promise.resolve(value);
        }
      }
      let shutdownHandler = void 0;
      let initializeHandler = void 0;
      let exitHandler = void 0;
      let protocolConnection = {
        listen: () => connection.listen(),
        sendRequest: (type, ...params) => connection.sendRequest(Is.string(type) ? type : type.method, ...params),
        onRequest: (type, handler) => connection.onRequest(type, handler),
        sendNotification: (type, param) => {
          const method = Is.string(type) ? type : type.method;
          if (arguments.length === 1) {
            connection.sendNotification(method);
          } else {
            connection.sendNotification(method, param);
          }
        },
        onNotification: (type, handler) => connection.onNotification(type, handler),
        onProgress: connection.onProgress,
        sendProgress: connection.sendProgress,
        onInitialize: (handler) => initializeHandler = handler,
        onInitialized: (handler) => connection.onNotification(vscode_languageserver_protocol_1.InitializedNotification.type, handler),
        onShutdown: (handler) => shutdownHandler = handler,
        onExit: (handler) => exitHandler = handler,
        get console() {
          return logger;
        },
        get telemetry() {
          return telemetry;
        },
        get tracer() {
          return tracer;
        },
        get client() {
          return client;
        },
        get window() {
          return remoteWindow;
        },
        get workspace() {
          return workspace;
        },
        get languages() {
          return languages;
        },
        onDidChangeConfiguration: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, handler),
        onDidChangeWatchedFiles: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type, handler),
        __textDocumentSync: void 0,
        onDidOpenTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, handler),
        onDidChangeTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, handler),
        onDidCloseTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, handler),
        onWillSaveTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type, handler),
        onWillSaveTextDocumentWaitUntil: (handler) => connection.onRequest(vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type, handler),
        onDidSaveTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, handler),
        sendDiagnostics: (params) => connection.sendNotification(vscode_languageserver_protocol_1.PublishDiagnosticsNotification.type, params),
        onHover: (handler) => connection.onRequest(vscode_languageserver_protocol_1.HoverRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), void 0);
        }),
        onCompletion: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CompletionRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onCompletionResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, handler),
        onSignatureHelp: (handler) => connection.onRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), void 0);
        }),
        onDeclaration: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onDefinition: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onTypeDefinition: (handler) => connection.onRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onImplementation: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onReferences: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onDocumentHighlight: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onDocumentSymbol: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onWorkspaceSymbol: (handler) => connection.onRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onCodeAction: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onCodeLens: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onCodeLensResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onDocumentFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), void 0);
        }),
        onDocumentRangeFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), void 0);
        }),
        onDocumentOnTypeFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onRenameRequest: (handler) => connection.onRequest(vscode_languageserver_protocol_1.RenameRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), void 0);
        }),
        onPrepareRename: (handler) => connection.onRequest(vscode_languageserver_protocol_1.PrepareRenameRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onDocumentLinks: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onDocumentLinkResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onDocumentColor: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentColorRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onColorPresentation: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onFoldingRanges: (handler) => connection.onRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onSelectionRanges: (handler) => connection.onRequest(vscode_languageserver_protocol_1.SelectionRangeRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onExecuteCommand: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, (params, cancel) => {
          return handler(params, cancel, progress_1.attachWorkDone(connection, params), void 0);
        }),
        dispose: () => connection.dispose()
      };
      for (let remote of allRemotes) {
        remote.attach(protocolConnection);
      }
      connection.onRequest(vscode_languageserver_protocol_1.InitializeRequest.type, (params) => {
        const processId = params.processId;
        if (Is.number(processId) && exitTimer === void 0) {
          setInterval(() => {
            try {
              process.kill(processId, 0);
            } catch (ex) {
              process.exit(shutdownReceived ? 0 : 1);
            }
          }, 3e3);
        }
        if (Is.string(params.trace)) {
          tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.trace);
        }
        for (let remote of allRemotes) {
          remote.initialize(params.capabilities);
        }
        if (initializeHandler) {
          let result = initializeHandler(params, new vscode_languageserver_protocol_1.CancellationTokenSource().token, progress_1.attachWorkDone(connection, params), void 0);
          return asPromise(result).then((value) => {
            if (value instanceof vscode_languageserver_protocol_1.ResponseError) {
              return value;
            }
            let result2 = value;
            if (!result2) {
              result2 = { capabilities: {} };
            }
            let capabilities = result2.capabilities;
            if (!capabilities) {
              capabilities = {};
              result2.capabilities = capabilities;
            }
            if (capabilities.textDocumentSync === void 0 || capabilities.textDocumentSync === null) {
              capabilities.textDocumentSync = Is.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
            } else if (!Is.number(capabilities.textDocumentSync) && !Is.number(capabilities.textDocumentSync.change)) {
              capabilities.textDocumentSync.change = Is.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
            }
            for (let remote of allRemotes) {
              remote.fillServerCapabilities(capabilities);
            }
            return result2;
          });
        } else {
          let result = { capabilities: { textDocumentSync: vscode_languageserver_protocol_1.TextDocumentSyncKind.None } };
          for (let remote of allRemotes) {
            remote.fillServerCapabilities(result.capabilities);
          }
          return result;
        }
      });
      connection.onRequest(vscode_languageserver_protocol_1.ShutdownRequest.type, () => {
        shutdownReceived = true;
        if (shutdownHandler) {
          return shutdownHandler(new vscode_languageserver_protocol_1.CancellationTokenSource().token);
        } else {
          return void 0;
        }
      });
      connection.onNotification(vscode_languageserver_protocol_1.ExitNotification.type, () => {
        try {
          if (exitHandler) {
            exitHandler();
          }
        } finally {
          if (shutdownReceived) {
            process.exit(0);
          } else {
            process.exit(1);
          }
        }
      });
      connection.onNotification(vscode_languageserver_protocol_1.SetTraceNotification.type, (params) => {
        tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.value);
      });
      return protocolConnection;
    }
    var callHierarchy_proposed_1 = require_callHierarchy_proposed();
    var st = require_sematicTokens_proposed();
    var ProposedFeatures;
    (function(ProposedFeatures2) {
      ProposedFeatures2.all = {
        __brand: "features",
        languages: combineLanguagesFeatures(callHierarchy_proposed_1.CallHierarchyFeature, st.SemanticTokensFeature)
      };
      ProposedFeatures2.SemanticTokensBuilder = st.SemanticTokensBuilder;
    })(ProposedFeatures = exports.ProposedFeatures || (exports.ProposedFeatures = {}));
  }
});

// node_modules/@sqltools/base-driver/dist/lib/exception/response-error.js
var require_response_error = __commonJS({
  "node_modules/@sqltools/base-driver/dist/lib/exception/response-error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NotifyResponseError = void 0;
    var vscode_languageserver_1 = require_main4();
    var NotifyResponseError = class extends vscode_languageserver_1.ResponseError {
      constructor(code, message, data) {
        super(code, message, data);
      }
    };
    exports.NotifyResponseError = NotifyResponseError;
    exports.default = NotifyResponseError;
  }
});

// node_modules/@sqltools/base-driver/dist/lib/notification.js
var require_notification = __commonJS({
  "node_modules/@sqltools/base-driver/dist/lib/notification.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MissingModuleNotification = exports.ElectronNotSupportedNotification = void 0;
    exports.ElectronNotSupportedNotification = "Core/electronNotSupported";
    exports.MissingModuleNotification = "Core/missingModule";
  }
});

// node_modules/@sqltools/base-driver/dist/lib/exception/electron-not-supported.js
var require_electron_not_supported = __commonJS({
  "node_modules/@sqltools/base-driver/dist/lib/exception/electron-not-supported.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ElectronNotSupportedError = void 0;
    var response_error_1 = __importDefault(require_response_error());
    var notification_1 = require_notification();
    var ElectronNotSupportedError = class extends response_error_1.default {
      constructor(message = `Electron is not supported. You should enable 'sqltools.useNodeRuntime' and have NodeJS installed to continue.`) {
        super(1001, message, {
          notification: notification_1.ElectronNotSupportedNotification,
          dontNotify: true
        });
      }
    };
    exports.ElectronNotSupportedError = ElectronNotSupportedError;
    exports.default = ElectronNotSupportedError;
  }
});

// node_modules/@sqltools/base-driver/dist/lib/exception/missing-module.js
var require_missing_module = __commonJS({
  "node_modules/@sqltools/base-driver/dist/lib/exception/missing-module.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MissingModuleError = void 0;
    var response_error_1 = __importDefault(require_response_error());
    var notification_1 = require_notification();
    var MissingModuleError = class extends response_error_1.default {
      constructor(deps, conn, mustUpgrade = false) {
        super(1e3, `Missing module "${deps.map((d, i) => `${d.name}@${d.version || "latest"}${i === deps.length - 2 ? " and " : i === deps.length - 1 ? "" : ", "}`).join("")}". Need to ${mustUpgrade ? "upgrade" : "install"}.`, {
          notification: notification_1.MissingModuleNotification,
          dontNotify: true,
          args: {
            conn,
            action: mustUpgrade ? "upgrade" : "install",
            deps
          }
        });
      }
    };
    exports.MissingModuleError = MissingModuleError;
    exports.default = MissingModuleError;
  }
});

// node_modules/env-paths/index.js
var require_env_paths = __commonJS({
  "node_modules/env-paths/index.js"(exports, module2) {
    "use strict";
    var path = require("path");
    var os = require("os");
    var homedir = os.homedir();
    var tmpdir = os.tmpdir();
    var { env } = process;
    var macos = (name) => {
      const library = path.join(homedir, "Library");
      return {
        data: path.join(library, "Application Support", name),
        config: path.join(library, "Preferences", name),
        cache: path.join(library, "Caches", name),
        log: path.join(library, "Logs", name),
        temp: path.join(tmpdir, name)
      };
    };
    var windows = (name) => {
      const appData = env.APPDATA || path.join(homedir, "AppData", "Roaming");
      const localAppData = env.LOCALAPPDATA || path.join(homedir, "AppData", "Local");
      return {
        data: path.join(localAppData, name, "Data"),
        config: path.join(appData, name, "Config"),
        cache: path.join(localAppData, name, "Cache"),
        log: path.join(localAppData, name, "Log"),
        temp: path.join(tmpdir, name)
      };
    };
    var linux = (name) => {
      const username = path.basename(homedir);
      return {
        data: path.join(env.XDG_DATA_HOME || path.join(homedir, ".local", "share"), name),
        config: path.join(env.XDG_CONFIG_HOME || path.join(homedir, ".config"), name),
        cache: path.join(env.XDG_CACHE_HOME || path.join(homedir, ".cache"), name),
        log: path.join(env.XDG_STATE_HOME || path.join(homedir, ".local", "state"), name),
        temp: path.join(tmpdir, username, name)
      };
    };
    var envPaths = (name, options) => {
      if (typeof name !== "string") {
        throw new TypeError(`Expected string, got ${typeof name}`);
      }
      options = Object.assign({ suffix: "nodejs" }, options);
      if (options.suffix) {
        name += `-${options.suffix}`;
      }
      if (process.platform === "darwin") {
        return macos(name);
      }
      if (process.platform === "win32") {
        return windows(name);
      }
      return linux(name);
    };
    module2.exports = envPaths;
    module2.exports.default = envPaths;
  }
});

// node_modules/resolve/lib/homedir.js
var require_homedir = __commonJS({
  "node_modules/resolve/lib/homedir.js"(exports, module2) {
    "use strict";
    var os = require("os");
    module2.exports = os.homedir || function homedir() {
      var home = process.env.HOME;
      var user = process.env.LOGNAME || process.env.USER || process.env.LNAME || process.env.USERNAME;
      if (process.platform === "win32") {
        return process.env.USERPROFILE || process.env.HOMEDRIVE + process.env.HOMEPATH || home || null;
      }
      if (process.platform === "darwin") {
        return home || (user ? "/Users/" + user : null);
      }
      if (process.platform === "linux") {
        return home || (process.getuid() === 0 ? "/root" : user ? "/home/" + user : null);
      }
      return home || null;
    };
  }
});

// node_modules/resolve/lib/caller.js
var require_caller = __commonJS({
  "node_modules/resolve/lib/caller.js"(exports, module2) {
    module2.exports = function() {
      var origPrepareStackTrace = Error.prepareStackTrace;
      Error.prepareStackTrace = function(_, stack2) {
        return stack2;
      };
      var stack = new Error().stack;
      Error.prepareStackTrace = origPrepareStackTrace;
      return stack[2].getFileName();
    };
  }
});

// node_modules/path-parse/index.js
var require_path_parse = __commonJS({
  "node_modules/path-parse/index.js"(exports, module2) {
    "use strict";
    var isWindows = process.platform === "win32";
    var splitWindowsRe = /^(((?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?[\\\/]?)(?:[^\\\/]*[\\\/])*)((\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))[\\\/]*$/;
    var win32 = {};
    function win32SplitPath(filename) {
      return splitWindowsRe.exec(filename).slice(1);
    }
    win32.parse = function(pathString) {
      if (typeof pathString !== "string") {
        throw new TypeError(
          "Parameter 'pathString' must be a string, not " + typeof pathString
        );
      }
      var allParts = win32SplitPath(pathString);
      if (!allParts || allParts.length !== 5) {
        throw new TypeError("Invalid path '" + pathString + "'");
      }
      return {
        root: allParts[1],
        dir: allParts[0] === allParts[1] ? allParts[0] : allParts[0].slice(0, -1),
        base: allParts[2],
        ext: allParts[4],
        name: allParts[3]
      };
    };
    var splitPathRe = /^((\/?)(?:[^\/]*\/)*)((\.{1,2}|[^\/]+?|)(\.[^.\/]*|))[\/]*$/;
    var posix = {};
    function posixSplitPath(filename) {
      return splitPathRe.exec(filename).slice(1);
    }
    posix.parse = function(pathString) {
      if (typeof pathString !== "string") {
        throw new TypeError(
          "Parameter 'pathString' must be a string, not " + typeof pathString
        );
      }
      var allParts = posixSplitPath(pathString);
      if (!allParts || allParts.length !== 5) {
        throw new TypeError("Invalid path '" + pathString + "'");
      }
      return {
        root: allParts[1],
        dir: allParts[0].slice(0, -1),
        base: allParts[2],
        ext: allParts[4],
        name: allParts[3]
      };
    };
    if (isWindows)
      module2.exports = win32.parse;
    else
      module2.exports = posix.parse;
    module2.exports.posix = posix.parse;
    module2.exports.win32 = win32.parse;
  }
});

// node_modules/resolve/lib/node-modules-paths.js
var require_node_modules_paths = __commonJS({
  "node_modules/resolve/lib/node-modules-paths.js"(exports, module2) {
    var path = require("path");
    var parse = path.parse || require_path_parse();
    var getNodeModulesDirs = function getNodeModulesDirs2(absoluteStart, modules) {
      var prefix = "/";
      if (/^([A-Za-z]:)/.test(absoluteStart)) {
        prefix = "";
      } else if (/^\\\\/.test(absoluteStart)) {
        prefix = "\\\\";
      }
      var paths = [absoluteStart];
      var parsed = parse(absoluteStart);
      while (parsed.dir !== paths[paths.length - 1]) {
        paths.push(parsed.dir);
        parsed = parse(parsed.dir);
      }
      return paths.reduce(function(dirs, aPath) {
        return dirs.concat(modules.map(function(moduleDir) {
          return path.resolve(prefix, aPath, moduleDir);
        }));
      }, []);
    };
    module2.exports = function nodeModulesPaths(start, opts, request) {
      var modules = opts && opts.moduleDirectory ? [].concat(opts.moduleDirectory) : ["node_modules"];
      if (opts && typeof opts.paths === "function") {
        return opts.paths(
          request,
          start,
          function() {
            return getNodeModulesDirs(start, modules);
          },
          opts
        );
      }
      var dirs = getNodeModulesDirs(start, modules);
      return opts && opts.paths ? dirs.concat(opts.paths) : dirs;
    };
  }
});

// node_modules/resolve/lib/normalize-options.js
var require_normalize_options = __commonJS({
  "node_modules/resolve/lib/normalize-options.js"(exports, module2) {
    module2.exports = function(x, opts) {
      return opts || {};
    };
  }
});

// node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "node_modules/function-bind/implementation.js"(exports, module2) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max = Math.max;
    var funcType = "[object Function]";
    var concatty = function concatty2(a, b) {
      var arr = [];
      for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
      }
      for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
      }
      return arr;
    };
    var slicy = function slicy2(arrLike, offset) {
      var arr = [];
      for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
      }
      return arr;
    };
    var joiny = function(arr, joiner) {
      var str = "";
      for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
          str += joiner;
        }
      }
      return str;
    };
    module2.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            concatty(args, arguments)
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        }
        return target.apply(
          that,
          concatty(args, arguments)
        );
      };
      var boundLength = max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = "$" + i;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/function-bind/index.js"(exports, module2) {
    "use strict";
    var implementation = require_implementation();
    module2.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/hasown/index.js
var require_hasown = __commonJS({
  "node_modules/hasown/index.js"(exports, module2) {
    "use strict";
    var call = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind = require_function_bind();
    module2.exports = bind.call(call, $hasOwn);
  }
});

// node_modules/is-core-module/core.json
var require_core = __commonJS({
  "node_modules/is-core-module/core.json"(exports, module2) {
    module2.exports = {
      assert: true,
      "node:assert": [">= 14.18 && < 15", ">= 16"],
      "assert/strict": ">= 15",
      "node:assert/strict": ">= 16",
      async_hooks: ">= 8",
      "node:async_hooks": [">= 14.18 && < 15", ">= 16"],
      buffer_ieee754: ">= 0.5 && < 0.9.7",
      buffer: true,
      "node:buffer": [">= 14.18 && < 15", ">= 16"],
      child_process: true,
      "node:child_process": [">= 14.18 && < 15", ">= 16"],
      cluster: ">= 0.5",
      "node:cluster": [">= 14.18 && < 15", ">= 16"],
      console: true,
      "node:console": [">= 14.18 && < 15", ">= 16"],
      constants: true,
      "node:constants": [">= 14.18 && < 15", ">= 16"],
      crypto: true,
      "node:crypto": [">= 14.18 && < 15", ">= 16"],
      _debug_agent: ">= 1 && < 8",
      _debugger: "< 8",
      dgram: true,
      "node:dgram": [">= 14.18 && < 15", ">= 16"],
      diagnostics_channel: [">= 14.17 && < 15", ">= 15.1"],
      "node:diagnostics_channel": [">= 14.18 && < 15", ">= 16"],
      dns: true,
      "node:dns": [">= 14.18 && < 15", ">= 16"],
      "dns/promises": ">= 15",
      "node:dns/promises": ">= 16",
      domain: ">= 0.7.12",
      "node:domain": [">= 14.18 && < 15", ">= 16"],
      events: true,
      "node:events": [">= 14.18 && < 15", ">= 16"],
      freelist: "< 6",
      fs: true,
      "node:fs": [">= 14.18 && < 15", ">= 16"],
      "fs/promises": [">= 10 && < 10.1", ">= 14"],
      "node:fs/promises": [">= 14.18 && < 15", ">= 16"],
      _http_agent: ">= 0.11.1",
      "node:_http_agent": [">= 14.18 && < 15", ">= 16"],
      _http_client: ">= 0.11.1",
      "node:_http_client": [">= 14.18 && < 15", ">= 16"],
      _http_common: ">= 0.11.1",
      "node:_http_common": [">= 14.18 && < 15", ">= 16"],
      _http_incoming: ">= 0.11.1",
      "node:_http_incoming": [">= 14.18 && < 15", ">= 16"],
      _http_outgoing: ">= 0.11.1",
      "node:_http_outgoing": [">= 14.18 && < 15", ">= 16"],
      _http_server: ">= 0.11.1",
      "node:_http_server": [">= 14.18 && < 15", ">= 16"],
      http: true,
      "node:http": [">= 14.18 && < 15", ">= 16"],
      http2: ">= 8.8",
      "node:http2": [">= 14.18 && < 15", ">= 16"],
      https: true,
      "node:https": [">= 14.18 && < 15", ">= 16"],
      inspector: ">= 8",
      "node:inspector": [">= 14.18 && < 15", ">= 16"],
      "inspector/promises": [">= 19"],
      "node:inspector/promises": [">= 19"],
      _linklist: "< 8",
      module: true,
      "node:module": [">= 14.18 && < 15", ">= 16"],
      net: true,
      "node:net": [">= 14.18 && < 15", ">= 16"],
      "node-inspect/lib/_inspect": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_client": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_repl": ">= 7.6 && < 12",
      os: true,
      "node:os": [">= 14.18 && < 15", ">= 16"],
      path: true,
      "node:path": [">= 14.18 && < 15", ">= 16"],
      "path/posix": ">= 15.3",
      "node:path/posix": ">= 16",
      "path/win32": ">= 15.3",
      "node:path/win32": ">= 16",
      perf_hooks: ">= 8.5",
      "node:perf_hooks": [">= 14.18 && < 15", ">= 16"],
      process: ">= 1",
      "node:process": [">= 14.18 && < 15", ">= 16"],
      punycode: ">= 0.5",
      "node:punycode": [">= 14.18 && < 15", ">= 16"],
      querystring: true,
      "node:querystring": [">= 14.18 && < 15", ">= 16"],
      readline: true,
      "node:readline": [">= 14.18 && < 15", ">= 16"],
      "readline/promises": ">= 17",
      "node:readline/promises": ">= 17",
      repl: true,
      "node:repl": [">= 14.18 && < 15", ">= 16"],
      smalloc: ">= 0.11.5 && < 3",
      _stream_duplex: ">= 0.9.4",
      "node:_stream_duplex": [">= 14.18 && < 15", ">= 16"],
      _stream_transform: ">= 0.9.4",
      "node:_stream_transform": [">= 14.18 && < 15", ">= 16"],
      _stream_wrap: ">= 1.4.1",
      "node:_stream_wrap": [">= 14.18 && < 15", ">= 16"],
      _stream_passthrough: ">= 0.9.4",
      "node:_stream_passthrough": [">= 14.18 && < 15", ">= 16"],
      _stream_readable: ">= 0.9.4",
      "node:_stream_readable": [">= 14.18 && < 15", ">= 16"],
      _stream_writable: ">= 0.9.4",
      "node:_stream_writable": [">= 14.18 && < 15", ">= 16"],
      stream: true,
      "node:stream": [">= 14.18 && < 15", ">= 16"],
      "stream/consumers": ">= 16.7",
      "node:stream/consumers": ">= 16.7",
      "stream/promises": ">= 15",
      "node:stream/promises": ">= 16",
      "stream/web": ">= 16.5",
      "node:stream/web": ">= 16.5",
      string_decoder: true,
      "node:string_decoder": [">= 14.18 && < 15", ">= 16"],
      sys: [">= 0.4 && < 0.7", ">= 0.8"],
      "node:sys": [">= 14.18 && < 15", ">= 16"],
      "test/reporters": ">= 19.9 && < 20.2",
      "node:test/reporters": [">= 18.17 && < 19", ">= 19.9", ">= 20"],
      "node:test": [">= 16.17 && < 17", ">= 18"],
      timers: true,
      "node:timers": [">= 14.18 && < 15", ">= 16"],
      "timers/promises": ">= 15",
      "node:timers/promises": ">= 16",
      _tls_common: ">= 0.11.13",
      "node:_tls_common": [">= 14.18 && < 15", ">= 16"],
      _tls_legacy: ">= 0.11.3 && < 10",
      _tls_wrap: ">= 0.11.3",
      "node:_tls_wrap": [">= 14.18 && < 15", ">= 16"],
      tls: true,
      "node:tls": [">= 14.18 && < 15", ">= 16"],
      trace_events: ">= 10",
      "node:trace_events": [">= 14.18 && < 15", ">= 16"],
      tty: true,
      "node:tty": [">= 14.18 && < 15", ">= 16"],
      url: true,
      "node:url": [">= 14.18 && < 15", ">= 16"],
      util: true,
      "node:util": [">= 14.18 && < 15", ">= 16"],
      "util/types": ">= 15.3",
      "node:util/types": ">= 16",
      "v8/tools/arguments": ">= 10 && < 12",
      "v8/tools/codemap": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/consarray": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/csvparser": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/logreader": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/profile_view": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/splaytree": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      v8: ">= 1",
      "node:v8": [">= 14.18 && < 15", ">= 16"],
      vm: true,
      "node:vm": [">= 14.18 && < 15", ">= 16"],
      wasi: [">= 13.4 && < 13.5", ">= 18.17 && < 19", ">= 20"],
      "node:wasi": [">= 18.17 && < 19", ">= 20"],
      worker_threads: ">= 11.7",
      "node:worker_threads": [">= 14.18 && < 15", ">= 16"],
      zlib: ">= 0.5",
      "node:zlib": [">= 14.18 && < 15", ">= 16"]
    };
  }
});

// node_modules/is-core-module/index.js
var require_is_core_module = __commonJS({
  "node_modules/is-core-module/index.js"(exports, module2) {
    "use strict";
    var hasOwn = require_hasown();
    function specifierIncluded(current, specifier) {
      var nodeParts = current.split(".");
      var parts = specifier.split(" ");
      var op = parts.length > 1 ? parts[0] : "=";
      var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split(".");
      for (var i = 0; i < 3; ++i) {
        var cur = parseInt(nodeParts[i] || 0, 10);
        var ver = parseInt(versionParts[i] || 0, 10);
        if (cur === ver) {
          continue;
        }
        if (op === "<") {
          return cur < ver;
        }
        if (op === ">=") {
          return cur >= ver;
        }
        return false;
      }
      return op === ">=";
    }
    function matchesRange(current, range) {
      var specifiers = range.split(/ ?&& ?/);
      if (specifiers.length === 0) {
        return false;
      }
      for (var i = 0; i < specifiers.length; ++i) {
        if (!specifierIncluded(current, specifiers[i])) {
          return false;
        }
      }
      return true;
    }
    function versionIncluded(nodeVersion, specifierValue) {
      if (typeof specifierValue === "boolean") {
        return specifierValue;
      }
      var current = typeof nodeVersion === "undefined" ? process.versions && process.versions.node : nodeVersion;
      if (typeof current !== "string") {
        throw new TypeError(typeof nodeVersion === "undefined" ? "Unable to determine current node version" : "If provided, a valid node version is required");
      }
      if (specifierValue && typeof specifierValue === "object") {
        for (var i = 0; i < specifierValue.length; ++i) {
          if (matchesRange(current, specifierValue[i])) {
            return true;
          }
        }
        return false;
      }
      return matchesRange(current, specifierValue);
    }
    var data = require_core();
    module2.exports = function isCore(x, nodeVersion) {
      return hasOwn(data, x) && versionIncluded(nodeVersion, data[x]);
    };
  }
});

// node_modules/resolve/lib/async.js
var require_async = __commonJS({
  "node_modules/resolve/lib/async.js"(exports, module2) {
    var fs = require("fs");
    var getHomedir = require_homedir();
    var path = require("path");
    var caller = require_caller();
    var nodeModulesPaths = require_node_modules_paths();
    var normalizeOptions = require_normalize_options();
    var isCore = require_is_core_module();
    var realpathFS = process.platform !== "win32" && fs.realpath && typeof fs.realpath.native === "function" ? fs.realpath.native : fs.realpath;
    var homedir = getHomedir();
    var defaultPaths = function() {
      return [
        path.join(homedir, ".node_modules"),
        path.join(homedir, ".node_libraries")
      ];
    };
    var defaultIsFile = function isFile(file, cb) {
      fs.stat(file, function(err, stat) {
        if (!err) {
          return cb(null, stat.isFile() || stat.isFIFO());
        }
        if (err.code === "ENOENT" || err.code === "ENOTDIR")
          return cb(null, false);
        return cb(err);
      });
    };
    var defaultIsDir = function isDirectory(dir, cb) {
      fs.stat(dir, function(err, stat) {
        if (!err) {
          return cb(null, stat.isDirectory());
        }
        if (err.code === "ENOENT" || err.code === "ENOTDIR")
          return cb(null, false);
        return cb(err);
      });
    };
    var defaultRealpath = function realpath(x, cb) {
      realpathFS(x, function(realpathErr, realPath) {
        if (realpathErr && realpathErr.code !== "ENOENT")
          cb(realpathErr);
        else
          cb(null, realpathErr ? x : realPath);
      });
    };
    var maybeRealpath = function maybeRealpath2(realpath, x, opts, cb) {
      if (opts && opts.preserveSymlinks === false) {
        realpath(x, cb);
      } else {
        cb(null, x);
      }
    };
    var defaultReadPackage = function defaultReadPackage2(readFile, pkgfile, cb) {
      readFile(pkgfile, function(readFileErr, body) {
        if (readFileErr)
          cb(readFileErr);
        else {
          try {
            var pkg = JSON.parse(body);
            cb(null, pkg);
          } catch (jsonErr) {
            cb(null);
          }
        }
      });
    };
    var getPackageCandidates = function getPackageCandidates2(x, start, opts) {
      var dirs = nodeModulesPaths(start, opts, x);
      for (var i = 0; i < dirs.length; i++) {
        dirs[i] = path.join(dirs[i], x);
      }
      return dirs;
    };
    module2.exports = function resolve(x, options, callback) {
      var cb = callback;
      var opts = options;
      if (typeof options === "function") {
        cb = opts;
        opts = {};
      }
      if (typeof x !== "string") {
        var err = new TypeError("Path must be a string.");
        return process.nextTick(function() {
          cb(err);
        });
      }
      opts = normalizeOptions(x, opts);
      var isFile = opts.isFile || defaultIsFile;
      var isDirectory = opts.isDirectory || defaultIsDir;
      var readFile = opts.readFile || fs.readFile;
      var realpath = opts.realpath || defaultRealpath;
      var readPackage = opts.readPackage || defaultReadPackage;
      if (opts.readFile && opts.readPackage) {
        var conflictErr = new TypeError("`readFile` and `readPackage` are mutually exclusive.");
        return process.nextTick(function() {
          cb(conflictErr);
        });
      }
      var packageIterator = opts.packageIterator;
      var extensions = opts.extensions || [".js"];
      var includeCoreModules = opts.includeCoreModules !== false;
      var basedir = opts.basedir || path.dirname(caller());
      var parent = opts.filename || basedir;
      opts.paths = opts.paths || defaultPaths();
      var absoluteStart = path.resolve(basedir);
      maybeRealpath(
        realpath,
        absoluteStart,
        opts,
        function(err2, realStart) {
          if (err2)
            cb(err2);
          else
            init(realStart);
        }
      );
      var res;
      function init(basedir2) {
        if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) {
          res = path.resolve(basedir2, x);
          if (x === "." || x === ".." || x.slice(-1) === "/")
            res += "/";
          if (/\/$/.test(x) && res === basedir2) {
            loadAsDirectory(res, opts.package, onfile);
          } else
            loadAsFile(res, opts.package, onfile);
        } else if (includeCoreModules && isCore(x)) {
          return cb(null, x);
        } else
          loadNodeModules(x, basedir2, function(err2, n, pkg) {
            if (err2)
              cb(err2);
            else if (n) {
              return maybeRealpath(realpath, n, opts, function(err3, realN) {
                if (err3) {
                  cb(err3);
                } else {
                  cb(null, realN, pkg);
                }
              });
            } else {
              var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
              moduleError.code = "MODULE_NOT_FOUND";
              cb(moduleError);
            }
          });
      }
      function onfile(err2, m, pkg) {
        if (err2)
          cb(err2);
        else if (m)
          cb(null, m, pkg);
        else
          loadAsDirectory(res, function(err3, d, pkg2) {
            if (err3)
              cb(err3);
            else if (d) {
              maybeRealpath(realpath, d, opts, function(err4, realD) {
                if (err4) {
                  cb(err4);
                } else {
                  cb(null, realD, pkg2);
                }
              });
            } else {
              var moduleError = new Error("Cannot find module '" + x + "' from '" + parent + "'");
              moduleError.code = "MODULE_NOT_FOUND";
              cb(moduleError);
            }
          });
      }
      function loadAsFile(x2, thePackage, callback2) {
        var loadAsFilePackage = thePackage;
        var cb2 = callback2;
        if (typeof loadAsFilePackage === "function") {
          cb2 = loadAsFilePackage;
          loadAsFilePackage = void 0;
        }
        var exts = [""].concat(extensions);
        load(exts, x2, loadAsFilePackage);
        function load(exts2, x3, loadPackage) {
          if (exts2.length === 0)
            return cb2(null, void 0, loadPackage);
          var file = x3 + exts2[0];
          var pkg = loadPackage;
          if (pkg)
            onpkg(null, pkg);
          else
            loadpkg(path.dirname(file), onpkg);
          function onpkg(err2, pkg_, dir) {
            pkg = pkg_;
            if (err2)
              return cb2(err2);
            if (dir && pkg && opts.pathFilter) {
              var rfile = path.relative(dir, file);
              var rel = rfile.slice(0, rfile.length - exts2[0].length);
              var r = opts.pathFilter(pkg, x3, rel);
              if (r)
                return load(
                  [""].concat(extensions.slice()),
                  path.resolve(dir, r),
                  pkg
                );
            }
            isFile(file, onex);
          }
          function onex(err2, ex) {
            if (err2)
              return cb2(err2);
            if (ex)
              return cb2(null, file, pkg);
            load(exts2.slice(1), x3, pkg);
          }
        }
      }
      function loadpkg(dir, cb2) {
        if (dir === "" || dir === "/")
          return cb2(null);
        if (process.platform === "win32" && /^\w:[/\\]*$/.test(dir)) {
          return cb2(null);
        }
        if (/[/\\]node_modules[/\\]*$/.test(dir))
          return cb2(null);
        maybeRealpath(realpath, dir, opts, function(unwrapErr, pkgdir) {
          if (unwrapErr)
            return loadpkg(path.dirname(dir), cb2);
          var pkgfile = path.join(pkgdir, "package.json");
          isFile(pkgfile, function(err2, ex) {
            if (!ex)
              return loadpkg(path.dirname(dir), cb2);
            readPackage(readFile, pkgfile, function(err3, pkgParam) {
              if (err3)
                cb2(err3);
              var pkg = pkgParam;
              if (pkg && opts.packageFilter) {
                pkg = opts.packageFilter(pkg, pkgfile);
              }
              cb2(null, pkg, dir);
            });
          });
        });
      }
      function loadAsDirectory(x2, loadAsDirectoryPackage, callback2) {
        var cb2 = callback2;
        var fpkg = loadAsDirectoryPackage;
        if (typeof fpkg === "function") {
          cb2 = fpkg;
          fpkg = opts.package;
        }
        maybeRealpath(realpath, x2, opts, function(unwrapErr, pkgdir) {
          if (unwrapErr)
            return cb2(unwrapErr);
          var pkgfile = path.join(pkgdir, "package.json");
          isFile(pkgfile, function(err2, ex) {
            if (err2)
              return cb2(err2);
            if (!ex)
              return loadAsFile(path.join(x2, "index"), fpkg, cb2);
            readPackage(readFile, pkgfile, function(err3, pkgParam) {
              if (err3)
                return cb2(err3);
              var pkg = pkgParam;
              if (pkg && opts.packageFilter) {
                pkg = opts.packageFilter(pkg, pkgfile);
              }
              if (pkg && pkg.main) {
                if (typeof pkg.main !== "string") {
                  var mainError = new TypeError("package \u201C" + pkg.name + "\u201D `main` must be a string");
                  mainError.code = "INVALID_PACKAGE_MAIN";
                  return cb2(mainError);
                }
                if (pkg.main === "." || pkg.main === "./") {
                  pkg.main = "index";
                }
                loadAsFile(path.resolve(x2, pkg.main), pkg, function(err4, m, pkg2) {
                  if (err4)
                    return cb2(err4);
                  if (m)
                    return cb2(null, m, pkg2);
                  if (!pkg2)
                    return loadAsFile(path.join(x2, "index"), pkg2, cb2);
                  var dir = path.resolve(x2, pkg2.main);
                  loadAsDirectory(dir, pkg2, function(err5, n, pkg3) {
                    if (err5)
                      return cb2(err5);
                    if (n)
                      return cb2(null, n, pkg3);
                    loadAsFile(path.join(x2, "index"), pkg3, cb2);
                  });
                });
                return;
              }
              loadAsFile(path.join(x2, "/index"), pkg, cb2);
            });
          });
        });
      }
      function processDirs(cb2, dirs) {
        if (dirs.length === 0)
          return cb2(null, void 0);
        var dir = dirs[0];
        isDirectory(path.dirname(dir), isdir);
        function isdir(err2, isdir2) {
          if (err2)
            return cb2(err2);
          if (!isdir2)
            return processDirs(cb2, dirs.slice(1));
          loadAsFile(dir, opts.package, onfile2);
        }
        function onfile2(err2, m, pkg) {
          if (err2)
            return cb2(err2);
          if (m)
            return cb2(null, m, pkg);
          loadAsDirectory(dir, opts.package, ondir);
        }
        function ondir(err2, n, pkg) {
          if (err2)
            return cb2(err2);
          if (n)
            return cb2(null, n, pkg);
          processDirs(cb2, dirs.slice(1));
        }
      }
      function loadNodeModules(x2, start, cb2) {
        var thunk = function() {
          return getPackageCandidates(x2, start, opts);
        };
        processDirs(
          cb2,
          packageIterator ? packageIterator(x2, start, thunk, opts) : thunk()
        );
      }
    };
  }
});

// node_modules/resolve/lib/core.json
var require_core2 = __commonJS({
  "node_modules/resolve/lib/core.json"(exports, module2) {
    module2.exports = {
      assert: true,
      "node:assert": [">= 14.18 && < 15", ">= 16"],
      "assert/strict": ">= 15",
      "node:assert/strict": ">= 16",
      async_hooks: ">= 8",
      "node:async_hooks": [">= 14.18 && < 15", ">= 16"],
      buffer_ieee754: ">= 0.5 && < 0.9.7",
      buffer: true,
      "node:buffer": [">= 14.18 && < 15", ">= 16"],
      child_process: true,
      "node:child_process": [">= 14.18 && < 15", ">= 16"],
      cluster: ">= 0.5",
      "node:cluster": [">= 14.18 && < 15", ">= 16"],
      console: true,
      "node:console": [">= 14.18 && < 15", ">= 16"],
      constants: true,
      "node:constants": [">= 14.18 && < 15", ">= 16"],
      crypto: true,
      "node:crypto": [">= 14.18 && < 15", ">= 16"],
      _debug_agent: ">= 1 && < 8",
      _debugger: "< 8",
      dgram: true,
      "node:dgram": [">= 14.18 && < 15", ">= 16"],
      diagnostics_channel: [">= 14.17 && < 15", ">= 15.1"],
      "node:diagnostics_channel": [">= 14.18 && < 15", ">= 16"],
      dns: true,
      "node:dns": [">= 14.18 && < 15", ">= 16"],
      "dns/promises": ">= 15",
      "node:dns/promises": ">= 16",
      domain: ">= 0.7.12",
      "node:domain": [">= 14.18 && < 15", ">= 16"],
      events: true,
      "node:events": [">= 14.18 && < 15", ">= 16"],
      freelist: "< 6",
      fs: true,
      "node:fs": [">= 14.18 && < 15", ">= 16"],
      "fs/promises": [">= 10 && < 10.1", ">= 14"],
      "node:fs/promises": [">= 14.18 && < 15", ">= 16"],
      _http_agent: ">= 0.11.1",
      "node:_http_agent": [">= 14.18 && < 15", ">= 16"],
      _http_client: ">= 0.11.1",
      "node:_http_client": [">= 14.18 && < 15", ">= 16"],
      _http_common: ">= 0.11.1",
      "node:_http_common": [">= 14.18 && < 15", ">= 16"],
      _http_incoming: ">= 0.11.1",
      "node:_http_incoming": [">= 14.18 && < 15", ">= 16"],
      _http_outgoing: ">= 0.11.1",
      "node:_http_outgoing": [">= 14.18 && < 15", ">= 16"],
      _http_server: ">= 0.11.1",
      "node:_http_server": [">= 14.18 && < 15", ">= 16"],
      http: true,
      "node:http": [">= 14.18 && < 15", ">= 16"],
      http2: ">= 8.8",
      "node:http2": [">= 14.18 && < 15", ">= 16"],
      https: true,
      "node:https": [">= 14.18 && < 15", ">= 16"],
      inspector: ">= 8",
      "node:inspector": [">= 14.18 && < 15", ">= 16"],
      "inspector/promises": [">= 19"],
      "node:inspector/promises": [">= 19"],
      _linklist: "< 8",
      module: true,
      "node:module": [">= 14.18 && < 15", ">= 16"],
      net: true,
      "node:net": [">= 14.18 && < 15", ">= 16"],
      "node-inspect/lib/_inspect": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_client": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_repl": ">= 7.6 && < 12",
      os: true,
      "node:os": [">= 14.18 && < 15", ">= 16"],
      path: true,
      "node:path": [">= 14.18 && < 15", ">= 16"],
      "path/posix": ">= 15.3",
      "node:path/posix": ">= 16",
      "path/win32": ">= 15.3",
      "node:path/win32": ">= 16",
      perf_hooks: ">= 8.5",
      "node:perf_hooks": [">= 14.18 && < 15", ">= 16"],
      process: ">= 1",
      "node:process": [">= 14.18 && < 15", ">= 16"],
      punycode: ">= 0.5",
      "node:punycode": [">= 14.18 && < 15", ">= 16"],
      querystring: true,
      "node:querystring": [">= 14.18 && < 15", ">= 16"],
      readline: true,
      "node:readline": [">= 14.18 && < 15", ">= 16"],
      "readline/promises": ">= 17",
      "node:readline/promises": ">= 17",
      repl: true,
      "node:repl": [">= 14.18 && < 15", ">= 16"],
      smalloc: ">= 0.11.5 && < 3",
      _stream_duplex: ">= 0.9.4",
      "node:_stream_duplex": [">= 14.18 && < 15", ">= 16"],
      _stream_transform: ">= 0.9.4",
      "node:_stream_transform": [">= 14.18 && < 15", ">= 16"],
      _stream_wrap: ">= 1.4.1",
      "node:_stream_wrap": [">= 14.18 && < 15", ">= 16"],
      _stream_passthrough: ">= 0.9.4",
      "node:_stream_passthrough": [">= 14.18 && < 15", ">= 16"],
      _stream_readable: ">= 0.9.4",
      "node:_stream_readable": [">= 14.18 && < 15", ">= 16"],
      _stream_writable: ">= 0.9.4",
      "node:_stream_writable": [">= 14.18 && < 15", ">= 16"],
      stream: true,
      "node:stream": [">= 14.18 && < 15", ">= 16"],
      "stream/consumers": ">= 16.7",
      "node:stream/consumers": ">= 16.7",
      "stream/promises": ">= 15",
      "node:stream/promises": ">= 16",
      "stream/web": ">= 16.5",
      "node:stream/web": ">= 16.5",
      string_decoder: true,
      "node:string_decoder": [">= 14.18 && < 15", ">= 16"],
      sys: [">= 0.4 && < 0.7", ">= 0.8"],
      "node:sys": [">= 14.18 && < 15", ">= 16"],
      "test/reporters": ">= 19.9 && < 20.2",
      "node:test/reporters": [">= 18.17 && < 19", ">= 19.9", ">= 20"],
      "node:test": [">= 16.17 && < 17", ">= 18"],
      timers: true,
      "node:timers": [">= 14.18 && < 15", ">= 16"],
      "timers/promises": ">= 15",
      "node:timers/promises": ">= 16",
      _tls_common: ">= 0.11.13",
      "node:_tls_common": [">= 14.18 && < 15", ">= 16"],
      _tls_legacy: ">= 0.11.3 && < 10",
      _tls_wrap: ">= 0.11.3",
      "node:_tls_wrap": [">= 14.18 && < 15", ">= 16"],
      tls: true,
      "node:tls": [">= 14.18 && < 15", ">= 16"],
      trace_events: ">= 10",
      "node:trace_events": [">= 14.18 && < 15", ">= 16"],
      tty: true,
      "node:tty": [">= 14.18 && < 15", ">= 16"],
      url: true,
      "node:url": [">= 14.18 && < 15", ">= 16"],
      util: true,
      "node:util": [">= 14.18 && < 15", ">= 16"],
      "util/types": ">= 15.3",
      "node:util/types": ">= 16",
      "v8/tools/arguments": ">= 10 && < 12",
      "v8/tools/codemap": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/consarray": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/csvparser": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/logreader": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/profile_view": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/splaytree": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      v8: ">= 1",
      "node:v8": [">= 14.18 && < 15", ">= 16"],
      vm: true,
      "node:vm": [">= 14.18 && < 15", ">= 16"],
      wasi: [">= 13.4 && < 13.5", ">= 18.17 && < 19", ">= 20"],
      "node:wasi": [">= 18.17 && < 19", ">= 20"],
      worker_threads: ">= 11.7",
      "node:worker_threads": [">= 14.18 && < 15", ">= 16"],
      zlib: ">= 0.5",
      "node:zlib": [">= 14.18 && < 15", ">= 16"]
    };
  }
});

// node_modules/resolve/lib/core.js
var require_core3 = __commonJS({
  "node_modules/resolve/lib/core.js"(exports, module2) {
    "use strict";
    var isCoreModule = require_is_core_module();
    var data = require_core2();
    var core = {};
    for (mod in data) {
      if (Object.prototype.hasOwnProperty.call(data, mod)) {
        core[mod] = isCoreModule(mod);
      }
    }
    var mod;
    module2.exports = core;
  }
});

// node_modules/resolve/lib/is-core.js
var require_is_core = __commonJS({
  "node_modules/resolve/lib/is-core.js"(exports, module2) {
    var isCoreModule = require_is_core_module();
    module2.exports = function isCore(x) {
      return isCoreModule(x);
    };
  }
});

// node_modules/resolve/lib/sync.js
var require_sync = __commonJS({
  "node_modules/resolve/lib/sync.js"(exports, module2) {
    var isCore = require_is_core_module();
    var fs = require("fs");
    var path = require("path");
    var getHomedir = require_homedir();
    var caller = require_caller();
    var nodeModulesPaths = require_node_modules_paths();
    var normalizeOptions = require_normalize_options();
    var realpathFS = process.platform !== "win32" && fs.realpathSync && typeof fs.realpathSync.native === "function" ? fs.realpathSync.native : fs.realpathSync;
    var homedir = getHomedir();
    var defaultPaths = function() {
      return [
        path.join(homedir, ".node_modules"),
        path.join(homedir, ".node_libraries")
      ];
    };
    var defaultIsFile = function isFile(file) {
      try {
        var stat = fs.statSync(file, { throwIfNoEntry: false });
      } catch (e) {
        if (e && (e.code === "ENOENT" || e.code === "ENOTDIR"))
          return false;
        throw e;
      }
      return !!stat && (stat.isFile() || stat.isFIFO());
    };
    var defaultIsDir = function isDirectory(dir) {
      try {
        var stat = fs.statSync(dir, { throwIfNoEntry: false });
      } catch (e) {
        if (e && (e.code === "ENOENT" || e.code === "ENOTDIR"))
          return false;
        throw e;
      }
      return !!stat && stat.isDirectory();
    };
    var defaultRealpathSync = function realpathSync(x) {
      try {
        return realpathFS(x);
      } catch (realpathErr) {
        if (realpathErr.code !== "ENOENT") {
          throw realpathErr;
        }
      }
      return x;
    };
    var maybeRealpathSync = function maybeRealpathSync2(realpathSync, x, opts) {
      if (opts && opts.preserveSymlinks === false) {
        return realpathSync(x);
      }
      return x;
    };
    var defaultReadPackageSync = function defaultReadPackageSync2(readFileSync, pkgfile) {
      var body = readFileSync(pkgfile);
      try {
        var pkg = JSON.parse(body);
        return pkg;
      } catch (jsonErr) {
      }
    };
    var getPackageCandidates = function getPackageCandidates2(x, start, opts) {
      var dirs = nodeModulesPaths(start, opts, x);
      for (var i = 0; i < dirs.length; i++) {
        dirs[i] = path.join(dirs[i], x);
      }
      return dirs;
    };
    module2.exports = function resolveSync(x, options) {
      if (typeof x !== "string") {
        throw new TypeError("Path must be a string.");
      }
      var opts = normalizeOptions(x, options);
      var isFile = opts.isFile || defaultIsFile;
      var readFileSync = opts.readFileSync || fs.readFileSync;
      var isDirectory = opts.isDirectory || defaultIsDir;
      var realpathSync = opts.realpathSync || defaultRealpathSync;
      var readPackageSync = opts.readPackageSync || defaultReadPackageSync;
      if (opts.readFileSync && opts.readPackageSync) {
        throw new TypeError("`readFileSync` and `readPackageSync` are mutually exclusive.");
      }
      var packageIterator = opts.packageIterator;
      var extensions = opts.extensions || [".js"];
      var includeCoreModules = opts.includeCoreModules !== false;
      var basedir = opts.basedir || path.dirname(caller());
      var parent = opts.filename || basedir;
      opts.paths = opts.paths || defaultPaths();
      var absoluteStart = maybeRealpathSync(realpathSync, path.resolve(basedir), opts);
      if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) {
        var res = path.resolve(absoluteStart, x);
        if (x === "." || x === ".." || x.slice(-1) === "/")
          res += "/";
        var m = loadAsFileSync(res) || loadAsDirectorySync(res);
        if (m)
          return maybeRealpathSync(realpathSync, m, opts);
      } else if (includeCoreModules && isCore(x)) {
        return x;
      } else {
        var n = loadNodeModulesSync(x, absoluteStart);
        if (n)
          return maybeRealpathSync(realpathSync, n, opts);
      }
      var err = new Error("Cannot find module '" + x + "' from '" + parent + "'");
      err.code = "MODULE_NOT_FOUND";
      throw err;
      function loadAsFileSync(x2) {
        var pkg = loadpkg(path.dirname(x2));
        if (pkg && pkg.dir && pkg.pkg && opts.pathFilter) {
          var rfile = path.relative(pkg.dir, x2);
          var r = opts.pathFilter(pkg.pkg, x2, rfile);
          if (r) {
            x2 = path.resolve(pkg.dir, r);
          }
        }
        if (isFile(x2)) {
          return x2;
        }
        for (var i = 0; i < extensions.length; i++) {
          var file = x2 + extensions[i];
          if (isFile(file)) {
            return file;
          }
        }
      }
      function loadpkg(dir) {
        if (dir === "" || dir === "/")
          return;
        if (process.platform === "win32" && /^\w:[/\\]*$/.test(dir)) {
          return;
        }
        if (/[/\\]node_modules[/\\]*$/.test(dir))
          return;
        var pkgfile = path.join(maybeRealpathSync(realpathSync, dir, opts), "package.json");
        if (!isFile(pkgfile)) {
          return loadpkg(path.dirname(dir));
        }
        var pkg = readPackageSync(readFileSync, pkgfile);
        if (pkg && opts.packageFilter) {
          pkg = opts.packageFilter(pkg, dir);
        }
        return { pkg, dir };
      }
      function loadAsDirectorySync(x2) {
        var pkgfile = path.join(maybeRealpathSync(realpathSync, x2, opts), "/package.json");
        if (isFile(pkgfile)) {
          try {
            var pkg = readPackageSync(readFileSync, pkgfile);
          } catch (e) {
          }
          if (pkg && opts.packageFilter) {
            pkg = opts.packageFilter(pkg, x2);
          }
          if (pkg && pkg.main) {
            if (typeof pkg.main !== "string") {
              var mainError = new TypeError("package \u201C" + pkg.name + "\u201D `main` must be a string");
              mainError.code = "INVALID_PACKAGE_MAIN";
              throw mainError;
            }
            if (pkg.main === "." || pkg.main === "./") {
              pkg.main = "index";
            }
            try {
              var m2 = loadAsFileSync(path.resolve(x2, pkg.main));
              if (m2)
                return m2;
              var n2 = loadAsDirectorySync(path.resolve(x2, pkg.main));
              if (n2)
                return n2;
            } catch (e) {
            }
          }
        }
        return loadAsFileSync(path.join(x2, "/index"));
      }
      function loadNodeModulesSync(x2, start) {
        var thunk = function() {
          return getPackageCandidates(x2, start, opts);
        };
        var dirs = packageIterator ? packageIterator(x2, start, thunk, opts) : thunk();
        for (var i = 0; i < dirs.length; i++) {
          var dir = dirs[i];
          if (isDirectory(path.dirname(dir))) {
            var m2 = loadAsFileSync(dir);
            if (m2)
              return m2;
            var n2 = loadAsDirectorySync(dir);
            if (n2)
              return n2;
          }
        }
      }
    };
  }
});

// node_modules/resolve/index.js
var require_resolve = __commonJS({
  "node_modules/resolve/index.js"(exports, module2) {
    var async = require_async();
    async.core = require_core3();
    async.isCore = require_is_core();
    async.sync = require_sync();
    module2.exports = async;
  }
});

// node_modules/semver/semver.js
var require_semver = __commonJS({
  "node_modules/semver/semver.js"(exports, module2) {
    exports = module2.exports = SemVer;
    var debug;
    if (typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
      debug = function() {
        var args = Array.prototype.slice.call(arguments, 0);
        args.unshift("SEMVER");
        console.log.apply(console, args);
      };
    } else {
      debug = function() {
      };
    }
    exports.SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var re = exports.re = [];
    var safeRe = exports.safeRe = [];
    var src = exports.src = [];
    var t = exports.tokens = {};
    var R = 0;
    function tok(n) {
      t[n] = R++;
    }
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    function makeSafeRe(value) {
      for (var i2 = 0; i2 < safeRegexReplacements.length; i2++) {
        var token = safeRegexReplacements[i2][0];
        var max = safeRegexReplacements[i2][1];
        value = value.split(token + "*").join(token + "{0," + max + "}").split(token + "+").join(token + "{1," + max + "}");
      }
      return value;
    }
    tok("NUMERICIDENTIFIER");
    src[t.NUMERICIDENTIFIER] = "0|[1-9]\\d*";
    tok("NUMERICIDENTIFIERLOOSE");
    src[t.NUMERICIDENTIFIERLOOSE] = "\\d+";
    tok("NONNUMERICIDENTIFIER");
    src[t.NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-]" + LETTERDASHNUMBER + "*";
    tok("MAINVERSION");
    src[t.MAINVERSION] = "(" + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ")";
    tok("MAINVERSIONLOOSE");
    src[t.MAINVERSIONLOOSE] = "(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ")";
    tok("PRERELEASEIDENTIFIER");
    src[t.PRERELEASEIDENTIFIER] = "(?:" + src[t.NUMERICIDENTIFIER] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
    tok("PRERELEASEIDENTIFIERLOOSE");
    src[t.PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[t.NUMERICIDENTIFIERLOOSE] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
    tok("PRERELEASE");
    src[t.PRERELEASE] = "(?:-(" + src[t.PRERELEASEIDENTIFIER] + "(?:\\." + src[t.PRERELEASEIDENTIFIER] + ")*))";
    tok("PRERELEASELOOSE");
    src[t.PRERELEASELOOSE] = "(?:-?(" + src[t.PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[t.PRERELEASEIDENTIFIERLOOSE] + ")*))";
    tok("BUILDIDENTIFIER");
    src[t.BUILDIDENTIFIER] = LETTERDASHNUMBER + "+";
    tok("BUILD");
    src[t.BUILD] = "(?:\\+(" + src[t.BUILDIDENTIFIER] + "(?:\\." + src[t.BUILDIDENTIFIER] + ")*))";
    tok("FULL");
    tok("FULLPLAIN");
    src[t.FULLPLAIN] = "v?" + src[t.MAINVERSION] + src[t.PRERELEASE] + "?" + src[t.BUILD] + "?";
    src[t.FULL] = "^" + src[t.FULLPLAIN] + "$";
    tok("LOOSEPLAIN");
    src[t.LOOSEPLAIN] = "[v=\\s]*" + src[t.MAINVERSIONLOOSE] + src[t.PRERELEASELOOSE] + "?" + src[t.BUILD] + "?";
    tok("LOOSE");
    src[t.LOOSE] = "^" + src[t.LOOSEPLAIN] + "$";
    tok("GTLT");
    src[t.GTLT] = "((?:<|>)?=?)";
    tok("XRANGEIDENTIFIERLOOSE");
    src[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
    tok("XRANGEIDENTIFIER");
    src[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + "|x|X|\\*";
    tok("XRANGEPLAIN");
    src[t.XRANGEPLAIN] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:" + src[t.PRERELEASE] + ")?" + src[t.BUILD] + "?)?)?";
    tok("XRANGEPLAINLOOSE");
    src[t.XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:" + src[t.PRERELEASELOOSE] + ")?" + src[t.BUILD] + "?)?)?";
    tok("XRANGE");
    src[t.XRANGE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAIN] + "$";
    tok("XRANGELOOSE");
    src[t.XRANGELOOSE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAINLOOSE] + "$";
    tok("COERCE");
    src[t.COERCE] = "(^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
    tok("COERCERTL");
    re[t.COERCERTL] = new RegExp(src[t.COERCE], "g");
    safeRe[t.COERCERTL] = new RegExp(makeSafeRe(src[t.COERCE]), "g");
    tok("LONETILDE");
    src[t.LONETILDE] = "(?:~>?)";
    tok("TILDETRIM");
    src[t.TILDETRIM] = "(\\s*)" + src[t.LONETILDE] + "\\s+";
    re[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], "g");
    safeRe[t.TILDETRIM] = new RegExp(makeSafeRe(src[t.TILDETRIM]), "g");
    var tildeTrimReplace = "$1~";
    tok("TILDE");
    src[t.TILDE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAIN] + "$";
    tok("TILDELOOSE");
    src[t.TILDELOOSE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + "$";
    tok("LONECARET");
    src[t.LONECARET] = "(?:\\^)";
    tok("CARETTRIM");
    src[t.CARETTRIM] = "(\\s*)" + src[t.LONECARET] + "\\s+";
    re[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], "g");
    safeRe[t.CARETTRIM] = new RegExp(makeSafeRe(src[t.CARETTRIM]), "g");
    var caretTrimReplace = "$1^";
    tok("CARET");
    src[t.CARET] = "^" + src[t.LONECARET] + src[t.XRANGEPLAIN] + "$";
    tok("CARETLOOSE");
    src[t.CARETLOOSE] = "^" + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + "$";
    tok("COMPARATORLOOSE");
    src[t.COMPARATORLOOSE] = "^" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + ")$|^$";
    tok("COMPARATOR");
    src[t.COMPARATOR] = "^" + src[t.GTLT] + "\\s*(" + src[t.FULLPLAIN] + ")$|^$";
    tok("COMPARATORTRIM");
    src[t.COMPARATORTRIM] = "(\\s*)" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + "|" + src[t.XRANGEPLAIN] + ")";
    re[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], "g");
    safeRe[t.COMPARATORTRIM] = new RegExp(makeSafeRe(src[t.COMPARATORTRIM]), "g");
    var comparatorTrimReplace = "$1$2$3";
    tok("HYPHENRANGE");
    src[t.HYPHENRANGE] = "^\\s*(" + src[t.XRANGEPLAIN] + ")\\s+-\\s+(" + src[t.XRANGEPLAIN] + ")\\s*$";
    tok("HYPHENRANGELOOSE");
    src[t.HYPHENRANGELOOSE] = "^\\s*(" + src[t.XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[t.XRANGEPLAINLOOSE] + ")\\s*$";
    tok("STAR");
    src[t.STAR] = "(<|>)?=?\\s*\\*";
    for (i = 0; i < R; i++) {
      debug(i, src[i]);
      if (!re[i]) {
        re[i] = new RegExp(src[i]);
        safeRe[i] = new RegExp(makeSafeRe(src[i]));
      }
    }
    var i;
    exports.parse = parse;
    function parse(version, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version !== "string") {
        return null;
      }
      if (version.length > MAX_LENGTH) {
        return null;
      }
      var r = options.loose ? safeRe[t.LOOSE] : safeRe[t.FULL];
      if (!r.test(version)) {
        return null;
      }
      try {
        return new SemVer(version, options);
      } catch (er) {
        return null;
      }
    }
    exports.valid = valid;
    function valid(version, options) {
      var v = parse(version, options);
      return v ? v.version : null;
    }
    exports.clean = clean;
    function clean(version, options) {
      var s = parse(version.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    }
    exports.SemVer = SemVer;
    function SemVer(version, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (version instanceof SemVer) {
        if (version.loose === options.loose) {
          return version;
        } else {
          version = version.version;
        }
      } else if (typeof version !== "string") {
        throw new TypeError("Invalid Version: " + version);
      }
      if (version.length > MAX_LENGTH) {
        throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
      }
      if (!(this instanceof SemVer)) {
        return new SemVer(version, options);
      }
      debug("SemVer", version, options);
      this.options = options;
      this.loose = !!options.loose;
      var m = version.trim().match(options.loose ? safeRe[t.LOOSE] : safeRe[t.FULL]);
      if (!m) {
        throw new TypeError("Invalid Version: " + version);
      }
      this.raw = version;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split(".").map(function(id) {
          if (/^[0-9]+$/.test(id)) {
            var num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }
          return id;
        });
      }
      this.build = m[5] ? m[5].split(".") : [];
      this.format();
    }
    SemVer.prototype.format = function() {
      this.version = this.major + "." + this.minor + "." + this.patch;
      if (this.prerelease.length) {
        this.version += "-" + this.prerelease.join(".");
      }
      return this.version;
    };
    SemVer.prototype.toString = function() {
      return this.version;
    };
    SemVer.prototype.compare = function(other) {
      debug("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return this.compareMain(other) || this.comparePre(other);
    };
    SemVer.prototype.compareMain = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    };
    SemVer.prototype.comparePre = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      var i2 = 0;
      do {
        var a = this.prerelease[i2];
        var b = other.prerelease[i2];
        debug("prerelease compare", i2, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i2);
    };
    SemVer.prototype.compareBuild = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      var i2 = 0;
      do {
        var a = this.build[i2];
        var b = other.build[i2];
        debug("prerelease compare", i2, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i2);
    };
    SemVer.prototype.inc = function(release, identifier) {
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier);
          this.inc("pre", identifier);
          break;
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier);
          }
          this.inc("pre", identifier);
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        case "pre":
          if (this.prerelease.length === 0) {
            this.prerelease = [0];
          } else {
            var i2 = this.prerelease.length;
            while (--i2 >= 0) {
              if (typeof this.prerelease[i2] === "number") {
                this.prerelease[i2]++;
                i2 = -2;
              }
            }
            if (i2 === -1) {
              this.prerelease.push(0);
            }
          }
          if (identifier) {
            if (this.prerelease[0] === identifier) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = [identifier, 0];
              }
            } else {
              this.prerelease = [identifier, 0];
            }
          }
          break;
        default:
          throw new Error("invalid increment argument: " + release);
      }
      this.format();
      this.raw = this.version;
      return this;
    };
    exports.inc = inc;
    function inc(version, release, loose, identifier) {
      if (typeof loose === "string") {
        identifier = loose;
        loose = void 0;
      }
      try {
        return new SemVer(version, loose).inc(release, identifier).version;
      } catch (er) {
        return null;
      }
    }
    exports.diff = diff;
    function diff(version1, version2) {
      if (eq(version1, version2)) {
        return null;
      } else {
        var v1 = parse(version1);
        var v2 = parse(version2);
        var prefix = "";
        if (v1.prerelease.length || v2.prerelease.length) {
          prefix = "pre";
          var defaultResult = "prerelease";
        }
        for (var key in v1) {
          if (key === "major" || key === "minor" || key === "patch") {
            if (v1[key] !== v2[key]) {
              return prefix + key;
            }
          }
        }
        return defaultResult;
      }
    }
    exports.compareIdentifiers = compareIdentifiers;
    var numeric = /^[0-9]+$/;
    function compareIdentifiers(a, b) {
      var anum = numeric.test(a);
      var bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    }
    exports.rcompareIdentifiers = rcompareIdentifiers;
    function rcompareIdentifiers(a, b) {
      return compareIdentifiers(b, a);
    }
    exports.major = major;
    function major(a, loose) {
      return new SemVer(a, loose).major;
    }
    exports.minor = minor;
    function minor(a, loose) {
      return new SemVer(a, loose).minor;
    }
    exports.patch = patch;
    function patch(a, loose) {
      return new SemVer(a, loose).patch;
    }
    exports.compare = compare;
    function compare(a, b, loose) {
      return new SemVer(a, loose).compare(new SemVer(b, loose));
    }
    exports.compareLoose = compareLoose;
    function compareLoose(a, b) {
      return compare(a, b, true);
    }
    exports.compareBuild = compareBuild;
    function compareBuild(a, b, loose) {
      var versionA = new SemVer(a, loose);
      var versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    }
    exports.rcompare = rcompare;
    function rcompare(a, b, loose) {
      return compare(b, a, loose);
    }
    exports.sort = sort;
    function sort(list, loose) {
      return list.sort(function(a, b) {
        return exports.compareBuild(a, b, loose);
      });
    }
    exports.rsort = rsort;
    function rsort(list, loose) {
      return list.sort(function(a, b) {
        return exports.compareBuild(b, a, loose);
      });
    }
    exports.gt = gt;
    function gt(a, b, loose) {
      return compare(a, b, loose) > 0;
    }
    exports.lt = lt;
    function lt(a, b, loose) {
      return compare(a, b, loose) < 0;
    }
    exports.eq = eq;
    function eq(a, b, loose) {
      return compare(a, b, loose) === 0;
    }
    exports.neq = neq;
    function neq(a, b, loose) {
      return compare(a, b, loose) !== 0;
    }
    exports.gte = gte;
    function gte(a, b, loose) {
      return compare(a, b, loose) >= 0;
    }
    exports.lte = lte;
    function lte(a, b, loose) {
      return compare(a, b, loose) <= 0;
    }
    exports.cmp = cmp;
    function cmp(a, op, b, loose) {
      switch (op) {
        case "===":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a === b;
        case "!==":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError("Invalid operator: " + op);
      }
    }
    exports.Comparator = Comparator;
    function Comparator(comp, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      if (!(this instanceof Comparator)) {
        return new Comparator(comp, options);
      }
      comp = comp.trim().split(/\s+/).join(" ");
      debug("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug("comp", this);
    }
    var ANY = {};
    Comparator.prototype.parse = function(comp) {
      var r = this.options.loose ? safeRe[t.COMPARATORLOOSE] : safeRe[t.COMPARATOR];
      var m = comp.match(r);
      if (!m) {
        throw new TypeError("Invalid comparator: " + comp);
      }
      this.operator = m[1] !== void 0 ? m[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m[2], this.options.loose);
      }
    };
    Comparator.prototype.toString = function() {
      return this.value;
    };
    Comparator.prototype.test = function(version) {
      debug("Comparator.test", version, this.options.loose);
      if (this.semver === ANY || version === ANY) {
        return true;
      }
      if (typeof version === "string") {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp(version, this.operator, this.semver, this.options);
    };
    Comparator.prototype.intersects = function(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      var rangeTmp;
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        rangeTmp = new Range(comp.value, options);
        return satisfies(this.value, rangeTmp, options);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        rangeTmp = new Range(this.value, options);
        return satisfies(comp.semver, rangeTmp, options);
      }
      var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
      var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
      var sameSemVer = this.semver.version === comp.semver.version;
      var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
      var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
      var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
      return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
    };
    exports.Range = Range;
    function Range(range, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (range instanceof Range) {
        if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
          return range;
        } else {
          return new Range(range.raw, options);
        }
      }
      if (range instanceof Comparator) {
        return new Range(range.value, options);
      }
      if (!(this instanceof Range)) {
        return new Range(range, options);
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range.trim().split(/\s+/).join(" ");
      this.set = this.raw.split("||").map(function(range2) {
        return this.parseRange(range2.trim());
      }, this).filter(function(c) {
        return c.length;
      });
      if (!this.set.length) {
        throw new TypeError("Invalid SemVer Range: " + this.raw);
      }
      this.format();
    }
    Range.prototype.format = function() {
      this.range = this.set.map(function(comps) {
        return comps.join(" ").trim();
      }).join("||").trim();
      return this.range;
    };
    Range.prototype.toString = function() {
      return this.range;
    };
    Range.prototype.parseRange = function(range) {
      var loose = this.options.loose;
      var hr = loose ? safeRe[t.HYPHENRANGELOOSE] : safeRe[t.HYPHENRANGE];
      range = range.replace(hr, hyphenReplace);
      debug("hyphen replace", range);
      range = range.replace(safeRe[t.COMPARATORTRIM], comparatorTrimReplace);
      debug("comparator trim", range, safeRe[t.COMPARATORTRIM]);
      range = range.replace(safeRe[t.TILDETRIM], tildeTrimReplace);
      range = range.replace(safeRe[t.CARETTRIM], caretTrimReplace);
      range = range.split(/\s+/).join(" ");
      var compRe = loose ? safeRe[t.COMPARATORLOOSE] : safeRe[t.COMPARATOR];
      var set = range.split(" ").map(function(comp) {
        return parseComparator(comp, this.options);
      }, this).join(" ").split(/\s+/);
      if (this.options.loose) {
        set = set.filter(function(comp) {
          return !!comp.match(compRe);
        });
      }
      set = set.map(function(comp) {
        return new Comparator(comp, this.options);
      }, this);
      return set;
    };
    Range.prototype.intersects = function(range, options) {
      if (!(range instanceof Range)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some(function(thisComparators) {
        return isSatisfiable(thisComparators, options) && range.set.some(function(rangeComparators) {
          return isSatisfiable(rangeComparators, options) && thisComparators.every(function(thisComparator) {
            return rangeComparators.every(function(rangeComparator) {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    };
    function isSatisfiable(comparators, options) {
      var result = true;
      var remainingComparators = comparators.slice();
      var testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every(function(otherComparator) {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    }
    exports.toComparators = toComparators;
    function toComparators(range, options) {
      return new Range(range, options).set.map(function(comp) {
        return comp.map(function(c) {
          return c.value;
        }).join(" ").trim().split(" ");
      });
    }
    function parseComparator(comp, options) {
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    }
    function isX(id) {
      return !id || id.toLowerCase() === "x" || id === "*";
    }
    function replaceTildes(comp, options) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceTilde(comp2, options);
      }).join(" ");
    }
    function replaceTilde(comp, options) {
      var r = options.loose ? safeRe[t.TILDELOOSE] : safeRe[t.TILDE];
      return comp.replace(r, function(_, M, m, p, pr) {
        debug("tilde", comp, _, M, m, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
        } else {
          ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
        }
        debug("tilde return", ret);
        return ret;
      });
    }
    function replaceCarets(comp, options) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceCaret(comp2, options);
      }).join(" ");
    }
    function replaceCaret(comp, options) {
      debug("caret", comp, options);
      var r = options.loose ? safeRe[t.CARETLOOSE] : safeRe[t.CARET];
      return comp.replace(r, function(_, M, m, p, pr) {
        debug("caret", comp, _, M, m, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          if (M === "0") {
            ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
          } else {
            ret = ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0";
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0";
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0";
          }
        }
        debug("caret return", ret);
        return ret;
      });
    }
    function replaceXRanges(comp, options) {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map(function(comp2) {
        return replaceXRange(comp2, options);
      }).join(" ");
    }
    function replaceXRange(comp, options) {
      comp = comp.trim();
      var r = options.loose ? safeRe[t.XRANGELOOSE] : safeRe[t.XRANGE];
      return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        var xM = isX(M);
        var xm = xM || isX(m);
        var xp = xm || isX(p);
        var anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          ret = gtlt + M + "." + m + "." + p + pr;
        } else if (xm) {
          ret = ">=" + M + ".0.0" + pr + " <" + (+M + 1) + ".0.0" + pr;
        } else if (xp) {
          ret = ">=" + M + "." + m + ".0" + pr + " <" + M + "." + (+m + 1) + ".0" + pr;
        }
        debug("xRange return", ret);
        return ret;
      });
    }
    function replaceStars(comp, options) {
      debug("replaceStars", comp, options);
      return comp.trim().replace(safeRe[t.STAR], "");
    }
    function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = ">=" + fM + ".0.0";
      } else if (isX(fp)) {
        from = ">=" + fM + "." + fm + ".0";
      } else {
        from = ">=" + from;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = "<" + (+tM + 1) + ".0.0";
      } else if (isX(tp)) {
        to = "<" + tM + "." + (+tm + 1) + ".0";
      } else if (tpr) {
        to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
      } else {
        to = "<=" + to;
      }
      return (from + " " + to).trim();
    }
    Range.prototype.test = function(version) {
      if (!version) {
        return false;
      }
      if (typeof version === "string") {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }
      for (var i2 = 0; i2 < this.set.length; i2++) {
        if (testSet(this.set[i2], version, this.options)) {
          return true;
        }
      }
      return false;
    };
    function testSet(set, version, options) {
      for (var i2 = 0; i2 < set.length; i2++) {
        if (!set[i2].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options.includePrerelease) {
        for (i2 = 0; i2 < set.length; i2++) {
          debug(set[i2].semver);
          if (set[i2].semver === ANY) {
            continue;
          }
          if (set[i2].semver.prerelease.length > 0) {
            var allowed = set[i2].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    }
    exports.satisfies = satisfies;
    function satisfies(version, range, options) {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version);
    }
    exports.maxSatisfying = maxSatisfying;
    function maxSatisfying(versions, range, options) {
      var max = null;
      var maxSV = null;
      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    }
    exports.minSatisfying = minSatisfying;
    function minSatisfying(versions, range, options) {
      var min = null;
      var minSV = null;
      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    }
    exports.minVersion = minVersion;
    function minVersion(range, loose) {
      range = new Range(range, loose);
      var minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2];
        comparators.forEach(function(comparator) {
          var compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!minver || gt(minver, compver)) {
                minver = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error("Unexpected operation: " + comparator.operator);
          }
        });
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    }
    exports.validRange = validRange;
    function validRange(range, options) {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    }
    exports.ltr = ltr;
    function ltr(version, range, options) {
      return outside(version, range, "<", options);
    }
    exports.gtr = gtr;
    function gtr(version, range, options) {
      return outside(version, range, ">", options);
    }
    exports.outside = outside;
    function outside(version, range, hilo, options) {
      version = new SemVer(version, options);
      range = new Range(range, options);
      var gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version, range, options)) {
        return false;
      }
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2];
        var high = null;
        var low = null;
        comparators.forEach(function(comparator) {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    }
    exports.prerelease = prerelease;
    function prerelease(version, options) {
      var parsed = parse(version, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    }
    exports.intersects = intersects;
    function intersects(r1, r2, options) {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2);
    }
    exports.coerce = coerce;
    function coerce(version, options) {
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version === "number") {
        version = String(version);
      }
      if (typeof version !== "string") {
        return null;
      }
      options = options || {};
      var match = null;
      if (!options.rtl) {
        match = version.match(safeRe[t.COERCE]);
      } else {
        var next;
        while ((next = safeRe[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          safeRe[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
        }
        safeRe[t.COERCERTL].lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      return parse(match[2] + "." + (match[3] || "0") + "." + (match[4] || "0"), options);
    }
  }
});

// node_modules/make-dir/index.js
var require_make_dir = __commonJS({
  "node_modules/make-dir/index.js"(exports, module2) {
    "use strict";
    var fs = require("fs");
    var path = require("path");
    var { promisify } = require("util");
    var semver = require_semver();
    var useNativeRecursiveOption = semver.satisfies(process.version, ">=10.12.0");
    var checkPath = (pth) => {
      if (process.platform === "win32") {
        const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path.parse(pth).root, ""));
        if (pathHasInvalidWinCharacters) {
          const error = new Error(`Path contains invalid characters: ${pth}`);
          error.code = "EINVAL";
          throw error;
        }
      }
    };
    var processOptions = (options) => {
      const defaults = {
        mode: 511,
        fs
      };
      return {
        ...defaults,
        ...options
      };
    };
    var permissionError = (pth) => {
      const error = new Error(`operation not permitted, mkdir '${pth}'`);
      error.code = "EPERM";
      error.errno = -4048;
      error.path = pth;
      error.syscall = "mkdir";
      return error;
    };
    var makeDir = async (input, options) => {
      checkPath(input);
      options = processOptions(options);
      const mkdir = promisify(options.fs.mkdir);
      const stat = promisify(options.fs.stat);
      if (useNativeRecursiveOption && options.fs.mkdir === fs.mkdir) {
        const pth = path.resolve(input);
        await mkdir(pth, {
          mode: options.mode,
          recursive: true
        });
        return pth;
      }
      const make = async (pth) => {
        try {
          await mkdir(pth, options.mode);
          return pth;
        } catch (error) {
          if (error.code === "EPERM") {
            throw error;
          }
          if (error.code === "ENOENT") {
            if (path.dirname(pth) === pth) {
              throw permissionError(pth);
            }
            if (error.message.includes("null bytes")) {
              throw error;
            }
            await make(path.dirname(pth));
            return make(pth);
          }
          try {
            const stats = await stat(pth);
            if (!stats.isDirectory()) {
              throw new Error("The path is not a directory");
            }
          } catch (_) {
            throw error;
          }
          return pth;
        }
      };
      return make(path.resolve(input));
    };
    module2.exports = makeDir;
    module2.exports.sync = (input, options) => {
      checkPath(input);
      options = processOptions(options);
      if (useNativeRecursiveOption && options.fs.mkdirSync === fs.mkdirSync) {
        const pth = path.resolve(input);
        fs.mkdirSync(pth, {
          mode: options.mode,
          recursive: true
        });
        return pth;
      }
      const make = (pth) => {
        try {
          options.fs.mkdirSync(pth, options.mode);
        } catch (error) {
          if (error.code === "EPERM") {
            throw error;
          }
          if (error.code === "ENOENT") {
            if (path.dirname(pth) === pth) {
              throw permissionError(pth);
            }
            if (error.message.includes("null bytes")) {
              throw error;
            }
            make(path.dirname(pth));
            return make(pth);
          }
          try {
            if (!options.fs.statSync(pth).isDirectory()) {
              throw new Error("The path is not a directory");
            }
          } catch (_) {
            throw error;
          }
        }
        return pth;
      };
      return make(path.resolve(input));
    };
  }
});

// node_modules/@sqltools/base-driver/dist/lib/require.js
var require_require = __commonJS({
  "node_modules/@sqltools/base-driver/dist/lib/require.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sqltoolsResolve = void 0;
    var env_paths_1 = __importDefault(require_env_paths());
    var path_1 = __importDefault(require("path"));
    var fs_1 = __importDefault(require("fs"));
    var resolve_1 = require_resolve();
    var mkdir = __importStar(require_make_dir());
    var SQLTOOLS_PATHS = env_paths_1.default(`vscode-${process.env.EXT_NAMESPACE || "sqltools"}`, { suffix: null });
    if (!fs_1.default.existsSync(SQLTOOLS_PATHS.data)) {
      mkdir.sync(SQLTOOLS_PATHS.data);
    }
    if (!fs_1.default.existsSync(getDataPath("node_modules"))) {
      mkdir.sync(getDataPath("node_modules"));
    }
    function getDataPath(...args) {
      return path_1.default.resolve(SQLTOOLS_PATHS.data, ...args);
    }
    exports.sqltoolsResolve = (name) => resolve_1.sync(name, { basedir: getDataPath() });
    var sqltoolsRequire = (name) => require(exports.sqltoolsResolve(name));
    exports.default = sqltoolsRequire;
  }
});

// node_modules/pino-std-serializers/lib/err.js
var require_err = __commonJS({
  "node_modules/pino-std-serializers/lib/err.js"(exports, module2) {
    "use strict";
    module2.exports = errSerializer;
    var { toString } = Object.prototype;
    var seen = Symbol("circular-ref-tag");
    var rawSymbol = Symbol("pino-raw-err-ref");
    var pinoErrProto = Object.create({}, {
      type: {
        enumerable: true,
        writable: true,
        value: void 0
      },
      message: {
        enumerable: true,
        writable: true,
        value: void 0
      },
      stack: {
        enumerable: true,
        writable: true,
        value: void 0
      },
      raw: {
        enumerable: false,
        get: function() {
          return this[rawSymbol];
        },
        set: function(val) {
          this[rawSymbol] = val;
        }
      }
    });
    Object.defineProperty(pinoErrProto, rawSymbol, {
      writable: true,
      value: {}
    });
    function errSerializer(err) {
      if (!(err instanceof Error)) {
        return err;
      }
      err[seen] = void 0;
      const _err = Object.create(pinoErrProto);
      _err.type = toString.call(err.constructor) === "[object Function]" ? err.constructor.name : err.name;
      _err.message = err.message;
      _err.stack = err.stack;
      for (const key in err) {
        if (_err[key] === void 0) {
          const val = err[key];
          if (val instanceof Error) {
            if (!val.hasOwnProperty(seen)) {
              _err[key] = errSerializer(val);
            }
          } else {
            _err[key] = val;
          }
        }
      }
      delete err[seen];
      _err.raw = err;
      return _err;
    }
  }
});

// node_modules/pino-std-serializers/lib/req.js
var require_req = __commonJS({
  "node_modules/pino-std-serializers/lib/req.js"(exports, module2) {
    "use strict";
    module2.exports = {
      mapHttpRequest,
      reqSerializer
    };
    var rawSymbol = Symbol("pino-raw-req-ref");
    var pinoReqProto = Object.create({}, {
      id: {
        enumerable: true,
        writable: true,
        value: ""
      },
      method: {
        enumerable: true,
        writable: true,
        value: ""
      },
      url: {
        enumerable: true,
        writable: true,
        value: ""
      },
      query: {
        enumerable: true,
        writable: true,
        value: ""
      },
      params: {
        enumerable: true,
        writable: true,
        value: ""
      },
      headers: {
        enumerable: true,
        writable: true,
        value: {}
      },
      remoteAddress: {
        enumerable: true,
        writable: true,
        value: ""
      },
      remotePort: {
        enumerable: true,
        writable: true,
        value: ""
      },
      raw: {
        enumerable: false,
        get: function() {
          return this[rawSymbol];
        },
        set: function(val) {
          this[rawSymbol] = val;
        }
      }
    });
    Object.defineProperty(pinoReqProto, rawSymbol, {
      writable: true,
      value: {}
    });
    function reqSerializer(req) {
      const connection = req.info || req.socket;
      const _req = Object.create(pinoReqProto);
      _req.id = typeof req.id === "function" ? req.id() : req.id || (req.info ? req.info.id : void 0);
      _req.method = req.method;
      if (req.originalUrl) {
        _req.url = req.originalUrl;
        _req.query = req.query;
        _req.params = req.params;
      } else {
        _req.url = req.path || (req.url ? req.url.path || req.url : void 0);
      }
      _req.headers = req.headers;
      _req.remoteAddress = connection && connection.remoteAddress;
      _req.remotePort = connection && connection.remotePort;
      _req.raw = req.raw || req;
      return _req;
    }
    function mapHttpRequest(req) {
      return {
        req: reqSerializer(req)
      };
    }
  }
});

// node_modules/pino-std-serializers/lib/res.js
var require_res = __commonJS({
  "node_modules/pino-std-serializers/lib/res.js"(exports, module2) {
    "use strict";
    module2.exports = {
      mapHttpResponse,
      resSerializer
    };
    var rawSymbol = Symbol("pino-raw-res-ref");
    var pinoResProto = Object.create({}, {
      statusCode: {
        enumerable: true,
        writable: true,
        value: 0
      },
      headers: {
        enumerable: true,
        writable: true,
        value: ""
      },
      raw: {
        enumerable: false,
        get: function() {
          return this[rawSymbol];
        },
        set: function(val) {
          this[rawSymbol] = val;
        }
      }
    });
    Object.defineProperty(pinoResProto, rawSymbol, {
      writable: true,
      value: {}
    });
    function resSerializer(res) {
      const _res = Object.create(pinoResProto);
      _res.statusCode = res.statusCode;
      _res.headers = res.getHeaders ? res.getHeaders() : res._headers;
      _res.raw = res;
      return _res;
    }
    function mapHttpResponse(res) {
      return {
        res: resSerializer(res)
      };
    }
  }
});

// node_modules/pino-std-serializers/index.js
var require_pino_std_serializers = __commonJS({
  "node_modules/pino-std-serializers/index.js"(exports, module2) {
    "use strict";
    var errSerializer = require_err();
    var reqSerializers = require_req();
    var resSerializers = require_res();
    module2.exports = {
      err: errSerializer,
      mapHttpRequest: reqSerializers.mapHttpRequest,
      mapHttpResponse: resSerializers.mapHttpResponse,
      req: reqSerializers.reqSerializer,
      res: resSerializers.resSerializer,
      wrapErrorSerializer: function wrapErrorSerializer(customSerializer) {
        if (customSerializer === errSerializer)
          return customSerializer;
        return function wrapErrSerializer(err) {
          return customSerializer(errSerializer(err));
        };
      },
      wrapRequestSerializer: function wrapRequestSerializer(customSerializer) {
        if (customSerializer === reqSerializers.reqSerializer)
          return customSerializer;
        return function wrappedReqSerializer(req) {
          return customSerializer(reqSerializers.reqSerializer(req));
        };
      },
      wrapResponseSerializer: function wrapResponseSerializer(customSerializer) {
        if (customSerializer === resSerializers.resSerializer)
          return customSerializer;
        return function wrappedResSerializer(res) {
          return customSerializer(resSerializers.resSerializer(res));
        };
      }
    };
  }
});

// node_modules/fast-redact/lib/validator.js
var require_validator = __commonJS({
  "node_modules/fast-redact/lib/validator.js"(exports, module2) {
    "use strict";
    module2.exports = validator;
    function validator(opts = {}) {
      const {
        ERR_PATHS_MUST_BE_STRINGS = () => "fast-redact - Paths must be (non-empty) strings",
        ERR_INVALID_PATH = (s) => `fast-redact \u2013 Invalid path (${s})`
      } = opts;
      return function validate({ paths }) {
        paths.forEach((s) => {
          if (typeof s !== "string") {
            throw Error(ERR_PATHS_MUST_BE_STRINGS());
          }
          try {
            if (/„Äá/.test(s))
              throw Error();
            const expr = (s[0] === "[" ? "" : ".") + s.replace(/^\*/, "\u3007").replace(/\.\*/g, ".\u3007").replace(/\[\*\]/g, "[\u3007]");
            if (/\n|\r|;/.test(expr))
              throw Error();
            if (/\/\*/.test(expr))
              throw Error();
            Function(`
            'use strict'
            const o = new Proxy({}, { get: () => o, set: () => { throw Error() } });
            const \u3007 = null;
            o${expr}
            if ([o${expr}].length !== 1) throw Error()`)();
          } catch (e) {
            throw Error(ERR_INVALID_PATH(s));
          }
        });
      };
    }
  }
});

// node_modules/fast-redact/lib/rx.js
var require_rx = __commonJS({
  "node_modules/fast-redact/lib/rx.js"(exports, module2) {
    "use strict";
    module2.exports = /[^.[\]]+|\[((?:.)*?)\]/g;
  }
});

// node_modules/fast-redact/lib/parse.js
var require_parse2 = __commonJS({
  "node_modules/fast-redact/lib/parse.js"(exports, module2) {
    "use strict";
    var rx = require_rx();
    module2.exports = parse;
    function parse({ paths }) {
      const wildcards = [];
      var wcLen = 0;
      const secret = paths.reduce(function(o, strPath, ix) {
        var path = strPath.match(rx).map((p) => p.replace(/'|"|`/g, ""));
        const leadingBracket = strPath[0] === "[";
        path = path.map((p) => {
          if (p[0] === "[")
            return p.substr(1, p.length - 2);
          else
            return p;
        });
        const star = path.indexOf("*");
        if (star > -1) {
          const before = path.slice(0, star);
          const beforeStr = before.join(".");
          const after = path.slice(star + 1, path.length);
          const nested = after.length > 0;
          wcLen++;
          wildcards.push({
            before,
            beforeStr,
            after,
            nested
          });
        } else {
          o[strPath] = {
            path,
            val: void 0,
            precensored: false,
            circle: "",
            escPath: JSON.stringify(strPath),
            leadingBracket
          };
        }
        return o;
      }, {});
      return { wildcards, wcLen, secret };
    }
  }
});

// node_modules/fast-redact/lib/redactor.js
var require_redactor = __commonJS({
  "node_modules/fast-redact/lib/redactor.js"(exports, module2) {
    "use strict";
    var rx = require_rx();
    module2.exports = redactor;
    function redactor({ secret, serialize, wcLen, strict, isCensorFct, censorFctTakesPath }, state) {
      const redact = Function("o", `
    if (typeof o !== 'object' || o == null) {
      ${strictImpl(strict, serialize)}
    }
    const { censor, secret } = this
    ${redactTmpl(secret, isCensorFct, censorFctTakesPath)}
    this.compileRestore()
    ${dynamicRedactTmpl(wcLen > 0, isCensorFct, censorFctTakesPath)}
    ${resultTmpl(serialize)}
  `).bind(state);
      if (serialize === false) {
        redact.restore = (o) => state.restore(o);
      }
      return redact;
    }
    function redactTmpl(secret, isCensorFct, censorFctTakesPath) {
      return Object.keys(secret).map((path) => {
        const { escPath, leadingBracket, path: arrPath } = secret[path];
        const skip = leadingBracket ? 1 : 0;
        const delim = leadingBracket ? "" : ".";
        const hops = [];
        var match;
        while ((match = rx.exec(path)) !== null) {
          const [, ix] = match;
          const { index, input } = match;
          if (index > skip)
            hops.push(input.substring(0, index - (ix ? 0 : 1)));
        }
        var existence = hops.map((p) => `o${delim}${p}`).join(" && ");
        if (existence.length === 0)
          existence += `o${delim}${path} != null`;
        else
          existence += ` && o${delim}${path} != null`;
        const circularDetection = `
      switch (true) {
        ${hops.reverse().map((p) => `
          case o${delim}${p} === censor:
            secret[${escPath}].circle = ${JSON.stringify(p)}
            break
        `).join("\n")}
      }
    `;
        const censorArgs = censorFctTakesPath ? `val, ${JSON.stringify(arrPath)}` : `val`;
        return `
      if (${existence}) {
        const val = o${delim}${path}
        if (val === censor) {
          secret[${escPath}].precensored = true
        } else {
          secret[${escPath}].val = val
          o${delim}${path} = ${isCensorFct ? `censor(${censorArgs})` : "censor"}
          ${circularDetection}
        }
      }
    `;
      }).join("\n");
    }
    function dynamicRedactTmpl(hasWildcards, isCensorFct, censorFctTakesPath) {
      return hasWildcards === true ? `
    {
      const { wildcards, wcLen, groupRedact, nestedRedact } = this
      for (var i = 0; i < wcLen; i++) {
        const { before, beforeStr, after, nested } = wildcards[i]
        if (nested === true) {
          secret[beforeStr] = secret[beforeStr] || []
          nestedRedact(secret[beforeStr], o, before, after, censor, ${isCensorFct}, ${censorFctTakesPath})
        } else secret[beforeStr] = groupRedact(o, before, censor, ${isCensorFct}, ${censorFctTakesPath})
      }
    }
  ` : "";
    }
    function resultTmpl(serialize) {
      return serialize === false ? `return o` : `
    var s = this.serialize(o)
    this.restore(o)
    return s
  `;
    }
    function strictImpl(strict, serialize) {
      return strict === true ? `throw Error('fast-redact: primitives cannot be redacted')` : serialize === false ? `return o` : `return this.serialize(o)`;
    }
  }
});

// node_modules/fast-redact/lib/modifiers.js
var require_modifiers = __commonJS({
  "node_modules/fast-redact/lib/modifiers.js"(exports, module2) {
    "use strict";
    module2.exports = {
      groupRedact,
      groupRestore,
      nestedRedact,
      nestedRestore
    };
    function groupRestore({ keys, values, target }) {
      if (target == null)
        return;
      const length = keys.length;
      for (var i = 0; i < length; i++) {
        const k = keys[i];
        target[k] = values[i];
      }
    }
    function groupRedact(o, path, censor, isCensorFct, censorFctTakesPath) {
      const target = get(o, path);
      if (target == null)
        return { keys: null, values: null, target: null, flat: true };
      const keys = Object.keys(target);
      const keysLength = keys.length;
      const pathLength = path.length;
      const pathWithKey = censorFctTakesPath ? [...path] : void 0;
      const values = new Array(keysLength);
      for (var i = 0; i < keysLength; i++) {
        const key = keys[i];
        values[i] = target[key];
        if (censorFctTakesPath) {
          pathWithKey[pathLength] = key;
          target[key] = censor(target[key], pathWithKey);
        } else if (isCensorFct) {
          target[key] = censor(target[key]);
        } else {
          target[key] = censor;
        }
      }
      return { keys, values, target, flat: true };
    }
    function nestedRestore(instructions) {
      for (let i = 0; i < instructions.length; i++) {
        const { target, path, value } = instructions[i];
        let current = target;
        for (let i2 = path.length - 1; i2 > 0; i2--) {
          current = current[path[i2]];
        }
        current[path[0]] = value;
      }
    }
    function nestedRedact(store, o, path, ns, censor, isCensorFct, censorFctTakesPath) {
      const target = get(o, path);
      if (target == null)
        return;
      const keys = Object.keys(target);
      const keysLength = keys.length;
      for (var i = 0; i < keysLength; i++) {
        const key = keys[i];
        specialSet(store, target, key, path, ns, censor, isCensorFct, censorFctTakesPath);
      }
      return store;
    }
    function has(obj, prop) {
      return obj !== void 0 && obj !== null ? "hasOwn" in Object ? Object.hasOwn(obj, prop) : Object.prototype.hasOwnProperty.call(obj, prop) : false;
    }
    function specialSet(store, o, k, path, afterPath, censor, isCensorFct, censorFctTakesPath) {
      const afterPathLen = afterPath.length;
      const lastPathIndex = afterPathLen - 1;
      const originalKey = k;
      var i = -1;
      var n;
      var nv;
      var ov;
      var oov = null;
      var wc = null;
      var kIsWc;
      var wcov;
      var consecutive = false;
      var level = 0;
      var depth = 0;
      var redactPathCurrent = tree();
      ov = n = o[k];
      if (typeof n !== "object")
        return;
      while (n != null && ++i < afterPathLen) {
        depth += 1;
        k = afterPath[i];
        oov = ov;
        if (k !== "*" && !wc && !(typeof n === "object" && k in n)) {
          break;
        }
        if (k === "*") {
          if (wc === "*") {
            consecutive = true;
          }
          wc = k;
          if (i !== lastPathIndex) {
            continue;
          }
        }
        if (wc) {
          const wcKeys = Object.keys(n);
          for (var j = 0; j < wcKeys.length; j++) {
            const wck = wcKeys[j];
            wcov = n[wck];
            kIsWc = k === "*";
            if (consecutive) {
              redactPathCurrent = node(redactPathCurrent, wck, depth);
              level = i;
              ov = iterateNthLevel(wcov, level - 1, k, path, afterPath, censor, isCensorFct, censorFctTakesPath, originalKey, n, nv, ov, kIsWc, wck, i, lastPathIndex, redactPathCurrent, store, o[originalKey], depth + 1);
            } else {
              if (kIsWc || typeof wcov === "object" && wcov !== null && k in wcov) {
                if (kIsWc) {
                  ov = wcov;
                } else {
                  ov = wcov[k];
                }
                nv = i !== lastPathIndex ? ov : isCensorFct ? censorFctTakesPath ? censor(ov, [...path, originalKey, ...afterPath]) : censor(ov) : censor;
                if (kIsWc) {
                  const rv = restoreInstr(node(redactPathCurrent, wck, depth), ov, o[originalKey]);
                  store.push(rv);
                  n[wck] = nv;
                } else {
                  if (wcov[k] === nv) {
                  } else if (nv === void 0 && censor !== void 0 || has(wcov, k) && nv === ov) {
                    redactPathCurrent = node(redactPathCurrent, wck, depth);
                  } else {
                    redactPathCurrent = node(redactPathCurrent, wck, depth);
                    const rv = restoreInstr(node(redactPathCurrent, k, depth + 1), ov, o[originalKey]);
                    store.push(rv);
                    wcov[k] = nv;
                  }
                }
              }
            }
          }
          wc = null;
        } else {
          ov = n[k];
          redactPathCurrent = node(redactPathCurrent, k, depth);
          nv = i !== lastPathIndex ? ov : isCensorFct ? censorFctTakesPath ? censor(ov, [...path, originalKey, ...afterPath]) : censor(ov) : censor;
          if (has(n, k) && nv === ov || nv === void 0 && censor !== void 0) {
          } else {
            const rv = restoreInstr(redactPathCurrent, ov, o[originalKey]);
            store.push(rv);
            n[k] = nv;
          }
          n = n[k];
        }
        if (typeof n !== "object")
          break;
        if (ov === oov || typeof ov === "undefined") {
        }
      }
    }
    function get(o, p) {
      var i = -1;
      var l = p.length;
      var n = o;
      while (n != null && ++i < l) {
        n = n[p[i]];
      }
      return n;
    }
    function iterateNthLevel(wcov, level, k, path, afterPath, censor, isCensorFct, censorFctTakesPath, originalKey, n, nv, ov, kIsWc, wck, i, lastPathIndex, redactPathCurrent, store, parent, depth) {
      if (level === 0) {
        if (kIsWc || typeof wcov === "object" && wcov !== null && k in wcov) {
          if (kIsWc) {
            ov = wcov;
          } else {
            ov = wcov[k];
          }
          nv = i !== lastPathIndex ? ov : isCensorFct ? censorFctTakesPath ? censor(ov, [...path, originalKey, ...afterPath]) : censor(ov) : censor;
          if (kIsWc) {
            const rv = restoreInstr(redactPathCurrent, ov, parent);
            store.push(rv);
            n[wck] = nv;
          } else {
            if (wcov[k] === nv) {
            } else if (nv === void 0 && censor !== void 0 || has(wcov, k) && nv === ov) {
            } else {
              const rv = restoreInstr(node(redactPathCurrent, k, depth + 1), ov, parent);
              store.push(rv);
              wcov[k] = nv;
            }
          }
        }
      }
      for (const key in wcov) {
        if (typeof wcov[key] === "object") {
          redactPathCurrent = node(redactPathCurrent, key, depth);
          iterateNthLevel(wcov[key], level - 1, k, path, afterPath, censor, isCensorFct, censorFctTakesPath, originalKey, n, nv, ov, kIsWc, wck, i, lastPathIndex, redactPathCurrent, store, parent, depth + 1);
        }
      }
    }
    function tree() {
      return { parent: null, key: null, children: [], depth: 0 };
    }
    function node(parent, key, depth) {
      if (parent.depth === depth) {
        return node(parent.parent, key, depth);
      }
      var child = {
        parent,
        key,
        depth,
        children: []
      };
      parent.children.push(child);
      return child;
    }
    function restoreInstr(node2, value, target) {
      let current = node2;
      const path = [];
      do {
        path.push(current.key);
        current = current.parent;
      } while (current.parent != null);
      return { path, value, target };
    }
  }
});

// node_modules/fast-redact/lib/restorer.js
var require_restorer = __commonJS({
  "node_modules/fast-redact/lib/restorer.js"(exports, module2) {
    "use strict";
    var { groupRestore, nestedRestore } = require_modifiers();
    module2.exports = restorer;
    function restorer({ secret, wcLen }) {
      return function compileRestore() {
        if (this.restore)
          return;
        const paths = Object.keys(secret);
        const resetters = resetTmpl(secret, paths);
        const hasWildcards = wcLen > 0;
        const state = hasWildcards ? { secret, groupRestore, nestedRestore } : { secret };
        this.restore = Function(
          "o",
          restoreTmpl(resetters, paths, hasWildcards)
        ).bind(state);
      };
    }
    function resetTmpl(secret, paths) {
      return paths.map((path) => {
        const { circle, escPath, leadingBracket } = secret[path];
        const delim = leadingBracket ? "" : ".";
        const reset = circle ? `o.${circle} = secret[${escPath}].val` : `o${delim}${path} = secret[${escPath}].val`;
        const clear = `secret[${escPath}].val = undefined`;
        return `
      if (secret[${escPath}].val !== undefined) {
        try { ${reset} } catch (e) {}
        ${clear}
      }
    `;
      }).join("");
    }
    function restoreTmpl(resetters, paths, hasWildcards) {
      const dynamicReset = hasWildcards === true ? `
    const keys = Object.keys(secret)
    const len = keys.length
    for (var i = len - 1; i >= ${paths.length}; i--) {
      const k = keys[i]
      const o = secret[k]
      if (o.flat === true) this.groupRestore(o)
      else this.nestedRestore(o)
      secret[k] = null
    }
  ` : "";
      return `
    const secret = this.secret
    ${dynamicReset}
    ${resetters}
    return o
  `;
    }
  }
});

// node_modules/fast-redact/lib/state.js
var require_state = __commonJS({
  "node_modules/fast-redact/lib/state.js"(exports, module2) {
    "use strict";
    module2.exports = state;
    function state(o) {
      const {
        secret,
        censor,
        compileRestore,
        serialize,
        groupRedact,
        nestedRedact,
        wildcards,
        wcLen
      } = o;
      const builder = [{ secret, censor, compileRestore }];
      if (serialize !== false)
        builder.push({ serialize });
      if (wcLen > 0)
        builder.push({ groupRedact, nestedRedact, wildcards, wcLen });
      return Object.assign(...builder);
    }
  }
});

// node_modules/fast-redact/index.js
var require_fast_redact = __commonJS({
  "node_modules/fast-redact/index.js"(exports, module2) {
    "use strict";
    var validator = require_validator();
    var parse = require_parse2();
    var redactor = require_redactor();
    var restorer = require_restorer();
    var { groupRedact, nestedRedact } = require_modifiers();
    var state = require_state();
    var rx = require_rx();
    var validate = validator();
    var noop = (o) => o;
    noop.restore = noop;
    var DEFAULT_CENSOR = "[REDACTED]";
    fastRedact.rx = rx;
    fastRedact.validator = validator;
    module2.exports = fastRedact;
    function fastRedact(opts = {}) {
      const paths = Array.from(new Set(opts.paths || []));
      const serialize = "serialize" in opts ? opts.serialize === false ? opts.serialize : typeof opts.serialize === "function" ? opts.serialize : JSON.stringify : JSON.stringify;
      const remove = opts.remove;
      if (remove === true && serialize !== JSON.stringify) {
        throw Error("fast-redact \u2013 remove option may only be set when serializer is JSON.stringify");
      }
      const censor = remove === true ? void 0 : "censor" in opts ? opts.censor : DEFAULT_CENSOR;
      const isCensorFct = typeof censor === "function";
      const censorFctTakesPath = isCensorFct && censor.length > 1;
      if (paths.length === 0)
        return serialize || noop;
      validate({ paths, serialize, censor });
      const { wildcards, wcLen, secret } = parse({ paths, censor });
      const compileRestore = restorer({ secret, wcLen });
      const strict = "strict" in opts ? opts.strict : true;
      return redactor({ secret, wcLen, serialize, strict, isCensorFct, censorFctTakesPath }, state({
        secret,
        censor,
        compileRestore,
        serialize,
        groupRedact,
        nestedRedact,
        wildcards,
        wcLen
      }));
    }
  }
});

// node_modules/pino/lib/symbols.js
var require_symbols = __commonJS({
  "node_modules/pino/lib/symbols.js"(exports, module2) {
    "use strict";
    var setLevelSym = Symbol("pino.setLevel");
    var getLevelSym = Symbol("pino.getLevel");
    var levelValSym = Symbol("pino.levelVal");
    var useLevelLabelsSym = Symbol("pino.useLevelLabels");
    var useOnlyCustomLevelsSym = Symbol("pino.useOnlyCustomLevels");
    var mixinSym = Symbol("pino.mixin");
    var lsCacheSym = Symbol("pino.lsCache");
    var chindingsSym = Symbol("pino.chindings");
    var parsedChindingsSym = Symbol("pino.parsedChindings");
    var asJsonSym = Symbol("pino.asJson");
    var writeSym = Symbol("pino.write");
    var redactFmtSym = Symbol("pino.redactFmt");
    var timeSym = Symbol("pino.time");
    var timeSliceIndexSym = Symbol("pino.timeSliceIndex");
    var streamSym = Symbol("pino.stream");
    var stringifySym = Symbol("pino.stringify");
    var stringifiersSym = Symbol("pino.stringifiers");
    var endSym = Symbol("pino.end");
    var formatOptsSym = Symbol("pino.formatOpts");
    var messageKeySym = Symbol("pino.messageKey");
    var nestedKeySym = Symbol("pino.nestedKey");
    var mixinMergeStrategySym = Symbol("pino.mixinMergeStrategy");
    var wildcardFirstSym = Symbol("pino.wildcardFirst");
    var serializersSym = Symbol.for("pino.serializers");
    var formattersSym = Symbol.for("pino.formatters");
    var hooksSym = Symbol.for("pino.hooks");
    var needsMetadataGsym = Symbol.for("pino.metadata");
    module2.exports = {
      setLevelSym,
      getLevelSym,
      levelValSym,
      useLevelLabelsSym,
      mixinSym,
      lsCacheSym,
      chindingsSym,
      parsedChindingsSym,
      asJsonSym,
      writeSym,
      serializersSym,
      redactFmtSym,
      timeSym,
      timeSliceIndexSym,
      streamSym,
      stringifySym,
      stringifiersSym,
      endSym,
      formatOptsSym,
      messageKeySym,
      nestedKeySym,
      wildcardFirstSym,
      needsMetadataGsym,
      useOnlyCustomLevelsSym,
      formattersSym,
      hooksSym,
      mixinMergeStrategySym
    };
  }
});

// node_modules/pino/lib/redaction.js
var require_redaction = __commonJS({
  "node_modules/pino/lib/redaction.js"(exports, module2) {
    "use strict";
    var fastRedact = require_fast_redact();
    var { redactFmtSym, wildcardFirstSym } = require_symbols();
    var { rx, validator } = fastRedact;
    var validate = validator({
      ERR_PATHS_MUST_BE_STRINGS: () => "pino \u2013 redacted paths must be strings",
      ERR_INVALID_PATH: (s) => `pino \u2013 redact paths array contains an invalid path (${s})`
    });
    var CENSOR = "[Redacted]";
    var strict = false;
    function redaction(opts, serialize) {
      const { paths, censor } = handle(opts);
      const shape = paths.reduce((o, str) => {
        rx.lastIndex = 0;
        const first = rx.exec(str);
        const next = rx.exec(str);
        let ns = first[1] !== void 0 ? first[1].replace(/^(?:"|'|`)(.*)(?:"|'|`)$/, "$1") : first[0];
        if (ns === "*") {
          ns = wildcardFirstSym;
        }
        if (next === null) {
          o[ns] = null;
          return o;
        }
        if (o[ns] === null) {
          return o;
        }
        const { index } = next;
        const nextPath = `${str.substr(index, str.length - 1)}`;
        o[ns] = o[ns] || [];
        if (ns !== wildcardFirstSym && o[ns].length === 0) {
          o[ns].push(...o[wildcardFirstSym] || []);
        }
        if (ns === wildcardFirstSym) {
          Object.keys(o).forEach(function(k) {
            if (o[k]) {
              o[k].push(nextPath);
            }
          });
        }
        o[ns].push(nextPath);
        return o;
      }, {});
      const result = {
        [redactFmtSym]: fastRedact({ paths, censor, serialize, strict })
      };
      const topCensor = (...args) => {
        return typeof censor === "function" ? serialize(censor(...args)) : serialize(censor);
      };
      return [...Object.keys(shape), ...Object.getOwnPropertySymbols(shape)].reduce((o, k) => {
        if (shape[k] === null) {
          o[k] = (value) => topCensor(value, [k]);
        } else {
          const wrappedCensor = typeof censor === "function" ? (value, path) => {
            return censor(value, [k, ...path]);
          } : censor;
          o[k] = fastRedact({
            paths: shape[k],
            censor: wrappedCensor,
            serialize,
            strict
          });
        }
        return o;
      }, result);
    }
    function handle(opts) {
      if (Array.isArray(opts)) {
        opts = { paths: opts, censor: CENSOR };
        validate(opts);
        return opts;
      }
      let { paths, censor = CENSOR, remove } = opts;
      if (Array.isArray(paths) === false) {
        throw Error("pino \u2013 redact must contain an array of strings");
      }
      if (remove === true)
        censor = void 0;
      validate({ paths, censor });
      return { paths, censor };
    }
    module2.exports = redaction;
  }
});

// node_modules/pino/lib/time.js
var require_time = __commonJS({
  "node_modules/pino/lib/time.js"(exports, module2) {
    "use strict";
    var nullTime = () => "";
    var epochTime = () => `,"time":${Date.now()}`;
    var unixTime = () => `,"time":${Math.round(Date.now() / 1e3)}`;
    var isoTime = () => `,"time":"${new Date(Date.now()).toISOString()}"`;
    module2.exports = { nullTime, epochTime, unixTime, isoTime };
  }
});

// node_modules/flatstr/index.js
var require_flatstr = __commonJS({
  "node_modules/flatstr/index.js"(exports, module2) {
    "use strict";
    function flatstr(s) {
      s | 0;
      return s;
    }
    module2.exports = flatstr;
  }
});

// node_modules/atomic-sleep/index.js
var require_atomic_sleep = __commonJS({
  "node_modules/atomic-sleep/index.js"(exports, module2) {
    "use strict";
    if (typeof SharedArrayBuffer !== "undefined" && typeof Atomics !== "undefined") {
      let sleep = function(ms) {
        const valid = ms > 0 && ms < Infinity;
        if (valid === false) {
          if (typeof ms !== "number" && typeof ms !== "bigint") {
            throw TypeError("sleep: ms must be a number");
          }
          throw RangeError("sleep: ms must be a number that is greater than 0 but less than Infinity");
        }
        Atomics.wait(nil, 0, 0, Number(ms));
      };
      const nil = new Int32Array(new SharedArrayBuffer(4));
      module2.exports = sleep;
    } else {
      let sleep = function(ms) {
        const valid = ms > 0 && ms < Infinity;
        if (valid === false) {
          if (typeof ms !== "number" && typeof ms !== "bigint") {
            throw TypeError("sleep: ms must be a number");
          }
          throw RangeError("sleep: ms must be a number that is greater than 0 but less than Infinity");
        }
        const target = Date.now() + Number(ms);
        while (target > Date.now()) {
        }
      };
      module2.exports = sleep;
    }
  }
});

// node_modules/sonic-boom/index.js
var require_sonic_boom = __commonJS({
  "node_modules/sonic-boom/index.js"(exports, module2) {
    "use strict";
    var fs = require("fs");
    var EventEmitter = require("events");
    var flatstr = require_flatstr();
    var inherits = require("util").inherits;
    var BUSY_WRITE_TIMEOUT = 100;
    var sleep = require_atomic_sleep();
    var MAX_WRITE = 16 * 1024 * 1024;
    function openFile(file, sonic) {
      sonic._opening = true;
      sonic._writing = true;
      sonic._asyncDrainScheduled = false;
      function fileOpened(err, fd) {
        if (err) {
          sonic._reopening = false;
          sonic._writing = false;
          sonic._opening = false;
          if (sonic.sync) {
            process.nextTick(() => {
              if (sonic.listenerCount("error") > 0) {
                sonic.emit("error", err);
              }
            });
          } else {
            sonic.emit("error", err);
          }
          return;
        }
        sonic.fd = fd;
        sonic.file = file;
        sonic._reopening = false;
        sonic._opening = false;
        sonic._writing = false;
        if (sonic.sync) {
          process.nextTick(() => sonic.emit("ready"));
        } else {
          sonic.emit("ready");
        }
        if (sonic._reopening) {
          return;
        }
        const len = sonic._buf.length;
        if (len > 0 && len > sonic.minLength && !sonic.destroyed) {
          actualWrite(sonic);
        }
      }
      if (sonic.sync) {
        try {
          const fd = fs.openSync(file, "a");
          fileOpened(null, fd);
        } catch (err) {
          fileOpened(err);
          throw err;
        }
      } else {
        fs.open(file, "a", fileOpened);
      }
    }
    function SonicBoom(opts) {
      if (!(this instanceof SonicBoom)) {
        return new SonicBoom(opts);
      }
      let { fd, dest, minLength, sync } = opts || {};
      fd = fd || dest;
      this._buf = "";
      this.fd = -1;
      this._writing = false;
      this._writingBuf = "";
      this._ending = false;
      this._reopening = false;
      this._asyncDrainScheduled = false;
      this.file = null;
      this.destroyed = false;
      this.sync = sync || false;
      this.minLength = minLength || 0;
      if (typeof fd === "number") {
        this.fd = fd;
        process.nextTick(() => this.emit("ready"));
      } else if (typeof fd === "string") {
        openFile(fd, this);
      } else {
        throw new Error("SonicBoom supports only file descriptors and files");
      }
      this.release = (err, n) => {
        if (err) {
          if (err.code === "EAGAIN") {
            if (this.sync) {
              try {
                sleep(BUSY_WRITE_TIMEOUT);
                this.release(void 0, 0);
              } catch (err2) {
                this.release(err2);
              }
            } else {
              setTimeout(() => {
                fs.write(this.fd, this._writingBuf, "utf8", this.release);
              }, BUSY_WRITE_TIMEOUT);
            }
          } else {
            this._buf = this._writingBuf + this._buf;
            this._writingBuf = "";
            this._writing = false;
            this.emit("error", err);
          }
          return;
        }
        if (this._writingBuf.length !== n) {
          this._writingBuf = this._writingBuf.slice(n);
          if (this.sync) {
            try {
              do {
                n = fs.writeSync(this.fd, this._writingBuf, "utf8");
                this._writingBuf = this._writingBuf.slice(n);
              } while (this._writingBuf.length !== 0);
            } catch (err2) {
              this.release(err2);
              return;
            }
          } else {
            fs.write(this.fd, this._writingBuf, "utf8", this.release);
            return;
          }
        }
        this._writingBuf = "";
        if (this.destroyed) {
          return;
        }
        const len = this._buf.length;
        if (this._reopening) {
          this._writing = false;
          this._reopening = false;
          this.reopen();
        } else if (len > 0 && len > this.minLength) {
          actualWrite(this);
        } else if (this._ending) {
          if (len > 0) {
            actualWrite(this);
          } else {
            this._writing = false;
            actualClose(this);
          }
        } else {
          this._writing = false;
          if (this.sync) {
            if (!this._asyncDrainScheduled) {
              this._asyncDrainScheduled = true;
              process.nextTick(emitDrain, this);
            }
          } else {
            this.emit("drain");
          }
        }
      };
      this.on("newListener", function(name) {
        if (name === "drain") {
          this._asyncDrainScheduled = false;
        }
      });
    }
    function emitDrain(sonic) {
      const hasListeners = sonic.listenerCount("drain") > 0;
      if (!hasListeners)
        return;
      sonic._asyncDrainScheduled = false;
      sonic.emit("drain");
    }
    inherits(SonicBoom, EventEmitter);
    SonicBoom.prototype.write = function(data) {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      this._buf += data;
      const len = this._buf.length;
      if (!this._writing && len > this.minLength) {
        actualWrite(this);
      }
      return len < 16384;
    };
    SonicBoom.prototype.flush = function() {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      if (this._writing || this.minLength <= 0) {
        return;
      }
      actualWrite(this);
    };
    SonicBoom.prototype.reopen = function(file) {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      if (this._opening) {
        this.once("ready", () => {
          this.reopen(file);
        });
        return;
      }
      if (this._ending) {
        return;
      }
      if (!this.file) {
        throw new Error("Unable to reopen a file descriptor, you must pass a file to SonicBoom");
      }
      this._reopening = true;
      if (this._writing) {
        return;
      }
      const fd = this.fd;
      this.once("ready", () => {
        if (fd !== this.fd) {
          fs.close(fd, (err) => {
            if (err) {
              return this.emit("error", err);
            }
          });
        }
      });
      openFile(file || this.file, this);
    };
    SonicBoom.prototype.end = function() {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      if (this._opening) {
        this.once("ready", () => {
          this.end();
        });
        return;
      }
      if (this._ending) {
        return;
      }
      this._ending = true;
      if (!this._writing && this._buf.length > 0 && this.fd >= 0) {
        actualWrite(this);
        return;
      }
      if (this._writing) {
        return;
      }
      actualClose(this);
    };
    SonicBoom.prototype.flushSync = function() {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      if (this.fd < 0) {
        throw new Error("sonic boom is not ready yet");
      }
      while (this._buf.length > 0) {
        try {
          fs.writeSync(this.fd, this._buf, "utf8");
          this._buf = "";
        } catch (err) {
          if (err.code !== "EAGAIN") {
            throw err;
          }
          sleep(BUSY_WRITE_TIMEOUT);
        }
      }
    };
    SonicBoom.prototype.destroy = function() {
      if (this.destroyed) {
        return;
      }
      actualClose(this);
    };
    function actualWrite(sonic) {
      sonic._writing = true;
      let buf = sonic._buf;
      const release = sonic.release;
      if (buf.length > MAX_WRITE) {
        buf = buf.slice(0, MAX_WRITE);
        sonic._buf = sonic._buf.slice(MAX_WRITE);
      } else {
        sonic._buf = "";
      }
      flatstr(buf);
      sonic._writingBuf = buf;
      if (sonic.sync) {
        try {
          const written = fs.writeSync(sonic.fd, buf, "utf8");
          release(null, written);
        } catch (err) {
          release(err);
        }
      } else {
        fs.write(sonic.fd, buf, "utf8", release);
      }
    }
    function actualClose(sonic) {
      if (sonic.fd === -1) {
        sonic.once("ready", actualClose.bind(null, sonic));
        return;
      }
      fs.close(sonic.fd, (err) => {
        if (err) {
          sonic.emit("error", err);
          return;
        }
        if (sonic._ending && !sonic._writing) {
          sonic.emit("finish");
        }
        sonic.emit("close");
      });
      sonic.destroyed = true;
      sonic._buf = "";
    }
    module2.exports = SonicBoom;
  }
});

// node_modules/process-warning/index.js
var require_process_warning = __commonJS({
  "node_modules/process-warning/index.js"(exports, module2) {
    "use strict";
    var { format } = require("util");
    function build() {
      const codes = {};
      const emitted = /* @__PURE__ */ new Map();
      function create(name, code, message) {
        if (!name)
          throw new Error("Warning name must not be empty");
        if (!code)
          throw new Error("Warning code must not be empty");
        if (!message)
          throw new Error("Warning message must not be empty");
        code = code.toUpperCase();
        if (codes[code] !== void 0) {
          throw new Error(`The code '${code}' already exist`);
        }
        function buildWarnOpts(a, b, c) {
          let formatted;
          if (a && b && c) {
            formatted = format(message, a, b, c);
          } else if (a && b) {
            formatted = format(message, a, b);
          } else if (a) {
            formatted = format(message, a);
          } else {
            formatted = message;
          }
          return {
            code,
            name,
            message: formatted
          };
        }
        emitted.set(code, false);
        codes[code] = buildWarnOpts;
        return codes[code];
      }
      function emit(code, a, b, c) {
        if (codes[code] === void 0)
          throw new Error(`The code '${code}' does not exist`);
        if (emitted.get(code) === true)
          return;
        emitted.set(code, true);
        const warning = codes[code](a, b, c);
        process.emitWarning(warning.message, warning.name, warning.code);
      }
      return {
        create,
        emit,
        emitted
      };
    }
    module2.exports = build;
  }
});

// node_modules/pino/lib/deprecations.js
var require_deprecations = __commonJS({
  "node_modules/pino/lib/deprecations.js"(exports, module2) {
    "use strict";
    var warning = require_process_warning()();
    module2.exports = warning;
    var warnName = "PinoWarning";
    warning.create(warnName, "PINODEP004", "bindings.serializers is deprecated, use options.serializers option instead");
    warning.create(warnName, "PINODEP005", "bindings.formatters is deprecated, use options.formatters option instead");
    warning.create(warnName, "PINODEP006", "bindings.customLevels is deprecated, use options.customLevels option instead");
    warning.create(warnName, "PINODEP007", "bindings.level is deprecated, use options.level option instead");
  }
});

// node_modules/quick-format-unescaped/index.js
var require_quick_format_unescaped = __commonJS({
  "node_modules/quick-format-unescaped/index.js"(exports, module2) {
    "use strict";
    function tryStringify(o) {
      try {
        return JSON.stringify(o);
      } catch (e) {
        return '"[Circular]"';
      }
    }
    module2.exports = format;
    function format(f, args, opts) {
      var ss = opts && opts.stringify || tryStringify;
      var offset = 1;
      if (typeof f === "object" && f !== null) {
        var len = args.length + offset;
        if (len === 1)
          return f;
        var objects = new Array(len);
        objects[0] = ss(f);
        for (var index = 1; index < len; index++) {
          objects[index] = ss(args[index]);
        }
        return objects.join(" ");
      }
      if (typeof f !== "string") {
        return f;
      }
      var argLen = args.length;
      if (argLen === 0)
        return f;
      var str = "";
      var a = 1 - offset;
      var lastPos = -1;
      var flen = f && f.length || 0;
      for (var i = 0; i < flen; ) {
        if (f.charCodeAt(i) === 37 && i + 1 < flen) {
          lastPos = lastPos > -1 ? lastPos : 0;
          switch (f.charCodeAt(i + 1)) {
            case 100:
            case 102:
              if (a >= argLen)
                break;
              if (args[a] == null)
                break;
              if (lastPos < i)
                str += f.slice(lastPos, i);
              str += Number(args[a]);
              lastPos = i + 2;
              i++;
              break;
            case 105:
              if (a >= argLen)
                break;
              if (args[a] == null)
                break;
              if (lastPos < i)
                str += f.slice(lastPos, i);
              str += Math.floor(Number(args[a]));
              lastPos = i + 2;
              i++;
              break;
            case 79:
            case 111:
            case 106:
              if (a >= argLen)
                break;
              if (args[a] === void 0)
                break;
              if (lastPos < i)
                str += f.slice(lastPos, i);
              var type = typeof args[a];
              if (type === "string") {
                str += "'" + args[a] + "'";
                lastPos = i + 2;
                i++;
                break;
              }
              if (type === "function") {
                str += args[a].name || "<anonymous>";
                lastPos = i + 2;
                i++;
                break;
              }
              str += ss(args[a]);
              lastPos = i + 2;
              i++;
              break;
            case 115:
              if (a >= argLen)
                break;
              if (lastPos < i)
                str += f.slice(lastPos, i);
              str += String(args[a]);
              lastPos = i + 2;
              i++;
              break;
            case 37:
              if (lastPos < i)
                str += f.slice(lastPos, i);
              str += "%";
              lastPos = i + 2;
              i++;
              a--;
              break;
          }
          ++a;
        }
        ++i;
      }
      if (lastPos === -1)
        return f;
      else if (lastPos < flen) {
        str += f.slice(lastPos);
      }
      return str;
    }
  }
});

// node_modules/fast-safe-stringify/index.js
var require_fast_safe_stringify = __commonJS({
  "node_modules/fast-safe-stringify/index.js"(exports, module2) {
    module2.exports = stringify;
    stringify.default = stringify;
    stringify.stable = deterministicStringify;
    stringify.stableStringify = deterministicStringify;
    var LIMIT_REPLACE_NODE = "[...]";
    var CIRCULAR_REPLACE_NODE = "[Circular]";
    var arr = [];
    var replacerStack = [];
    function defaultOptions() {
      return {
        depthLimit: Number.MAX_SAFE_INTEGER,
        edgesLimit: Number.MAX_SAFE_INTEGER
      };
    }
    function stringify(obj, replacer, spacer, options) {
      if (typeof options === "undefined") {
        options = defaultOptions();
      }
      decirc(obj, "", 0, [], void 0, 0, options);
      var res;
      try {
        if (replacerStack.length === 0) {
          res = JSON.stringify(obj, replacer, spacer);
        } else {
          res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);
        }
      } catch (_) {
        return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
      } finally {
        while (arr.length !== 0) {
          var part = arr.pop();
          if (part.length === 4) {
            Object.defineProperty(part[0], part[1], part[3]);
          } else {
            part[0][part[1]] = part[2];
          }
        }
      }
      return res;
    }
    function setReplace(replace, val, k, parent) {
      var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);
      if (propertyDescriptor.get !== void 0) {
        if (propertyDescriptor.configurable) {
          Object.defineProperty(parent, k, { value: replace });
          arr.push([parent, k, val, propertyDescriptor]);
        } else {
          replacerStack.push([val, k, replace]);
        }
      } else {
        parent[k] = replace;
        arr.push([parent, k, val]);
      }
    }
    function decirc(val, k, edgeIndex, stack, parent, depth, options) {
      depth += 1;
      var i;
      if (typeof val === "object" && val !== null) {
        for (i = 0; i < stack.length; i++) {
          if (stack[i] === val) {
            setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
            return;
          }
        }
        if (typeof options.depthLimit !== "undefined" && depth > options.depthLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        if (typeof options.edgesLimit !== "undefined" && edgeIndex + 1 > options.edgesLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        stack.push(val);
        if (Array.isArray(val)) {
          for (i = 0; i < val.length; i++) {
            decirc(val[i], i, i, stack, val, depth, options);
          }
        } else {
          var keys = Object.keys(val);
          for (i = 0; i < keys.length; i++) {
            var key = keys[i];
            decirc(val[key], key, i, stack, val, depth, options);
          }
        }
        stack.pop();
      }
    }
    function compareFunction(a, b) {
      if (a < b) {
        return -1;
      }
      if (a > b) {
        return 1;
      }
      return 0;
    }
    function deterministicStringify(obj, replacer, spacer, options) {
      if (typeof options === "undefined") {
        options = defaultOptions();
      }
      var tmp = deterministicDecirc(obj, "", 0, [], void 0, 0, options) || obj;
      var res;
      try {
        if (replacerStack.length === 0) {
          res = JSON.stringify(tmp, replacer, spacer);
        } else {
          res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);
        }
      } catch (_) {
        return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
      } finally {
        while (arr.length !== 0) {
          var part = arr.pop();
          if (part.length === 4) {
            Object.defineProperty(part[0], part[1], part[3]);
          } else {
            part[0][part[1]] = part[2];
          }
        }
      }
      return res;
    }
    function deterministicDecirc(val, k, edgeIndex, stack, parent, depth, options) {
      depth += 1;
      var i;
      if (typeof val === "object" && val !== null) {
        for (i = 0; i < stack.length; i++) {
          if (stack[i] === val) {
            setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
            return;
          }
        }
        try {
          if (typeof val.toJSON === "function") {
            return;
          }
        } catch (_) {
          return;
        }
        if (typeof options.depthLimit !== "undefined" && depth > options.depthLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        if (typeof options.edgesLimit !== "undefined" && edgeIndex + 1 > options.edgesLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        stack.push(val);
        if (Array.isArray(val)) {
          for (i = 0; i < val.length; i++) {
            deterministicDecirc(val[i], i, i, stack, val, depth, options);
          }
        } else {
          var tmp = {};
          var keys = Object.keys(val).sort(compareFunction);
          for (i = 0; i < keys.length; i++) {
            var key = keys[i];
            deterministicDecirc(val[key], key, i, stack, val, depth, options);
            tmp[key] = val[key];
          }
          if (typeof parent !== "undefined") {
            arr.push([parent, k, val]);
            parent[k] = tmp;
          } else {
            return tmp;
          }
        }
        stack.pop();
      }
    }
    function replaceGetterValues(replacer) {
      replacer = typeof replacer !== "undefined" ? replacer : function(k, v) {
        return v;
      };
      return function(key, val) {
        if (replacerStack.length > 0) {
          for (var i = 0; i < replacerStack.length; i++) {
            var part = replacerStack[i];
            if (part[1] === key && part[0] === val) {
              val = part[2];
              replacerStack.splice(i, 1);
              break;
            }
          }
        }
        return replacer.call(this, key, val);
      };
    }
  }
});

// node_modules/pino-pretty/node_modules/color-name/index.js
var require_color_name = __commonJS({
  "node_modules/pino-pretty/node_modules/color-name/index.js"(exports, module2) {
    "use strict";
    module2.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/pino-pretty/node_modules/color-convert/conversions.js
var require_conversions = __commonJS({
  "node_modules/pino-pretty/node_modules/color-convert/conversions.js"(exports, module2) {
    var cssKeywords = require_color_name();
    var reverseKeywords = {};
    for (const key of Object.keys(cssKeywords)) {
      reverseKeywords[cssKeywords[key]] = key;
    }
    var convert = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    module2.exports = convert;
    for (const model of Object.keys(convert)) {
      if (!("channels" in convert[model])) {
        throw new Error("missing channels property: " + model);
      }
      if (!("labels" in convert[model])) {
        throw new Error("missing channel labels property: " + model);
      }
      if (convert[model].labels.length !== convert[model].channels) {
        throw new Error("channel and label counts mismatch: " + model);
      }
      const { channels, labels } = convert[model];
      delete convert[model].channels;
      delete convert[model].labels;
      Object.defineProperty(convert[model], "channels", { value: channels });
      Object.defineProperty(convert[model], "labels", { value: labels });
    }
    convert.rgb.hsl = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const min = Math.min(r, g, b);
      const max = Math.max(r, g, b);
      const delta = max - min;
      let h;
      let s;
      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      const l = (min + max) / 2;
      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }
      return [h, s * 100, l * 100];
    };
    convert.rgb.hsv = function(rgb) {
      let rdif;
      let gdif;
      let bdif;
      let h;
      let s;
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const v = Math.max(r, g, b);
      const diff = v - Math.min(r, g, b);
      const diffc = function(c) {
        return (v - c) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h = 0;
        s = 0;
      } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r === v) {
          h = bdif - gdif;
        } else if (g === v) {
          h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h = 2 / 3 + gdif - rdif;
        }
        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }
      return [
        h * 360,
        s * 100,
        v * 100
      ];
    };
    convert.rgb.hwb = function(rgb) {
      const r = rgb[0];
      const g = rgb[1];
      let b = rgb[2];
      const h = convert.rgb.hsl(rgb)[0];
      const w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    };
    convert.rgb.cmyk = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const k = Math.min(1 - r, 1 - g, 1 - b);
      const c = (1 - r - k) / (1 - k) || 0;
      const m = (1 - g - k) / (1 - k) || 0;
      const y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
      return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
    }
    convert.rgb.keyword = function(rgb) {
      const reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      let currentClosestDistance = Infinity;
      let currentClosestKeyword;
      for (const keyword of Object.keys(cssKeywords)) {
        const value = cssKeywords[keyword];
        const distance = comparativeDistance(rgb, value);
        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      let r = rgb[0] / 255;
      let g = rgb[1] / 255;
      let b = rgb[2] / 255;
      r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
      g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
      b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
      const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };
    convert.rgb.lab = function(rgb) {
      const xyz = convert.rgb.xyz(rgb);
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert.hsl.rgb = function(hsl) {
      const h = hsl[0] / 360;
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      let t2;
      let t3;
      let val;
      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      const t1 = 2 * l - t2;
      const rgb = [0, 0, 0];
      for (let i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i] = val * 255;
      }
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      const h = hsl[0];
      let s = hsl[1] / 100;
      let l = hsl[2] / 100;
      let smin = s;
      const lmin = Math.max(l, 0.01);
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      const v = (l + s) / 2;
      const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    };
    convert.hsv.rgb = function(hsv) {
      const h = hsv[0] / 60;
      const s = hsv[1] / 100;
      let v = hsv[2] / 100;
      const hi = Math.floor(h) % 6;
      const f = h - Math.floor(h);
      const p = 255 * v * (1 - s);
      const q = 255 * v * (1 - s * f);
      const t = 255 * v * (1 - s * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t];
        case 3:
          return [p, q, v];
        case 4:
          return [t, p, v];
        case 5:
          return [v, p, q];
      }
    };
    convert.hsv.hsl = function(hsv) {
      const h = hsv[0];
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const vmin = Math.max(v, 0.01);
      let sl;
      let l;
      l = (2 - s) * v;
      const lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    };
    convert.hwb.rgb = function(hwb) {
      const h = hwb[0] / 360;
      let wh = hwb[1] / 100;
      let bl = hwb[2] / 100;
      const ratio = wh + bl;
      let f;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      const i = Math.floor(6 * h);
      const v = 1 - bl;
      f = 6 * h - i;
      if ((i & 1) !== 0) {
        f = 1 - f;
      }
      const n = wh + f * (v - wh);
      let r;
      let g;
      let b;
      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;
        case 1:
          r = n;
          g = v;
          b = wh;
          break;
        case 2:
          r = wh;
          g = v;
          b = n;
          break;
        case 3:
          r = wh;
          g = n;
          b = v;
          break;
        case 4:
          r = n;
          g = wh;
          b = v;
          break;
        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }
      return [r * 255, g * 255, b * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      const c = cmyk[0] / 100;
      const m = cmyk[1] / 100;
      const y = cmyk[2] / 100;
      const k = cmyk[3] / 100;
      const r = 1 - Math.min(1, c * (1 - k) + k);
      const g = 1 - Math.min(1, m * (1 - k) + k);
      const b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.rgb = function(xyz) {
      const x = xyz[0] / 100;
      const y = xyz[1] / 100;
      const z = xyz[2] / 100;
      let r;
      let g;
      let b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.204 + z * 1.057;
      r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
      g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
      b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.lab = function(xyz) {
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert.lab.xyz = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let x;
      let y;
      let z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      const y2 = y ** 3;
      const x2 = x ** 3;
      const z2 = z ** 3;
      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };
    convert.lab.lch = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let h;
      const hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      const c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    };
    convert.lch.lab = function(lch) {
      const l = lch[0];
      const c = lch[1];
      const h = lch[2];
      const hr = h / 360 * 2 * Math.PI;
      const a = c * Math.cos(hr);
      const b = c * Math.sin(hr);
      return [l, a, b];
    };
    convert.rgb.ansi16 = function(args, saturation = null) {
      const [r, g, b] = args;
      let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation;
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      const r = args[0];
      const g = args[1];
      const b = args[2];
      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args) {
      let color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      const mult = (~~(args > 50) + 1) * 0.5;
      const r = (color & 1) * mult * 255;
      const g = (color >> 1 & 1) * mult * 255;
      const b = (color >> 2 & 1) * mult * 255;
      return [r, g, b];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        const c = (args - 232) * 10 + 8;
        return [c, c, c];
      }
      args -= 16;
      let rem;
      const r = Math.floor(args / 36) / 5 * 255;
      const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      const b = rem % 6 / 5 * 255;
      return [r, g, b];
    };
    convert.rgb.hex = function(args) {
      const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.hex.rgb = function(args) {
      const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      let colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map((char) => {
          return char + char;
        }).join("");
      }
      const integer = parseInt(colorString, 16);
      const r = integer >> 16 & 255;
      const g = integer >> 8 & 255;
      const b = integer & 255;
      return [r, g, b];
    };
    convert.rgb.hcg = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const max = Math.max(Math.max(r, g), b);
      const min = Math.min(Math.min(r, g), b);
      const chroma = max - min;
      let grayscale;
      let hue;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r) {
        hue = (g - b) / chroma % 6;
      } else if (max === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl) {
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
      let f = 0;
      if (c < 1) {
        f = (l - 0.5 * c) / (1 - c);
      }
      return [hsl[0], c * 100, f * 100];
    };
    convert.hsv.hcg = function(hsv) {
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const c = s * v;
      let f = 0;
      if (c < 1) {
        f = (v - c) / (1 - c);
      }
      return [hsv[0], c * 100, f * 100];
    };
    convert.hcg.rgb = function(hcg) {
      const h = hcg[0] / 360;
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      if (c === 0) {
        return [g * 255, g * 255, g * 255];
      }
      const pure = [0, 0, 0];
      const hi = h % 1 * 6;
      const v = hi % 1;
      const w = 1 - v;
      let mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }
      mg = (1 - c) * g;
      return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      let f = 0;
      if (v > 0) {
        f = c / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert.hcg.hsl = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const l = g * (1 - c) + 0.5 * c;
      let s = 0;
      if (l > 0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s = c / (2 * (1 - l));
      }
      return [hcg[0], s * 100, l * 100];
    };
    convert.hcg.hwb = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      const w = hwb[1] / 100;
      const b = hwb[2] / 100;
      const v = 1 - b;
      const c = v - w;
      let g = 0;
      if (c < 1) {
        g = (v - c) / (1 - c);
      }
      return [hwb[0], c * 100, g * 100];
    };
    convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert.gray.hsl = function(args) {
      return [0, 0, args[0]];
    };
    convert.gray.hsv = convert.gray.hsl;
    convert.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert.gray.hex = function(gray) {
      const val = Math.round(gray[0] / 100 * 255) & 255;
      const integer = (val << 16) + (val << 8) + val;
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.rgb.gray = function(rgb) {
      const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
});

// node_modules/pino-pretty/node_modules/color-convert/route.js
var require_route = __commonJS({
  "node_modules/pino-pretty/node_modules/color-convert/route.js"(exports, module2) {
    var conversions = require_conversions();
    function buildGraph() {
      const graph = {};
      const models = Object.keys(conversions);
      for (let len = models.length, i = 0; i < len; i++) {
        graph[models[i]] = {
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      const graph = buildGraph();
      const queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        const current = queue.pop();
        const adjacents = Object.keys(conversions[current]);
        for (let len = adjacents.length, i = 0; i < len; i++) {
          const adjacent = adjacents[i];
          const node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      const path = [graph[toModel].parent, toModel];
      let fn = conversions[graph[toModel].parent][toModel];
      let cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path;
      return fn;
    }
    module2.exports = function(fromModel) {
      const graph = deriveBFS(fromModel);
      const conversion = {};
      const models = Object.keys(graph);
      for (let len = models.length, i = 0; i < len; i++) {
        const toModel = models[i];
        const node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// node_modules/pino-pretty/node_modules/color-convert/index.js
var require_color_convert = __commonJS({
  "node_modules/pino-pretty/node_modules/color-convert/index.js"(exports, module2) {
    var conversions = require_conversions();
    var route = require_route();
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        const result = fn(args);
        if (typeof result === "object") {
          for (let len = result.length, i = 0; i < len; i++) {
            result[i] = Math.round(result[i]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach((fromModel) => {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
      const routes = route(fromModel);
      const routeModels = Object.keys(routes);
      routeModels.forEach((toModel) => {
        const fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module2.exports = convert;
  }
});

// node_modules/pino-pretty/node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS({
  "node_modules/pino-pretty/node_modules/ansi-styles/index.js"(exports, module2) {
    "use strict";
    var wrapAnsi16 = (fn, offset) => (...args) => {
      const code = fn(...args);
      return `\x1B[${code + offset}m`;
    };
    var wrapAnsi256 = (fn, offset) => (...args) => {
      const code = fn(...args);
      return `\x1B[${38 + offset};5;${code}m`;
    };
    var wrapAnsi16m = (fn, offset) => (...args) => {
      const rgb = fn(...args);
      return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };
    var ansi2ansi = (n) => n;
    var rgb2rgb = (r, g, b) => [r, g, b];
    var setLazyProperty = (object, property, get) => {
      Object.defineProperty(object, property, {
        get: () => {
          const value = get();
          Object.defineProperty(object, property, {
            value,
            enumerable: true,
            configurable: true
          });
          return value;
        },
        enumerable: true,
        configurable: true
      });
    };
    var colorConvert;
    var makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
      if (colorConvert === void 0) {
        colorConvert = require_color_convert();
      }
      const offset = isBackground ? 10 : 0;
      const styles = {};
      for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
        const name = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
        if (sourceSpace === targetSpace) {
          styles[name] = wrap(identity, offset);
        } else if (typeof suite === "object") {
          styles[name] = wrap(suite[targetSpace], offset);
        }
      }
      return styles;
    };
    function assembleStyles() {
      const codes = /* @__PURE__ */ new Map();
      const styles = {
        modifier: {
          reset: [0, 0],
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles.color.gray = styles.color.blackBright;
      styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
      styles.color.grey = styles.color.blackBright;
      styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
      for (const [groupName, group] of Object.entries(styles)) {
        for (const [styleName, style] of Object.entries(group)) {
          styles[styleName] = {
            open: `\x1B[${style[0]}m`,
            close: `\x1B[${style[1]}m`
          };
          group[styleName] = styles[styleName];
          codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles, groupName, {
          value: group,
          enumerable: false
        });
      }
      Object.defineProperty(styles, "codes", {
        value: codes,
        enumerable: false
      });
      styles.color.close = "\x1B[39m";
      styles.bgColor.close = "\x1B[49m";
      setLazyProperty(styles.color, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
      setLazyProperty(styles.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
      return styles;
    }
    Object.defineProperty(module2, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  }
});

// node_modules/pino-pretty/node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "node_modules/pino-pretty/node_modules/has-flag/index.js"(exports, module2) {
    "use strict";
    module2.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// node_modules/pino-pretty/node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/pino-pretty/node_modules/supports-color/index.js"(exports, module2) {
    "use strict";
    var os = require("os");
    var tty = require("tty");
    var hasFlag = require_has_flag();
    var { env } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// node_modules/pino-pretty/node_modules/chalk/source/util.js
var require_util = __commonJS({
  "node_modules/pino-pretty/node_modules/chalk/source/util.js"(exports, module2) {
    "use strict";
    var stringReplaceAll = (string, substring, replacer) => {
      let index = string.indexOf(substring);
      if (index === -1) {
        return string;
      }
      const substringLength = substring.length;
      let endIndex = 0;
      let returnValue = "";
      do {
        returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
        endIndex = index + substringLength;
        index = string.indexOf(substring, endIndex);
      } while (index !== -1);
      returnValue += string.substr(endIndex);
      return returnValue;
    };
    var stringEncaseCRLFWithFirstIndex = (string, prefix, postfix, index) => {
      let endIndex = 0;
      let returnValue = "";
      do {
        const gotCR = string[index - 1] === "\r";
        returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
        endIndex = index + 1;
        index = string.indexOf("\n", endIndex);
      } while (index !== -1);
      returnValue += string.substr(endIndex);
      return returnValue;
    };
    module2.exports = {
      stringReplaceAll,
      stringEncaseCRLFWithFirstIndex
    };
  }
});

// node_modules/pino-pretty/node_modules/chalk/source/templates.js
var require_templates = __commonJS({
  "node_modules/pino-pretty/node_modules/chalk/source/templates.js"(exports, module2) {
    "use strict";
    var TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
    var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
    var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
    var ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
    var ESCAPES = /* @__PURE__ */ new Map([
      ["n", "\n"],
      ["r", "\r"],
      ["t", "	"],
      ["b", "\b"],
      ["f", "\f"],
      ["v", "\v"],
      ["0", "\0"],
      ["\\", "\\"],
      ["e", "\x1B"],
      ["a", "\x07"]
    ]);
    function unescape2(c) {
      const u = c[0] === "u";
      const bracket = c[1] === "{";
      if (u && !bracket && c.length === 5 || c[0] === "x" && c.length === 3) {
        return String.fromCharCode(parseInt(c.slice(1), 16));
      }
      if (u && bracket) {
        return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
      }
      return ESCAPES.get(c) || c;
    }
    function parseArguments(name, arguments_) {
      const results = [];
      const chunks = arguments_.trim().split(/\s*,\s*/g);
      let matches;
      for (const chunk of chunks) {
        const number = Number(chunk);
        if (!Number.isNaN(number)) {
          results.push(number);
        } else if (matches = chunk.match(STRING_REGEX)) {
          results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, character) => escape ? unescape2(escape) : character));
        } else {
          throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
        }
      }
      return results;
    }
    function parseStyle(style) {
      STYLE_REGEX.lastIndex = 0;
      const results = [];
      let matches;
      while ((matches = STYLE_REGEX.exec(style)) !== null) {
        const name = matches[1];
        if (matches[2]) {
          const args = parseArguments(name, matches[2]);
          results.push([name].concat(args));
        } else {
          results.push([name]);
        }
      }
      return results;
    }
    function buildStyle(chalk, styles) {
      const enabled = {};
      for (const layer of styles) {
        for (const style of layer.styles) {
          enabled[style[0]] = layer.inverse ? null : style.slice(1);
        }
      }
      let current = chalk;
      for (const [styleName, styles2] of Object.entries(enabled)) {
        if (!Array.isArray(styles2)) {
          continue;
        }
        if (!(styleName in current)) {
          throw new Error(`Unknown Chalk style: ${styleName}`);
        }
        current = styles2.length > 0 ? current[styleName](...styles2) : current[styleName];
      }
      return current;
    }
    module2.exports = (chalk, temporary) => {
      const styles = [];
      const chunks = [];
      let chunk = [];
      temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {
        if (escapeCharacter) {
          chunk.push(unescape2(escapeCharacter));
        } else if (style) {
          const string = chunk.join("");
          chunk = [];
          chunks.push(styles.length === 0 ? string : buildStyle(chalk, styles)(string));
          styles.push({ inverse, styles: parseStyle(style) });
        } else if (close) {
          if (styles.length === 0) {
            throw new Error("Found extraneous } in Chalk template literal");
          }
          chunks.push(buildStyle(chalk, styles)(chunk.join("")));
          chunk = [];
          styles.pop();
        } else {
          chunk.push(character);
        }
      });
      chunks.push(chunk.join(""));
      if (styles.length > 0) {
        const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
        throw new Error(errMessage);
      }
      return chunks.join("");
    };
  }
});

// node_modules/pino-pretty/node_modules/chalk/source/index.js
var require_source = __commonJS({
  "node_modules/pino-pretty/node_modules/chalk/source/index.js"(exports, module2) {
    "use strict";
    var ansiStyles = require_ansi_styles();
    var { stdout: stdoutColor, stderr: stderrColor } = require_supports_color();
    var {
      stringReplaceAll,
      stringEncaseCRLFWithFirstIndex
    } = require_util();
    var { isArray } = Array;
    var levelMapping = [
      "ansi",
      "ansi",
      "ansi256",
      "ansi16m"
    ];
    var styles = /* @__PURE__ */ Object.create(null);
    var applyOptions = (object, options = {}) => {
      if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
        throw new Error("The `level` option should be an integer from 0 to 3");
      }
      const colorLevel = stdoutColor ? stdoutColor.level : 0;
      object.level = options.level === void 0 ? colorLevel : options.level;
    };
    var ChalkClass = class {
      constructor(options) {
        return chalkFactory(options);
      }
    };
    var chalkFactory = (options) => {
      const chalk2 = {};
      applyOptions(chalk2, options);
      chalk2.template = (...arguments_) => chalkTag(chalk2.template, ...arguments_);
      Object.setPrototypeOf(chalk2, Chalk.prototype);
      Object.setPrototypeOf(chalk2.template, chalk2);
      chalk2.template.constructor = () => {
        throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
      };
      chalk2.template.Instance = ChalkClass;
      return chalk2.template;
    };
    function Chalk(options) {
      return chalkFactory(options);
    }
    for (const [styleName, style] of Object.entries(ansiStyles)) {
      styles[styleName] = {
        get() {
          const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
          Object.defineProperty(this, styleName, { value: builder });
          return builder;
        }
      };
    }
    styles.visible = {
      get() {
        const builder = createBuilder(this, this._styler, true);
        Object.defineProperty(this, "visible", { value: builder });
        return builder;
      }
    };
    var usedModels = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
    for (const model of usedModels) {
      styles[model] = {
        get() {
          const { level } = this;
          return function(...arguments_) {
            const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
            return createBuilder(this, styler, this._isEmpty);
          };
        }
      };
    }
    for (const model of usedModels) {
      const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
      styles[bgModel] = {
        get() {
          const { level } = this;
          return function(...arguments_) {
            const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
            return createBuilder(this, styler, this._isEmpty);
          };
        }
      };
    }
    var proto = Object.defineProperties(() => {
    }, {
      ...styles,
      level: {
        enumerable: true,
        get() {
          return this._generator.level;
        },
        set(level) {
          this._generator.level = level;
        }
      }
    });
    var createStyler = (open, close, parent) => {
      let openAll;
      let closeAll;
      if (parent === void 0) {
        openAll = open;
        closeAll = close;
      } else {
        openAll = parent.openAll + open;
        closeAll = close + parent.closeAll;
      }
      return {
        open,
        close,
        openAll,
        closeAll,
        parent
      };
    };
    var createBuilder = (self2, _styler, _isEmpty) => {
      const builder = (...arguments_) => {
        if (isArray(arguments_[0]) && isArray(arguments_[0].raw)) {
          return applyStyle(builder, chalkTag(builder, ...arguments_));
        }
        return applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
      };
      Object.setPrototypeOf(builder, proto);
      builder._generator = self2;
      builder._styler = _styler;
      builder._isEmpty = _isEmpty;
      return builder;
    };
    var applyStyle = (self2, string) => {
      if (self2.level <= 0 || !string) {
        return self2._isEmpty ? "" : string;
      }
      let styler = self2._styler;
      if (styler === void 0) {
        return string;
      }
      const { openAll, closeAll } = styler;
      if (string.indexOf("\x1B") !== -1) {
        while (styler !== void 0) {
          string = stringReplaceAll(string, styler.close, styler.open);
          styler = styler.parent;
        }
      }
      const lfIndex = string.indexOf("\n");
      if (lfIndex !== -1) {
        string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
      }
      return openAll + string + closeAll;
    };
    var template;
    var chalkTag = (chalk2, ...strings) => {
      const [firstString] = strings;
      if (!isArray(firstString) || !isArray(firstString.raw)) {
        return strings.join(" ");
      }
      const arguments_ = strings.slice(1);
      const parts = [firstString.raw[0]];
      for (let i = 1; i < firstString.length; i++) {
        parts.push(
          String(arguments_[i - 1]).replace(/[{}\\]/g, "\\$&"),
          String(firstString.raw[i])
        );
      }
      if (template === void 0) {
        template = require_templates();
      }
      return template(chalk2, parts.join(""));
    };
    Object.defineProperties(Chalk.prototype, styles);
    var chalk = Chalk();
    chalk.supportsColor = stdoutColor;
    chalk.stderr = Chalk({ level: stderrColor ? stderrColor.level : 0 });
    chalk.stderr.supportsColor = stderrColor;
    module2.exports = chalk;
  }
});

// node_modules/jmespath/jmespath.js
var require_jmespath = __commonJS({
  "node_modules/jmespath/jmespath.js"(exports) {
    (function(exports2) {
      "use strict";
      function isArray(obj) {
        if (obj !== null) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        } else {
          return false;
        }
      }
      function isObject(obj) {
        if (obj !== null) {
          return Object.prototype.toString.call(obj) === "[object Object]";
        } else {
          return false;
        }
      }
      function strictDeepEqual(first, second) {
        if (first === second) {
          return true;
        }
        var firstType = Object.prototype.toString.call(first);
        if (firstType !== Object.prototype.toString.call(second)) {
          return false;
        }
        if (isArray(first) === true) {
          if (first.length !== second.length) {
            return false;
          }
          for (var i = 0; i < first.length; i++) {
            if (strictDeepEqual(first[i], second[i]) === false) {
              return false;
            }
          }
          return true;
        }
        if (isObject(first) === true) {
          var keysSeen = {};
          for (var key in first) {
            if (hasOwnProperty.call(first, key)) {
              if (strictDeepEqual(first[key], second[key]) === false) {
                return false;
              }
              keysSeen[key] = true;
            }
          }
          for (var key2 in second) {
            if (hasOwnProperty.call(second, key2)) {
              if (keysSeen[key2] !== true) {
                return false;
              }
            }
          }
          return true;
        }
        return false;
      }
      function isFalse(obj) {
        if (obj === "" || obj === false || obj === null) {
          return true;
        } else if (isArray(obj) && obj.length === 0) {
          return true;
        } else if (isObject(obj)) {
          for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
              return false;
            }
          }
          return true;
        } else {
          return false;
        }
      }
      function objValues(obj) {
        var keys = Object.keys(obj);
        var values = [];
        for (var i = 0; i < keys.length; i++) {
          values.push(obj[keys[i]]);
        }
        return values;
      }
      function merge(a, b) {
        var merged = {};
        for (var key in a) {
          merged[key] = a[key];
        }
        for (var key2 in b) {
          merged[key2] = b[key2];
        }
        return merged;
      }
      var trimLeft;
      if (typeof String.prototype.trimLeft === "function") {
        trimLeft = function(str) {
          return str.trimLeft();
        };
      } else {
        trimLeft = function(str) {
          return str.match(/^\s*(.*)/)[1];
        };
      }
      var TYPE_NUMBER = 0;
      var TYPE_ANY = 1;
      var TYPE_STRING = 2;
      var TYPE_ARRAY = 3;
      var TYPE_OBJECT = 4;
      var TYPE_BOOLEAN = 5;
      var TYPE_EXPREF = 6;
      var TYPE_NULL = 7;
      var TYPE_ARRAY_NUMBER = 8;
      var TYPE_ARRAY_STRING = 9;
      var TOK_EOF = "EOF";
      var TOK_UNQUOTEDIDENTIFIER = "UnquotedIdentifier";
      var TOK_QUOTEDIDENTIFIER = "QuotedIdentifier";
      var TOK_RBRACKET = "Rbracket";
      var TOK_RPAREN = "Rparen";
      var TOK_COMMA = "Comma";
      var TOK_COLON = "Colon";
      var TOK_RBRACE = "Rbrace";
      var TOK_NUMBER = "Number";
      var TOK_CURRENT = "Current";
      var TOK_EXPREF = "Expref";
      var TOK_PIPE = "Pipe";
      var TOK_OR = "Or";
      var TOK_AND = "And";
      var TOK_EQ = "EQ";
      var TOK_GT = "GT";
      var TOK_LT = "LT";
      var TOK_GTE = "GTE";
      var TOK_LTE = "LTE";
      var TOK_NE = "NE";
      var TOK_FLATTEN = "Flatten";
      var TOK_STAR = "Star";
      var TOK_FILTER = "Filter";
      var TOK_DOT = "Dot";
      var TOK_NOT = "Not";
      var TOK_LBRACE = "Lbrace";
      var TOK_LBRACKET = "Lbracket";
      var TOK_LPAREN = "Lparen";
      var TOK_LITERAL = "Literal";
      var basicTokens = {
        ".": TOK_DOT,
        "*": TOK_STAR,
        ",": TOK_COMMA,
        ":": TOK_COLON,
        "{": TOK_LBRACE,
        "}": TOK_RBRACE,
        "]": TOK_RBRACKET,
        "(": TOK_LPAREN,
        ")": TOK_RPAREN,
        "@": TOK_CURRENT
      };
      var operatorStartToken = {
        "<": true,
        ">": true,
        "=": true,
        "!": true
      };
      var skipChars = {
        " ": true,
        "	": true,
        "\n": true
      };
      function isAlpha(ch) {
        return ch >= "a" && ch <= "z" || ch >= "A" && ch <= "Z" || ch === "_";
      }
      function isNum(ch) {
        return ch >= "0" && ch <= "9" || ch === "-";
      }
      function isAlphaNum(ch) {
        return ch >= "a" && ch <= "z" || ch >= "A" && ch <= "Z" || ch >= "0" && ch <= "9" || ch === "_";
      }
      function Lexer() {
      }
      Lexer.prototype = {
        tokenize: function(stream) {
          var tokens = [];
          this._current = 0;
          var start;
          var identifier;
          var token;
          while (this._current < stream.length) {
            if (isAlpha(stream[this._current])) {
              start = this._current;
              identifier = this._consumeUnquotedIdentifier(stream);
              tokens.push({
                type: TOK_UNQUOTEDIDENTIFIER,
                value: identifier,
                start
              });
            } else if (basicTokens[stream[this._current]] !== void 0) {
              tokens.push({
                type: basicTokens[stream[this._current]],
                value: stream[this._current],
                start: this._current
              });
              this._current++;
            } else if (isNum(stream[this._current])) {
              token = this._consumeNumber(stream);
              tokens.push(token);
            } else if (stream[this._current] === "[") {
              token = this._consumeLBracket(stream);
              tokens.push(token);
            } else if (stream[this._current] === '"') {
              start = this._current;
              identifier = this._consumeQuotedIdentifier(stream);
              tokens.push({
                type: TOK_QUOTEDIDENTIFIER,
                value: identifier,
                start
              });
            } else if (stream[this._current] === "'") {
              start = this._current;
              identifier = this._consumeRawStringLiteral(stream);
              tokens.push({
                type: TOK_LITERAL,
                value: identifier,
                start
              });
            } else if (stream[this._current] === "`") {
              start = this._current;
              var literal = this._consumeLiteral(stream);
              tokens.push({
                type: TOK_LITERAL,
                value: literal,
                start
              });
            } else if (operatorStartToken[stream[this._current]] !== void 0) {
              tokens.push(this._consumeOperator(stream));
            } else if (skipChars[stream[this._current]] !== void 0) {
              this._current++;
            } else if (stream[this._current] === "&") {
              start = this._current;
              this._current++;
              if (stream[this._current] === "&") {
                this._current++;
                tokens.push({ type: TOK_AND, value: "&&", start });
              } else {
                tokens.push({ type: TOK_EXPREF, value: "&", start });
              }
            } else if (stream[this._current] === "|") {
              start = this._current;
              this._current++;
              if (stream[this._current] === "|") {
                this._current++;
                tokens.push({ type: TOK_OR, value: "||", start });
              } else {
                tokens.push({ type: TOK_PIPE, value: "|", start });
              }
            } else {
              var error = new Error("Unknown character:" + stream[this._current]);
              error.name = "LexerError";
              throw error;
            }
          }
          return tokens;
        },
        _consumeUnquotedIdentifier: function(stream) {
          var start = this._current;
          this._current++;
          while (this._current < stream.length && isAlphaNum(stream[this._current])) {
            this._current++;
          }
          return stream.slice(start, this._current);
        },
        _consumeQuotedIdentifier: function(stream) {
          var start = this._current;
          this._current++;
          var maxLength = stream.length;
          while (stream[this._current] !== '"' && this._current < maxLength) {
            var current = this._current;
            if (stream[current] === "\\" && (stream[current + 1] === "\\" || stream[current + 1] === '"')) {
              current += 2;
            } else {
              current++;
            }
            this._current = current;
          }
          this._current++;
          return JSON.parse(stream.slice(start, this._current));
        },
        _consumeRawStringLiteral: function(stream) {
          var start = this._current;
          this._current++;
          var maxLength = stream.length;
          while (stream[this._current] !== "'" && this._current < maxLength) {
            var current = this._current;
            if (stream[current] === "\\" && (stream[current + 1] === "\\" || stream[current + 1] === "'")) {
              current += 2;
            } else {
              current++;
            }
            this._current = current;
          }
          this._current++;
          var literal = stream.slice(start + 1, this._current - 1);
          return literal.replace("\\'", "'");
        },
        _consumeNumber: function(stream) {
          var start = this._current;
          this._current++;
          var maxLength = stream.length;
          while (isNum(stream[this._current]) && this._current < maxLength) {
            this._current++;
          }
          var value = parseInt(stream.slice(start, this._current));
          return { type: TOK_NUMBER, value, start };
        },
        _consumeLBracket: function(stream) {
          var start = this._current;
          this._current++;
          if (stream[this._current] === "?") {
            this._current++;
            return { type: TOK_FILTER, value: "[?", start };
          } else if (stream[this._current] === "]") {
            this._current++;
            return { type: TOK_FLATTEN, value: "[]", start };
          } else {
            return { type: TOK_LBRACKET, value: "[", start };
          }
        },
        _consumeOperator: function(stream) {
          var start = this._current;
          var startingChar = stream[start];
          this._current++;
          if (startingChar === "!") {
            if (stream[this._current] === "=") {
              this._current++;
              return { type: TOK_NE, value: "!=", start };
            } else {
              return { type: TOK_NOT, value: "!", start };
            }
          } else if (startingChar === "<") {
            if (stream[this._current] === "=") {
              this._current++;
              return { type: TOK_LTE, value: "<=", start };
            } else {
              return { type: TOK_LT, value: "<", start };
            }
          } else if (startingChar === ">") {
            if (stream[this._current] === "=") {
              this._current++;
              return { type: TOK_GTE, value: ">=", start };
            } else {
              return { type: TOK_GT, value: ">", start };
            }
          } else if (startingChar === "=") {
            if (stream[this._current] === "=") {
              this._current++;
              return { type: TOK_EQ, value: "==", start };
            }
          }
        },
        _consumeLiteral: function(stream) {
          this._current++;
          var start = this._current;
          var maxLength = stream.length;
          var literal;
          while (stream[this._current] !== "`" && this._current < maxLength) {
            var current = this._current;
            if (stream[current] === "\\" && (stream[current + 1] === "\\" || stream[current + 1] === "`")) {
              current += 2;
            } else {
              current++;
            }
            this._current = current;
          }
          var literalString = trimLeft(stream.slice(start, this._current));
          literalString = literalString.replace("\\`", "`");
          if (this._looksLikeJSON(literalString)) {
            literal = JSON.parse(literalString);
          } else {
            literal = JSON.parse('"' + literalString + '"');
          }
          this._current++;
          return literal;
        },
        _looksLikeJSON: function(literalString) {
          var startingChars = '[{"';
          var jsonLiterals = ["true", "false", "null"];
          var numberLooking = "-0123456789";
          if (literalString === "") {
            return false;
          } else if (startingChars.indexOf(literalString[0]) >= 0) {
            return true;
          } else if (jsonLiterals.indexOf(literalString) >= 0) {
            return true;
          } else if (numberLooking.indexOf(literalString[0]) >= 0) {
            try {
              JSON.parse(literalString);
              return true;
            } catch (ex) {
              return false;
            }
          } else {
            return false;
          }
        }
      };
      var bindingPower = {};
      bindingPower[TOK_EOF] = 0;
      bindingPower[TOK_UNQUOTEDIDENTIFIER] = 0;
      bindingPower[TOK_QUOTEDIDENTIFIER] = 0;
      bindingPower[TOK_RBRACKET] = 0;
      bindingPower[TOK_RPAREN] = 0;
      bindingPower[TOK_COMMA] = 0;
      bindingPower[TOK_RBRACE] = 0;
      bindingPower[TOK_NUMBER] = 0;
      bindingPower[TOK_CURRENT] = 0;
      bindingPower[TOK_EXPREF] = 0;
      bindingPower[TOK_PIPE] = 1;
      bindingPower[TOK_OR] = 2;
      bindingPower[TOK_AND] = 3;
      bindingPower[TOK_EQ] = 5;
      bindingPower[TOK_GT] = 5;
      bindingPower[TOK_LT] = 5;
      bindingPower[TOK_GTE] = 5;
      bindingPower[TOK_LTE] = 5;
      bindingPower[TOK_NE] = 5;
      bindingPower[TOK_FLATTEN] = 9;
      bindingPower[TOK_STAR] = 20;
      bindingPower[TOK_FILTER] = 21;
      bindingPower[TOK_DOT] = 40;
      bindingPower[TOK_NOT] = 45;
      bindingPower[TOK_LBRACE] = 50;
      bindingPower[TOK_LBRACKET] = 55;
      bindingPower[TOK_LPAREN] = 60;
      function Parser() {
      }
      Parser.prototype = {
        parse: function(expression) {
          this._loadTokens(expression);
          this.index = 0;
          var ast = this.expression(0);
          if (this._lookahead(0) !== TOK_EOF) {
            var t = this._lookaheadToken(0);
            var error = new Error(
              "Unexpected token type: " + t.type + ", value: " + t.value
            );
            error.name = "ParserError";
            throw error;
          }
          return ast;
        },
        _loadTokens: function(expression) {
          var lexer = new Lexer();
          var tokens = lexer.tokenize(expression);
          tokens.push({ type: TOK_EOF, value: "", start: expression.length });
          this.tokens = tokens;
        },
        expression: function(rbp) {
          var leftToken = this._lookaheadToken(0);
          this._advance();
          var left = this.nud(leftToken);
          var currentToken = this._lookahead(0);
          while (rbp < bindingPower[currentToken]) {
            this._advance();
            left = this.led(currentToken, left);
            currentToken = this._lookahead(0);
          }
          return left;
        },
        _lookahead: function(number) {
          return this.tokens[this.index + number].type;
        },
        _lookaheadToken: function(number) {
          return this.tokens[this.index + number];
        },
        _advance: function() {
          this.index++;
        },
        nud: function(token) {
          var left;
          var right;
          var expression;
          switch (token.type) {
            case TOK_LITERAL:
              return { type: "Literal", value: token.value };
            case TOK_UNQUOTEDIDENTIFIER:
              return { type: "Field", name: token.value };
            case TOK_QUOTEDIDENTIFIER:
              var node = { type: "Field", name: token.value };
              if (this._lookahead(0) === TOK_LPAREN) {
                throw new Error("Quoted identifier not allowed for function names.");
              } else {
                return node;
              }
              break;
            case TOK_NOT:
              right = this.expression(bindingPower.Not);
              return { type: "NotExpression", children: [right] };
            case TOK_STAR:
              left = { type: "Identity" };
              right = null;
              if (this._lookahead(0) === TOK_RBRACKET) {
                right = { type: "Identity" };
              } else {
                right = this._parseProjectionRHS(bindingPower.Star);
              }
              return { type: "ValueProjection", children: [left, right] };
            case TOK_FILTER:
              return this.led(token.type, { type: "Identity" });
            case TOK_LBRACE:
              return this._parseMultiselectHash();
            case TOK_FLATTEN:
              left = { type: TOK_FLATTEN, children: [{ type: "Identity" }] };
              right = this._parseProjectionRHS(bindingPower.Flatten);
              return { type: "Projection", children: [left, right] };
            case TOK_LBRACKET:
              if (this._lookahead(0) === TOK_NUMBER || this._lookahead(0) === TOK_COLON) {
                right = this._parseIndexExpression();
                return this._projectIfSlice({ type: "Identity" }, right);
              } else if (this._lookahead(0) === TOK_STAR && this._lookahead(1) === TOK_RBRACKET) {
                this._advance();
                this._advance();
                right = this._parseProjectionRHS(bindingPower.Star);
                return {
                  type: "Projection",
                  children: [{ type: "Identity" }, right]
                };
              } else {
                return this._parseMultiselectList();
              }
              break;
            case TOK_CURRENT:
              return { type: TOK_CURRENT };
            case TOK_EXPREF:
              expression = this.expression(bindingPower.Expref);
              return { type: "ExpressionReference", children: [expression] };
            case TOK_LPAREN:
              var args = [];
              while (this._lookahead(0) !== TOK_RPAREN) {
                if (this._lookahead(0) === TOK_CURRENT) {
                  expression = { type: TOK_CURRENT };
                  this._advance();
                } else {
                  expression = this.expression(0);
                }
                args.push(expression);
              }
              this._match(TOK_RPAREN);
              return args[0];
            default:
              this._errorToken(token);
          }
        },
        led: function(tokenName, left) {
          var right;
          switch (tokenName) {
            case TOK_DOT:
              var rbp = bindingPower.Dot;
              if (this._lookahead(0) !== TOK_STAR) {
                right = this._parseDotRHS(rbp);
                return { type: "Subexpression", children: [left, right] };
              } else {
                this._advance();
                right = this._parseProjectionRHS(rbp);
                return { type: "ValueProjection", children: [left, right] };
              }
              break;
            case TOK_PIPE:
              right = this.expression(bindingPower.Pipe);
              return { type: TOK_PIPE, children: [left, right] };
            case TOK_OR:
              right = this.expression(bindingPower.Or);
              return { type: "OrExpression", children: [left, right] };
            case TOK_AND:
              right = this.expression(bindingPower.And);
              return { type: "AndExpression", children: [left, right] };
            case TOK_LPAREN:
              var name = left.name;
              var args = [];
              var expression, node;
              while (this._lookahead(0) !== TOK_RPAREN) {
                if (this._lookahead(0) === TOK_CURRENT) {
                  expression = { type: TOK_CURRENT };
                  this._advance();
                } else {
                  expression = this.expression(0);
                }
                if (this._lookahead(0) === TOK_COMMA) {
                  this._match(TOK_COMMA);
                }
                args.push(expression);
              }
              this._match(TOK_RPAREN);
              node = { type: "Function", name, children: args };
              return node;
            case TOK_FILTER:
              var condition = this.expression(0);
              this._match(TOK_RBRACKET);
              if (this._lookahead(0) === TOK_FLATTEN) {
                right = { type: "Identity" };
              } else {
                right = this._parseProjectionRHS(bindingPower.Filter);
              }
              return { type: "FilterProjection", children: [left, right, condition] };
            case TOK_FLATTEN:
              var leftNode = { type: TOK_FLATTEN, children: [left] };
              var rightNode = this._parseProjectionRHS(bindingPower.Flatten);
              return { type: "Projection", children: [leftNode, rightNode] };
            case TOK_EQ:
            case TOK_NE:
            case TOK_GT:
            case TOK_GTE:
            case TOK_LT:
            case TOK_LTE:
              return this._parseComparator(left, tokenName);
            case TOK_LBRACKET:
              var token = this._lookaheadToken(0);
              if (token.type === TOK_NUMBER || token.type === TOK_COLON) {
                right = this._parseIndexExpression();
                return this._projectIfSlice(left, right);
              } else {
                this._match(TOK_STAR);
                this._match(TOK_RBRACKET);
                right = this._parseProjectionRHS(bindingPower.Star);
                return { type: "Projection", children: [left, right] };
              }
              break;
            default:
              this._errorToken(this._lookaheadToken(0));
          }
        },
        _match: function(tokenType) {
          if (this._lookahead(0) === tokenType) {
            this._advance();
          } else {
            var t = this._lookaheadToken(0);
            var error = new Error("Expected " + tokenType + ", got: " + t.type);
            error.name = "ParserError";
            throw error;
          }
        },
        _errorToken: function(token) {
          var error = new Error("Invalid token (" + token.type + '): "' + token.value + '"');
          error.name = "ParserError";
          throw error;
        },
        _parseIndexExpression: function() {
          if (this._lookahead(0) === TOK_COLON || this._lookahead(1) === TOK_COLON) {
            return this._parseSliceExpression();
          } else {
            var node = {
              type: "Index",
              value: this._lookaheadToken(0).value
            };
            this._advance();
            this._match(TOK_RBRACKET);
            return node;
          }
        },
        _projectIfSlice: function(left, right) {
          var indexExpr = { type: "IndexExpression", children: [left, right] };
          if (right.type === "Slice") {
            return {
              type: "Projection",
              children: [indexExpr, this._parseProjectionRHS(bindingPower.Star)]
            };
          } else {
            return indexExpr;
          }
        },
        _parseSliceExpression: function() {
          var parts = [null, null, null];
          var index = 0;
          var currentToken = this._lookahead(0);
          while (currentToken !== TOK_RBRACKET && index < 3) {
            if (currentToken === TOK_COLON) {
              index++;
              this._advance();
            } else if (currentToken === TOK_NUMBER) {
              parts[index] = this._lookaheadToken(0).value;
              this._advance();
            } else {
              var t = this._lookahead(0);
              var error = new Error("Syntax error, unexpected token: " + t.value + "(" + t.type + ")");
              error.name = "Parsererror";
              throw error;
            }
            currentToken = this._lookahead(0);
          }
          this._match(TOK_RBRACKET);
          return {
            type: "Slice",
            children: parts
          };
        },
        _parseComparator: function(left, comparator) {
          var right = this.expression(bindingPower[comparator]);
          return { type: "Comparator", name: comparator, children: [left, right] };
        },
        _parseDotRHS: function(rbp) {
          var lookahead = this._lookahead(0);
          var exprTokens = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER, TOK_STAR];
          if (exprTokens.indexOf(lookahead) >= 0) {
            return this.expression(rbp);
          } else if (lookahead === TOK_LBRACKET) {
            this._match(TOK_LBRACKET);
            return this._parseMultiselectList();
          } else if (lookahead === TOK_LBRACE) {
            this._match(TOK_LBRACE);
            return this._parseMultiselectHash();
          }
        },
        _parseProjectionRHS: function(rbp) {
          var right;
          if (bindingPower[this._lookahead(0)] < 10) {
            right = { type: "Identity" };
          } else if (this._lookahead(0) === TOK_LBRACKET) {
            right = this.expression(rbp);
          } else if (this._lookahead(0) === TOK_FILTER) {
            right = this.expression(rbp);
          } else if (this._lookahead(0) === TOK_DOT) {
            this._match(TOK_DOT);
            right = this._parseDotRHS(rbp);
          } else {
            var t = this._lookaheadToken(0);
            var error = new Error("Sytanx error, unexpected token: " + t.value + "(" + t.type + ")");
            error.name = "ParserError";
            throw error;
          }
          return right;
        },
        _parseMultiselectList: function() {
          var expressions = [];
          while (this._lookahead(0) !== TOK_RBRACKET) {
            var expression = this.expression(0);
            expressions.push(expression);
            if (this._lookahead(0) === TOK_COMMA) {
              this._match(TOK_COMMA);
              if (this._lookahead(0) === TOK_RBRACKET) {
                throw new Error("Unexpected token Rbracket");
              }
            }
          }
          this._match(TOK_RBRACKET);
          return { type: "MultiSelectList", children: expressions };
        },
        _parseMultiselectHash: function() {
          var pairs = [];
          var identifierTypes = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER];
          var keyToken, keyName, value, node;
          for (; ; ) {
            keyToken = this._lookaheadToken(0);
            if (identifierTypes.indexOf(keyToken.type) < 0) {
              throw new Error("Expecting an identifier token, got: " + keyToken.type);
            }
            keyName = keyToken.value;
            this._advance();
            this._match(TOK_COLON);
            value = this.expression(0);
            node = { type: "KeyValuePair", name: keyName, value };
            pairs.push(node);
            if (this._lookahead(0) === TOK_COMMA) {
              this._match(TOK_COMMA);
            } else if (this._lookahead(0) === TOK_RBRACE) {
              this._match(TOK_RBRACE);
              break;
            }
          }
          return { type: "MultiSelectHash", children: pairs };
        }
      };
      function TreeInterpreter(runtime) {
        this.runtime = runtime;
      }
      TreeInterpreter.prototype = {
        search: function(node, value) {
          return this.visit(node, value);
        },
        visit: function(node, value) {
          var matched, current, result, first, second, field, left, right, collected, i;
          switch (node.type) {
            case "Field":
              if (value === null) {
                return null;
              } else if (isObject(value)) {
                field = value[node.name];
                if (field === void 0) {
                  return null;
                } else {
                  return field;
                }
              } else {
                return null;
              }
              break;
            case "Subexpression":
              result = this.visit(node.children[0], value);
              for (i = 1; i < node.children.length; i++) {
                result = this.visit(node.children[1], result);
                if (result === null) {
                  return null;
                }
              }
              return result;
            case "IndexExpression":
              left = this.visit(node.children[0], value);
              right = this.visit(node.children[1], left);
              return right;
            case "Index":
              if (!isArray(value)) {
                return null;
              }
              var index = node.value;
              if (index < 0) {
                index = value.length + index;
              }
              result = value[index];
              if (result === void 0) {
                result = null;
              }
              return result;
            case "Slice":
              if (!isArray(value)) {
                return null;
              }
              var sliceParams = node.children.slice(0);
              var computed = this.computeSliceParams(value.length, sliceParams);
              var start = computed[0];
              var stop = computed[1];
              var step = computed[2];
              result = [];
              if (step > 0) {
                for (i = start; i < stop; i += step) {
                  result.push(value[i]);
                }
              } else {
                for (i = start; i > stop; i += step) {
                  result.push(value[i]);
                }
              }
              return result;
            case "Projection":
              var base = this.visit(node.children[0], value);
              if (!isArray(base)) {
                return null;
              }
              collected = [];
              for (i = 0; i < base.length; i++) {
                current = this.visit(node.children[1], base[i]);
                if (current !== null) {
                  collected.push(current);
                }
              }
              return collected;
            case "ValueProjection":
              base = this.visit(node.children[0], value);
              if (!isObject(base)) {
                return null;
              }
              collected = [];
              var values = objValues(base);
              for (i = 0; i < values.length; i++) {
                current = this.visit(node.children[1], values[i]);
                if (current !== null) {
                  collected.push(current);
                }
              }
              return collected;
            case "FilterProjection":
              base = this.visit(node.children[0], value);
              if (!isArray(base)) {
                return null;
              }
              var filtered = [];
              var finalResults = [];
              for (i = 0; i < base.length; i++) {
                matched = this.visit(node.children[2], base[i]);
                if (!isFalse(matched)) {
                  filtered.push(base[i]);
                }
              }
              for (var j = 0; j < filtered.length; j++) {
                current = this.visit(node.children[1], filtered[j]);
                if (current !== null) {
                  finalResults.push(current);
                }
              }
              return finalResults;
            case "Comparator":
              first = this.visit(node.children[0], value);
              second = this.visit(node.children[1], value);
              switch (node.name) {
                case TOK_EQ:
                  result = strictDeepEqual(first, second);
                  break;
                case TOK_NE:
                  result = !strictDeepEqual(first, second);
                  break;
                case TOK_GT:
                  result = first > second;
                  break;
                case TOK_GTE:
                  result = first >= second;
                  break;
                case TOK_LT:
                  result = first < second;
                  break;
                case TOK_LTE:
                  result = first <= second;
                  break;
                default:
                  throw new Error("Unknown comparator: " + node.name);
              }
              return result;
            case TOK_FLATTEN:
              var original = this.visit(node.children[0], value);
              if (!isArray(original)) {
                return null;
              }
              var merged = [];
              for (i = 0; i < original.length; i++) {
                current = original[i];
                if (isArray(current)) {
                  merged.push.apply(merged, current);
                } else {
                  merged.push(current);
                }
              }
              return merged;
            case "Identity":
              return value;
            case "MultiSelectList":
              if (value === null) {
                return null;
              }
              collected = [];
              for (i = 0; i < node.children.length; i++) {
                collected.push(this.visit(node.children[i], value));
              }
              return collected;
            case "MultiSelectHash":
              if (value === null) {
                return null;
              }
              collected = {};
              var child;
              for (i = 0; i < node.children.length; i++) {
                child = node.children[i];
                collected[child.name] = this.visit(child.value, value);
              }
              return collected;
            case "OrExpression":
              matched = this.visit(node.children[0], value);
              if (isFalse(matched)) {
                matched = this.visit(node.children[1], value);
              }
              return matched;
            case "AndExpression":
              first = this.visit(node.children[0], value);
              if (isFalse(first) === true) {
                return first;
              }
              return this.visit(node.children[1], value);
            case "NotExpression":
              first = this.visit(node.children[0], value);
              return isFalse(first);
            case "Literal":
              return node.value;
            case TOK_PIPE:
              left = this.visit(node.children[0], value);
              return this.visit(node.children[1], left);
            case TOK_CURRENT:
              return value;
            case "Function":
              var resolvedArgs = [];
              for (i = 0; i < node.children.length; i++) {
                resolvedArgs.push(this.visit(node.children[i], value));
              }
              return this.runtime.callFunction(node.name, resolvedArgs);
            case "ExpressionReference":
              var refNode = node.children[0];
              refNode.jmespathType = TOK_EXPREF;
              return refNode;
            default:
              throw new Error("Unknown node type: " + node.type);
          }
        },
        computeSliceParams: function(arrayLength, sliceParams) {
          var start = sliceParams[0];
          var stop = sliceParams[1];
          var step = sliceParams[2];
          var computed = [null, null, null];
          if (step === null) {
            step = 1;
          } else if (step === 0) {
            var error = new Error("Invalid slice, step cannot be 0");
            error.name = "RuntimeError";
            throw error;
          }
          var stepValueNegative = step < 0 ? true : false;
          if (start === null) {
            start = stepValueNegative ? arrayLength - 1 : 0;
          } else {
            start = this.capSliceRange(arrayLength, start, step);
          }
          if (stop === null) {
            stop = stepValueNegative ? -1 : arrayLength;
          } else {
            stop = this.capSliceRange(arrayLength, stop, step);
          }
          computed[0] = start;
          computed[1] = stop;
          computed[2] = step;
          return computed;
        },
        capSliceRange: function(arrayLength, actualValue, step) {
          if (actualValue < 0) {
            actualValue += arrayLength;
            if (actualValue < 0) {
              actualValue = step < 0 ? -1 : 0;
            }
          } else if (actualValue >= arrayLength) {
            actualValue = step < 0 ? arrayLength - 1 : arrayLength;
          }
          return actualValue;
        }
      };
      function Runtime(interpreter) {
        this._interpreter = interpreter;
        this.functionTable = {
          abs: { _func: this._functionAbs, _signature: [{ types: [TYPE_NUMBER] }] },
          avg: { _func: this._functionAvg, _signature: [{ types: [TYPE_ARRAY_NUMBER] }] },
          ceil: { _func: this._functionCeil, _signature: [{ types: [TYPE_NUMBER] }] },
          contains: {
            _func: this._functionContains,
            _signature: [
              { types: [TYPE_STRING, TYPE_ARRAY] },
              { types: [TYPE_ANY] }
            ]
          },
          "ends_with": {
            _func: this._functionEndsWith,
            _signature: [{ types: [TYPE_STRING] }, { types: [TYPE_STRING] }]
          },
          floor: { _func: this._functionFloor, _signature: [{ types: [TYPE_NUMBER] }] },
          length: {
            _func: this._functionLength,
            _signature: [{ types: [TYPE_STRING, TYPE_ARRAY, TYPE_OBJECT] }]
          },
          map: {
            _func: this._functionMap,
            _signature: [{ types: [TYPE_EXPREF] }, { types: [TYPE_ARRAY] }]
          },
          max: {
            _func: this._functionMax,
            _signature: [{ types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING] }]
          },
          "merge": {
            _func: this._functionMerge,
            _signature: [{ types: [TYPE_OBJECT], variadic: true }]
          },
          "max_by": {
            _func: this._functionMaxBy,
            _signature: [{ types: [TYPE_ARRAY] }, { types: [TYPE_EXPREF] }]
          },
          sum: { _func: this._functionSum, _signature: [{ types: [TYPE_ARRAY_NUMBER] }] },
          "starts_with": {
            _func: this._functionStartsWith,
            _signature: [{ types: [TYPE_STRING] }, { types: [TYPE_STRING] }]
          },
          min: {
            _func: this._functionMin,
            _signature: [{ types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING] }]
          },
          "min_by": {
            _func: this._functionMinBy,
            _signature: [{ types: [TYPE_ARRAY] }, { types: [TYPE_EXPREF] }]
          },
          type: { _func: this._functionType, _signature: [{ types: [TYPE_ANY] }] },
          keys: { _func: this._functionKeys, _signature: [{ types: [TYPE_OBJECT] }] },
          values: { _func: this._functionValues, _signature: [{ types: [TYPE_OBJECT] }] },
          sort: { _func: this._functionSort, _signature: [{ types: [TYPE_ARRAY_STRING, TYPE_ARRAY_NUMBER] }] },
          "sort_by": {
            _func: this._functionSortBy,
            _signature: [{ types: [TYPE_ARRAY] }, { types: [TYPE_EXPREF] }]
          },
          join: {
            _func: this._functionJoin,
            _signature: [
              { types: [TYPE_STRING] },
              { types: [TYPE_ARRAY_STRING] }
            ]
          },
          reverse: {
            _func: this._functionReverse,
            _signature: [{ types: [TYPE_STRING, TYPE_ARRAY] }]
          },
          "to_array": { _func: this._functionToArray, _signature: [{ types: [TYPE_ANY] }] },
          "to_string": { _func: this._functionToString, _signature: [{ types: [TYPE_ANY] }] },
          "to_number": { _func: this._functionToNumber, _signature: [{ types: [TYPE_ANY] }] },
          "not_null": {
            _func: this._functionNotNull,
            _signature: [{ types: [TYPE_ANY], variadic: true }]
          }
        };
      }
      Runtime.prototype = {
        callFunction: function(name, resolvedArgs) {
          var functionEntry = this.functionTable[name];
          if (functionEntry === void 0) {
            throw new Error("Unknown function: " + name + "()");
          }
          this._validateArgs(name, resolvedArgs, functionEntry._signature);
          return functionEntry._func.call(this, resolvedArgs);
        },
        _validateArgs: function(name, args, signature) {
          var pluralized;
          if (signature[signature.length - 1].variadic) {
            if (args.length < signature.length) {
              pluralized = signature.length === 1 ? " argument" : " arguments";
              throw new Error("ArgumentError: " + name + "() takes at least" + signature.length + pluralized + " but received " + args.length);
            }
          } else if (args.length !== signature.length) {
            pluralized = signature.length === 1 ? " argument" : " arguments";
            throw new Error("ArgumentError: " + name + "() takes " + signature.length + pluralized + " but received " + args.length);
          }
          var currentSpec;
          var actualType;
          var typeMatched;
          for (var i = 0; i < signature.length; i++) {
            typeMatched = false;
            currentSpec = signature[i].types;
            actualType = this._getTypeName(args[i]);
            for (var j = 0; j < currentSpec.length; j++) {
              if (this._typeMatches(actualType, currentSpec[j], args[i])) {
                typeMatched = true;
                break;
              }
            }
            if (!typeMatched) {
              throw new Error("TypeError: " + name + "() expected argument " + (i + 1) + " to be type " + currentSpec + " but received type " + actualType + " instead.");
            }
          }
        },
        _typeMatches: function(actual, expected, argValue) {
          if (expected === TYPE_ANY) {
            return true;
          }
          if (expected === TYPE_ARRAY_STRING || expected === TYPE_ARRAY_NUMBER || expected === TYPE_ARRAY) {
            if (expected === TYPE_ARRAY) {
              return actual === TYPE_ARRAY;
            } else if (actual === TYPE_ARRAY) {
              var subtype;
              if (expected === TYPE_ARRAY_NUMBER) {
                subtype = TYPE_NUMBER;
              } else if (expected === TYPE_ARRAY_STRING) {
                subtype = TYPE_STRING;
              }
              for (var i = 0; i < argValue.length; i++) {
                if (!this._typeMatches(
                  this._getTypeName(argValue[i]),
                  subtype,
                  argValue[i]
                )) {
                  return false;
                }
              }
              return true;
            }
          } else {
            return actual === expected;
          }
        },
        _getTypeName: function(obj) {
          switch (Object.prototype.toString.call(obj)) {
            case "[object String]":
              return TYPE_STRING;
            case "[object Number]":
              return TYPE_NUMBER;
            case "[object Array]":
              return TYPE_ARRAY;
            case "[object Boolean]":
              return TYPE_BOOLEAN;
            case "[object Null]":
              return TYPE_NULL;
            case "[object Object]":
              if (obj.jmespathType === TOK_EXPREF) {
                return TYPE_EXPREF;
              } else {
                return TYPE_OBJECT;
              }
          }
        },
        _functionStartsWith: function(resolvedArgs) {
          return resolvedArgs[0].lastIndexOf(resolvedArgs[1]) === 0;
        },
        _functionEndsWith: function(resolvedArgs) {
          var searchStr = resolvedArgs[0];
          var suffix = resolvedArgs[1];
          return searchStr.indexOf(suffix, searchStr.length - suffix.length) !== -1;
        },
        _functionReverse: function(resolvedArgs) {
          var typeName = this._getTypeName(resolvedArgs[0]);
          if (typeName === TYPE_STRING) {
            var originalStr = resolvedArgs[0];
            var reversedStr = "";
            for (var i = originalStr.length - 1; i >= 0; i--) {
              reversedStr += originalStr[i];
            }
            return reversedStr;
          } else {
            var reversedArray = resolvedArgs[0].slice(0);
            reversedArray.reverse();
            return reversedArray;
          }
        },
        _functionAbs: function(resolvedArgs) {
          return Math.abs(resolvedArgs[0]);
        },
        _functionCeil: function(resolvedArgs) {
          return Math.ceil(resolvedArgs[0]);
        },
        _functionAvg: function(resolvedArgs) {
          var sum = 0;
          var inputArray = resolvedArgs[0];
          for (var i = 0; i < inputArray.length; i++) {
            sum += inputArray[i];
          }
          return sum / inputArray.length;
        },
        _functionContains: function(resolvedArgs) {
          return resolvedArgs[0].indexOf(resolvedArgs[1]) >= 0;
        },
        _functionFloor: function(resolvedArgs) {
          return Math.floor(resolvedArgs[0]);
        },
        _functionLength: function(resolvedArgs) {
          if (!isObject(resolvedArgs[0])) {
            return resolvedArgs[0].length;
          } else {
            return Object.keys(resolvedArgs[0]).length;
          }
        },
        _functionMap: function(resolvedArgs) {
          var mapped = [];
          var interpreter = this._interpreter;
          var exprefNode = resolvedArgs[0];
          var elements = resolvedArgs[1];
          for (var i = 0; i < elements.length; i++) {
            mapped.push(interpreter.visit(exprefNode, elements[i]));
          }
          return mapped;
        },
        _functionMerge: function(resolvedArgs) {
          var merged = {};
          for (var i = 0; i < resolvedArgs.length; i++) {
            var current = resolvedArgs[i];
            for (var key in current) {
              merged[key] = current[key];
            }
          }
          return merged;
        },
        _functionMax: function(resolvedArgs) {
          if (resolvedArgs[0].length > 0) {
            var typeName = this._getTypeName(resolvedArgs[0][0]);
            if (typeName === TYPE_NUMBER) {
              return Math.max.apply(Math, resolvedArgs[0]);
            } else {
              var elements = resolvedArgs[0];
              var maxElement = elements[0];
              for (var i = 1; i < elements.length; i++) {
                if (maxElement.localeCompare(elements[i]) < 0) {
                  maxElement = elements[i];
                }
              }
              return maxElement;
            }
          } else {
            return null;
          }
        },
        _functionMin: function(resolvedArgs) {
          if (resolvedArgs[0].length > 0) {
            var typeName = this._getTypeName(resolvedArgs[0][0]);
            if (typeName === TYPE_NUMBER) {
              return Math.min.apply(Math, resolvedArgs[0]);
            } else {
              var elements = resolvedArgs[0];
              var minElement = elements[0];
              for (var i = 1; i < elements.length; i++) {
                if (elements[i].localeCompare(minElement) < 0) {
                  minElement = elements[i];
                }
              }
              return minElement;
            }
          } else {
            return null;
          }
        },
        _functionSum: function(resolvedArgs) {
          var sum = 0;
          var listToSum = resolvedArgs[0];
          for (var i = 0; i < listToSum.length; i++) {
            sum += listToSum[i];
          }
          return sum;
        },
        _functionType: function(resolvedArgs) {
          switch (this._getTypeName(resolvedArgs[0])) {
            case TYPE_NUMBER:
              return "number";
            case TYPE_STRING:
              return "string";
            case TYPE_ARRAY:
              return "array";
            case TYPE_OBJECT:
              return "object";
            case TYPE_BOOLEAN:
              return "boolean";
            case TYPE_EXPREF:
              return "expref";
            case TYPE_NULL:
              return "null";
          }
        },
        _functionKeys: function(resolvedArgs) {
          return Object.keys(resolvedArgs[0]);
        },
        _functionValues: function(resolvedArgs) {
          var obj = resolvedArgs[0];
          var keys = Object.keys(obj);
          var values = [];
          for (var i = 0; i < keys.length; i++) {
            values.push(obj[keys[i]]);
          }
          return values;
        },
        _functionJoin: function(resolvedArgs) {
          var joinChar = resolvedArgs[0];
          var listJoin = resolvedArgs[1];
          return listJoin.join(joinChar);
        },
        _functionToArray: function(resolvedArgs) {
          if (this._getTypeName(resolvedArgs[0]) === TYPE_ARRAY) {
            return resolvedArgs[0];
          } else {
            return [resolvedArgs[0]];
          }
        },
        _functionToString: function(resolvedArgs) {
          if (this._getTypeName(resolvedArgs[0]) === TYPE_STRING) {
            return resolvedArgs[0];
          } else {
            return JSON.stringify(resolvedArgs[0]);
          }
        },
        _functionToNumber: function(resolvedArgs) {
          var typeName = this._getTypeName(resolvedArgs[0]);
          var convertedValue;
          if (typeName === TYPE_NUMBER) {
            return resolvedArgs[0];
          } else if (typeName === TYPE_STRING) {
            convertedValue = +resolvedArgs[0];
            if (!isNaN(convertedValue)) {
              return convertedValue;
            }
          }
          return null;
        },
        _functionNotNull: function(resolvedArgs) {
          for (var i = 0; i < resolvedArgs.length; i++) {
            if (this._getTypeName(resolvedArgs[i]) !== TYPE_NULL) {
              return resolvedArgs[i];
            }
          }
          return null;
        },
        _functionSort: function(resolvedArgs) {
          var sortedArray = resolvedArgs[0].slice(0);
          sortedArray.sort();
          return sortedArray;
        },
        _functionSortBy: function(resolvedArgs) {
          var sortedArray = resolvedArgs[0].slice(0);
          if (sortedArray.length === 0) {
            return sortedArray;
          }
          var interpreter = this._interpreter;
          var exprefNode = resolvedArgs[1];
          var requiredType = this._getTypeName(
            interpreter.visit(exprefNode, sortedArray[0])
          );
          if ([TYPE_NUMBER, TYPE_STRING].indexOf(requiredType) < 0) {
            throw new Error("TypeError");
          }
          var that = this;
          var decorated = [];
          for (var i = 0; i < sortedArray.length; i++) {
            decorated.push([i, sortedArray[i]]);
          }
          decorated.sort(function(a, b) {
            var exprA = interpreter.visit(exprefNode, a[1]);
            var exprB = interpreter.visit(exprefNode, b[1]);
            if (that._getTypeName(exprA) !== requiredType) {
              throw new Error(
                "TypeError: expected " + requiredType + ", received " + that._getTypeName(exprA)
              );
            } else if (that._getTypeName(exprB) !== requiredType) {
              throw new Error(
                "TypeError: expected " + requiredType + ", received " + that._getTypeName(exprB)
              );
            }
            if (exprA > exprB) {
              return 1;
            } else if (exprA < exprB) {
              return -1;
            } else {
              return a[0] - b[0];
            }
          });
          for (var j = 0; j < decorated.length; j++) {
            sortedArray[j] = decorated[j][1];
          }
          return sortedArray;
        },
        _functionMaxBy: function(resolvedArgs) {
          var exprefNode = resolvedArgs[1];
          var resolvedArray = resolvedArgs[0];
          var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);
          var maxNumber = -Infinity;
          var maxRecord;
          var current;
          for (var i = 0; i < resolvedArray.length; i++) {
            current = keyFunction(resolvedArray[i]);
            if (current > maxNumber) {
              maxNumber = current;
              maxRecord = resolvedArray[i];
            }
          }
          return maxRecord;
        },
        _functionMinBy: function(resolvedArgs) {
          var exprefNode = resolvedArgs[1];
          var resolvedArray = resolvedArgs[0];
          var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);
          var minNumber = Infinity;
          var minRecord;
          var current;
          for (var i = 0; i < resolvedArray.length; i++) {
            current = keyFunction(resolvedArray[i]);
            if (current < minNumber) {
              minNumber = current;
              minRecord = resolvedArray[i];
            }
          }
          return minRecord;
        },
        createKeyFunction: function(exprefNode, allowedTypes) {
          var that = this;
          var interpreter = this._interpreter;
          var keyFunc = function(x) {
            var current = interpreter.visit(exprefNode, x);
            if (allowedTypes.indexOf(that._getTypeName(current)) < 0) {
              var msg = "TypeError: expected one of " + allowedTypes + ", received " + that._getTypeName(current);
              throw new Error(msg);
            }
            return current;
          };
          return keyFunc;
        }
      };
      function compile(stream) {
        var parser = new Parser();
        var ast = parser.parse(stream);
        return ast;
      }
      function tokenize(stream) {
        var lexer = new Lexer();
        return lexer.tokenize(stream);
      }
      function search(data, expression) {
        var parser = new Parser();
        var runtime = new Runtime();
        var interpreter = new TreeInterpreter(runtime);
        runtime._interpreter = interpreter;
        var node = parser.parse(expression);
        return interpreter.search(node, data);
      }
      exports2.tokenize = tokenize;
      exports2.compile = compile;
      exports2.search = search;
      exports2.strictDeepEqual = strictDeepEqual;
    })(typeof exports === "undefined" ? exports.jmespath = {} : exports);
  }
});

// node_modules/pino-pretty/lib/constants.js
var require_constants = __commonJS({
  "node_modules/pino-pretty/lib/constants.js"(exports, module2) {
    "use strict";
    module2.exports = {
      DATE_FORMAT: "yyyy-mm-dd HH:MM:ss.l o",
      ERROR_LIKE_KEYS: ["err", "error"],
      MESSAGE_KEY: "msg",
      LEVEL_KEY: "level",
      LEVEL_LABEL: "levelLabel",
      TIMESTAMP_KEY: "time",
      LEVELS: {
        default: "USERLVL",
        60: "FATAL",
        50: "ERROR",
        40: "WARN",
        30: "INFO",
        20: "DEBUG",
        10: "TRACE"
      },
      LEVEL_NAMES: {
        fatal: 60,
        error: 50,
        warn: 40,
        info: 30,
        debug: 20,
        trace: 10
      },
      LOGGER_KEYS: [
        "pid",
        "hostname",
        "name",
        "level",
        "time",
        "timestamp",
        "caller"
      ]
    };
  }
});

// node_modules/pino-pretty/lib/colors.js
var require_colors = __commonJS({
  "node_modules/pino-pretty/lib/colors.js"(exports, module2) {
    "use strict";
    var { LEVELS, LEVEL_NAMES } = require_constants();
    var nocolor = (input) => input;
    var plain = {
      default: nocolor,
      60: nocolor,
      50: nocolor,
      40: nocolor,
      30: nocolor,
      20: nocolor,
      10: nocolor,
      message: nocolor,
      greyMessage: nocolor
    };
    var chalk = require_source();
    var ctx = new chalk.Instance({ level: 3 });
    var colored = {
      default: ctx.white,
      60: ctx.bgRed,
      50: ctx.red,
      40: ctx.yellow,
      30: ctx.green,
      20: ctx.blue,
      10: ctx.grey,
      message: ctx.cyan,
      greyMessage: ctx.grey
    };
    function colorizeLevel(level, colorizer) {
      if (Number.isInteger(+level)) {
        return Object.prototype.hasOwnProperty.call(LEVELS, level) ? colorizer[level](LEVELS[level]) : colorizer.default(LEVELS.default);
      }
      const levelNum = LEVEL_NAMES[level.toLowerCase()] || "default";
      return colorizer[levelNum](LEVELS[levelNum]);
    }
    function plainColorizer(level) {
      return colorizeLevel(level, plain);
    }
    plainColorizer.message = plain.message;
    plainColorizer.greyMessage = plain.greyMessage;
    function coloredColorizer(level) {
      return colorizeLevel(level, colored);
    }
    coloredColorizer.message = colored.message;
    coloredColorizer.greyMessage = colored.greyMessage;
    module2.exports = function getColorizer(useColors = false) {
      return useColors ? coloredColorizer : plainColorizer;
    };
  }
});

// node_modules/rfdc/index.js
var require_rfdc = __commonJS({
  "node_modules/rfdc/index.js"(exports, module2) {
    "use strict";
    module2.exports = rfdc;
    function copyBuffer(cur) {
      if (cur instanceof Buffer) {
        return Buffer.from(cur);
      }
      return new cur.constructor(cur.buffer.slice(), cur.byteOffset, cur.length);
    }
    function rfdc(opts) {
      opts = opts || {};
      if (opts.circles)
        return rfdcCircles(opts);
      return opts.proto ? cloneProto : clone;
      function cloneArray(a, fn) {
        var keys = Object.keys(a);
        var a2 = new Array(keys.length);
        for (var i = 0; i < keys.length; i++) {
          var k = keys[i];
          var cur = a[k];
          if (typeof cur !== "object" || cur === null) {
            a2[k] = cur;
          } else if (cur instanceof Date) {
            a2[k] = new Date(cur);
          } else if (ArrayBuffer.isView(cur)) {
            a2[k] = copyBuffer(cur);
          } else {
            a2[k] = fn(cur);
          }
        }
        return a2;
      }
      function clone(o) {
        if (typeof o !== "object" || o === null)
          return o;
        if (o instanceof Date)
          return new Date(o);
        if (Array.isArray(o))
          return cloneArray(o, clone);
        if (o instanceof Map)
          return new Map(cloneArray(Array.from(o), clone));
        if (o instanceof Set)
          return new Set(cloneArray(Array.from(o), clone));
        var o2 = {};
        for (var k in o) {
          if (Object.hasOwnProperty.call(o, k) === false)
            continue;
          var cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur instanceof Date) {
            o2[k] = new Date(cur);
          } else if (cur instanceof Map) {
            o2[k] = new Map(cloneArray(Array.from(cur), clone));
          } else if (cur instanceof Set) {
            o2[k] = new Set(cloneArray(Array.from(cur), clone));
          } else if (ArrayBuffer.isView(cur)) {
            o2[k] = copyBuffer(cur);
          } else {
            o2[k] = clone(cur);
          }
        }
        return o2;
      }
      function cloneProto(o) {
        if (typeof o !== "object" || o === null)
          return o;
        if (o instanceof Date)
          return new Date(o);
        if (Array.isArray(o))
          return cloneArray(o, cloneProto);
        if (o instanceof Map)
          return new Map(cloneArray(Array.from(o), cloneProto));
        if (o instanceof Set)
          return new Set(cloneArray(Array.from(o), cloneProto));
        var o2 = {};
        for (var k in o) {
          var cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur instanceof Date) {
            o2[k] = new Date(cur);
          } else if (cur instanceof Map) {
            o2[k] = new Map(cloneArray(Array.from(cur), cloneProto));
          } else if (cur instanceof Set) {
            o2[k] = new Set(cloneArray(Array.from(cur), cloneProto));
          } else if (ArrayBuffer.isView(cur)) {
            o2[k] = copyBuffer(cur);
          } else {
            o2[k] = cloneProto(cur);
          }
        }
        return o2;
      }
    }
    function rfdcCircles(opts) {
      var refs = [];
      var refsNew = [];
      return opts.proto ? cloneProto : clone;
      function cloneArray(a, fn) {
        var keys = Object.keys(a);
        var a2 = new Array(keys.length);
        for (var i = 0; i < keys.length; i++) {
          var k = keys[i];
          var cur = a[k];
          if (typeof cur !== "object" || cur === null) {
            a2[k] = cur;
          } else if (cur instanceof Date) {
            a2[k] = new Date(cur);
          } else if (ArrayBuffer.isView(cur)) {
            a2[k] = copyBuffer(cur);
          } else {
            var index = refs.indexOf(cur);
            if (index !== -1) {
              a2[k] = refsNew[index];
            } else {
              a2[k] = fn(cur);
            }
          }
        }
        return a2;
      }
      function clone(o) {
        if (typeof o !== "object" || o === null)
          return o;
        if (o instanceof Date)
          return new Date(o);
        if (Array.isArray(o))
          return cloneArray(o, clone);
        if (o instanceof Map)
          return new Map(cloneArray(Array.from(o), clone));
        if (o instanceof Set)
          return new Set(cloneArray(Array.from(o), clone));
        var o2 = {};
        refs.push(o);
        refsNew.push(o2);
        for (var k in o) {
          if (Object.hasOwnProperty.call(o, k) === false)
            continue;
          var cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur instanceof Date) {
            o2[k] = new Date(cur);
          } else if (cur instanceof Map) {
            o2[k] = new Map(cloneArray(Array.from(cur), clone));
          } else if (cur instanceof Set) {
            o2[k] = new Set(cloneArray(Array.from(cur), clone));
          } else if (ArrayBuffer.isView(cur)) {
            o2[k] = copyBuffer(cur);
          } else {
            var i = refs.indexOf(cur);
            if (i !== -1) {
              o2[k] = refsNew[i];
            } else {
              o2[k] = clone(cur);
            }
          }
        }
        refs.pop();
        refsNew.pop();
        return o2;
      }
      function cloneProto(o) {
        if (typeof o !== "object" || o === null)
          return o;
        if (o instanceof Date)
          return new Date(o);
        if (Array.isArray(o))
          return cloneArray(o, cloneProto);
        if (o instanceof Map)
          return new Map(cloneArray(Array.from(o), cloneProto));
        if (o instanceof Set)
          return new Set(cloneArray(Array.from(o), cloneProto));
        var o2 = {};
        refs.push(o);
        refsNew.push(o2);
        for (var k in o) {
          var cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur instanceof Date) {
            o2[k] = new Date(cur);
          } else if (cur instanceof Map) {
            o2[k] = new Map(cloneArray(Array.from(cur), cloneProto));
          } else if (cur instanceof Set) {
            o2[k] = new Set(cloneArray(Array.from(cur), cloneProto));
          } else if (ArrayBuffer.isView(cur)) {
            o2[k] = copyBuffer(cur);
          } else {
            var i = refs.indexOf(cur);
            if (i !== -1) {
              o2[k] = refsNew[i];
            } else {
              o2[k] = cloneProto(cur);
            }
          }
        }
        refs.pop();
        refsNew.pop();
        return o2;
      }
    }
  }
});

// node_modules/dateformat/lib/dateformat.js
var require_dateformat = __commonJS({
  "node_modules/dateformat/lib/dateformat.js"(exports, module2) {
    "use strict";
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    (function(global) {
      var _arguments = arguments;
      var dateFormat = function() {
        var token = /d{1,4}|D{3,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|W{1,2}|[LlopSZN]|"[^"]*"|'[^']*'/g;
        var timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g;
        var timezoneClip = /[^-+\dA-Z]/g;
        return function(date, mask, utc, gmt) {
          if (_arguments.length === 1 && kindOf(date) === "string" && !/\d/.test(date)) {
            mask = date;
            date = void 0;
          }
          date = date || date === 0 ? date : new Date();
          if (!(date instanceof Date)) {
            date = new Date(date);
          }
          if (isNaN(date)) {
            throw TypeError("Invalid date");
          }
          mask = String(dateFormat.masks[mask] || mask || dateFormat.masks["default"]);
          var maskSlice = mask.slice(0, 4);
          if (maskSlice === "UTC:" || maskSlice === "GMT:") {
            mask = mask.slice(4);
            utc = true;
            if (maskSlice === "GMT:") {
              gmt = true;
            }
          }
          var _ = function _2() {
            return utc ? "getUTC" : "get";
          };
          var _d = function d() {
            return date[_() + "Date"]();
          };
          var D = function D2() {
            return date[_() + "Day"]();
          };
          var _m = function m() {
            return date[_() + "Month"]();
          };
          var y = function y2() {
            return date[_() + "FullYear"]();
          };
          var _H = function H() {
            return date[_() + "Hours"]();
          };
          var _M = function M() {
            return date[_() + "Minutes"]();
          };
          var _s = function s() {
            return date[_() + "Seconds"]();
          };
          var _L = function L() {
            return date[_() + "Milliseconds"]();
          };
          var _o = function o() {
            return utc ? 0 : date.getTimezoneOffset();
          };
          var _W = function W() {
            return getWeek(date);
          };
          var _N = function N() {
            return getDayOfWeek(date);
          };
          var flags = { d: function d() {
            return _d();
          }, dd: function dd() {
            return pad(_d());
          }, ddd: function ddd() {
            return dateFormat.i18n.dayNames[D()];
          }, DDD: function DDD() {
            return getDayName({ y: y(), m: _m(), d: _d(), _: _(), dayName: dateFormat.i18n.dayNames[D()], short: true });
          }, dddd: function dddd() {
            return dateFormat.i18n.dayNames[D() + 7];
          }, DDDD: function DDDD() {
            return getDayName({ y: y(), m: _m(), d: _d(), _: _(), dayName: dateFormat.i18n.dayNames[D() + 7] });
          }, m: function m() {
            return _m() + 1;
          }, mm: function mm() {
            return pad(_m() + 1);
          }, mmm: function mmm() {
            return dateFormat.i18n.monthNames[_m()];
          }, mmmm: function mmmm() {
            return dateFormat.i18n.monthNames[_m() + 12];
          }, yy: function yy() {
            return String(y()).slice(2);
          }, yyyy: function yyyy() {
            return pad(y(), 4);
          }, h: function h() {
            return _H() % 12 || 12;
          }, hh: function hh() {
            return pad(_H() % 12 || 12);
          }, H: function H() {
            return _H();
          }, HH: function HH() {
            return pad(_H());
          }, M: function M() {
            return _M();
          }, MM: function MM() {
            return pad(_M());
          }, s: function s() {
            return _s();
          }, ss: function ss() {
            return pad(_s());
          }, l: function l() {
            return pad(_L(), 3);
          }, L: function L() {
            return pad(Math.floor(_L() / 10));
          }, t: function t() {
            return _H() < 12 ? dateFormat.i18n.timeNames[0] : dateFormat.i18n.timeNames[1];
          }, tt: function tt() {
            return _H() < 12 ? dateFormat.i18n.timeNames[2] : dateFormat.i18n.timeNames[3];
          }, T: function T() {
            return _H() < 12 ? dateFormat.i18n.timeNames[4] : dateFormat.i18n.timeNames[5];
          }, TT: function TT() {
            return _H() < 12 ? dateFormat.i18n.timeNames[6] : dateFormat.i18n.timeNames[7];
          }, Z: function Z() {
            return gmt ? "GMT" : utc ? "UTC" : (String(date).match(timezone) || [""]).pop().replace(timezoneClip, "").replace(/GMT\+0000/g, "UTC");
          }, o: function o() {
            return (_o() > 0 ? "-" : "+") + pad(Math.floor(Math.abs(_o()) / 60) * 100 + Math.abs(_o()) % 60, 4);
          }, p: function p() {
            return (_o() > 0 ? "-" : "+") + pad(Math.floor(Math.abs(_o()) / 60), 2) + ":" + pad(Math.floor(Math.abs(_o()) % 60), 2);
          }, S: function S() {
            return ["th", "st", "nd", "rd"][_d() % 10 > 3 ? 0 : (_d() % 100 - _d() % 10 != 10) * _d() % 10];
          }, W: function W() {
            return _W();
          }, WW: function WW() {
            return pad(_W());
          }, N: function N() {
            return _N();
          } };
          return mask.replace(token, function(match) {
            if (match in flags) {
              return flags[match]();
            }
            return match.slice(1, match.length - 1);
          });
        };
      }();
      dateFormat.masks = { default: "ddd mmm dd yyyy HH:MM:ss", shortDate: "m/d/yy", paddedShortDate: "mm/dd/yyyy", mediumDate: "mmm d, yyyy", longDate: "mmmm d, yyyy", fullDate: "dddd, mmmm d, yyyy", shortTime: "h:MM TT", mediumTime: "h:MM:ss TT", longTime: "h:MM:ss TT Z", isoDate: "yyyy-mm-dd", isoTime: "HH:MM:ss", isoDateTime: "yyyy-mm-dd'T'HH:MM:sso", isoUtcDateTime: "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'", expiresHeaderFormat: "ddd, dd mmm yyyy HH:MM:ss Z" };
      dateFormat.i18n = { dayNames: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], monthNames: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], timeNames: ["a", "p", "am", "pm", "A", "P", "AM", "PM"] };
      var pad = function pad2(val, len) {
        val = String(val);
        len = len || 2;
        while (val.length < len) {
          val = "0" + val;
        }
        return val;
      };
      var getDayName = function getDayName2(_ref) {
        var y = _ref.y, m = _ref.m, d = _ref.d, _ = _ref._, dayName = _ref.dayName, _ref$short = _ref["short"], _short = _ref$short === void 0 ? false : _ref$short;
        var today = new Date();
        var yesterday = new Date();
        yesterday.setDate(yesterday[_ + "Date"]() - 1);
        var tomorrow = new Date();
        tomorrow.setDate(tomorrow[_ + "Date"]() + 1);
        var today_d = function today_d2() {
          return today[_ + "Date"]();
        };
        var today_m = function today_m2() {
          return today[_ + "Month"]();
        };
        var today_y = function today_y2() {
          return today[_ + "FullYear"]();
        };
        var yesterday_d = function yesterday_d2() {
          return yesterday[_ + "Date"]();
        };
        var yesterday_m = function yesterday_m2() {
          return yesterday[_ + "Month"]();
        };
        var yesterday_y = function yesterday_y2() {
          return yesterday[_ + "FullYear"]();
        };
        var tomorrow_d = function tomorrow_d2() {
          return tomorrow[_ + "Date"]();
        };
        var tomorrow_m = function tomorrow_m2() {
          return tomorrow[_ + "Month"]();
        };
        var tomorrow_y = function tomorrow_y2() {
          return tomorrow[_ + "FullYear"]();
        };
        if (today_y() === y && today_m() === m && today_d() === d) {
          return _short ? "Tdy" : "Today";
        } else if (yesterday_y() === y && yesterday_m() === m && yesterday_d() === d) {
          return _short ? "Ysd" : "Yesterday";
        } else if (tomorrow_y() === y && tomorrow_m() === m && tomorrow_d() === d) {
          return _short ? "Tmw" : "Tomorrow";
        }
        return dayName;
      };
      var getWeek = function getWeek2(date) {
        var targetThursday = new Date(date.getFullYear(), date.getMonth(), date.getDate());
        targetThursday.setDate(targetThursday.getDate() - (targetThursday.getDay() + 6) % 7 + 3);
        var firstThursday = new Date(targetThursday.getFullYear(), 0, 4);
        firstThursday.setDate(firstThursday.getDate() - (firstThursday.getDay() + 6) % 7 + 3);
        var ds = targetThursday.getTimezoneOffset() - firstThursday.getTimezoneOffset();
        targetThursday.setHours(targetThursday.getHours() - ds);
        var weekDiff = (targetThursday - firstThursday) / (864e5 * 7);
        return 1 + Math.floor(weekDiff);
      };
      var getDayOfWeek = function getDayOfWeek2(date) {
        var dow = date.getDay();
        if (dow === 0) {
          dow = 7;
        }
        return dow;
      };
      var kindOf = function kindOf2(val) {
        if (val === null) {
          return "null";
        }
        if (val === void 0) {
          return "undefined";
        }
        if (_typeof(val) !== "object") {
          return _typeof(val);
        }
        if (Array.isArray(val)) {
          return "array";
        }
        return {}.toString.call(val).slice(8, -1).toLowerCase();
      };
      if (typeof define === "function" && define.amd) {
        define(function() {
          return dateFormat;
        });
      } else if ((typeof exports === "undefined" ? "undefined" : _typeof(exports)) === "object") {
        module2.exports = dateFormat;
      } else {
        global.dateFormat = dateFormat;
      }
    })(void 0);
  }
});

// node_modules/pino-pretty/lib/utils.js
var require_utils = __commonJS({
  "node_modules/pino-pretty/lib/utils.js"(exports, module2) {
    "use strict";
    var clone = require_rfdc()();
    var dateformat = require_dateformat();
    var stringifySafe = require_fast_safe_stringify();
    var defaultColorizer = require_colors()();
    var {
      DATE_FORMAT,
      ERROR_LIKE_KEYS,
      MESSAGE_KEY,
      LEVEL_KEY,
      LEVEL_LABEL,
      TIMESTAMP_KEY,
      LOGGER_KEYS,
      LEVELS
    } = require_constants();
    module2.exports = {
      isObject,
      prettifyErrorLog,
      prettifyLevel,
      prettifyMessage,
      prettifyMetadata,
      prettifyObject,
      prettifyTime,
      filterLog
    };
    module2.exports.internals = {
      formatTime,
      joinLinesWithIndentation,
      prettifyError,
      deleteLogProperty
    };
    function formatTime(epoch, translateTime = false) {
      if (translateTime === false) {
        return epoch;
      }
      const instant = new Date(epoch);
      if (translateTime === true) {
        return dateformat(instant, "UTC:" + DATE_FORMAT);
      }
      const upperFormat = translateTime.toUpperCase();
      if (upperFormat === "SYS:STANDARD") {
        return dateformat(instant, DATE_FORMAT);
      }
      const prefix = upperFormat.substr(0, 4);
      if (prefix === "SYS:" || prefix === "UTC:") {
        if (prefix === "UTC:") {
          return dateformat(instant, translateTime);
        }
        return dateformat(instant, translateTime.slice(4));
      }
      return dateformat(instant, `UTC:${translateTime}`);
    }
    function isObject(input) {
      return Object.prototype.toString.apply(input) === "[object Object]";
    }
    function joinLinesWithIndentation({ input, ident = "    ", eol = "\n" }) {
      const lines = input.split(/\r?\n/);
      for (let i = 1; i < lines.length; i += 1) {
        lines[i] = ident + lines[i];
      }
      return lines.join(eol);
    }
    function prettifyErrorLog({
      log,
      messageKey = MESSAGE_KEY,
      ident = "    ",
      eol = "\n",
      errorLikeKeys = ERROR_LIKE_KEYS,
      errorProperties = []
    }) {
      const stack = log.stack;
      const joinedLines = joinLinesWithIndentation({ input: stack, ident, eol });
      let result = `${ident}${joinedLines}${eol}`;
      if (errorProperties.length > 0) {
        const excludeProperties = LOGGER_KEYS.concat(messageKey, "type", "stack");
        let propertiesToPrint;
        if (errorProperties[0] === "*") {
          propertiesToPrint = Object.keys(log).filter((k) => excludeProperties.includes(k) === false);
        } else {
          propertiesToPrint = errorProperties.filter((k) => excludeProperties.includes(k) === false);
        }
        for (let i = 0; i < propertiesToPrint.length; i += 1) {
          const key = propertiesToPrint[i];
          if (key in log === false)
            continue;
          if (isObject(log[key])) {
            const prettifiedObject = prettifyObject({ input: log[key], errorLikeKeys, excludeLoggerKeys: false, eol, ident });
            result = `${result}${key}: {${eol}${prettifiedObject}}${eol}`;
            continue;
          }
          result = `${result}${key}: ${log[key]}${eol}`;
        }
      }
      return result;
    }
    function prettifyLevel({ log, colorizer = defaultColorizer, levelKey = LEVEL_KEY }) {
      if (levelKey in log === false)
        return void 0;
      return colorizer(log[levelKey]);
    }
    function prettifyMessage({ log, messageFormat, messageKey = MESSAGE_KEY, colorizer = defaultColorizer, levelLabel = LEVEL_LABEL }) {
      if (messageFormat && typeof messageFormat === "string") {
        const message = String(messageFormat).replace(/{([^{}]+)}/g, function(match, p1) {
          if (p1 === levelLabel && log[LEVEL_KEY]) {
            return LEVELS[log[LEVEL_KEY]];
          }
          return p1.split(".").reduce(function(prev, curr) {
            if (prev && prev[curr]) {
              return prev[curr];
            }
            return "";
          }, log);
        });
        return colorizer.message(message);
      }
      if (messageFormat && typeof messageFormat === "function") {
        const msg = messageFormat(log, messageKey, levelLabel);
        return colorizer.message(msg);
      }
      if (messageKey in log === false)
        return void 0;
      if (typeof log[messageKey] !== "string")
        return void 0;
      return colorizer.message(log[messageKey]);
    }
    function prettifyMetadata({ log }) {
      let line = "";
      if (log.name || log.pid || log.hostname) {
        line += "(";
        if (log.name) {
          line += log.name;
        }
        if (log.name && log.pid) {
          line += "/" + log.pid;
        } else if (log.pid) {
          line += log.pid;
        }
        if (log.hostname) {
          line += `${line === "(" ? "on" : " on"} ${log.hostname}`;
        }
        line += ")";
      }
      if (log.caller) {
        line += `${line === "" ? "" : " "}<${log.caller}>`;
      }
      if (line === "") {
        return void 0;
      } else {
        return line;
      }
    }
    function prettifyObject({
      input,
      ident = "    ",
      eol = "\n",
      skipKeys = [],
      customPrettifiers = {},
      errorLikeKeys = ERROR_LIKE_KEYS,
      excludeLoggerKeys = true,
      singleLine = false,
      colorizer = defaultColorizer
    }) {
      const keysToIgnore = [].concat(skipKeys);
      if (excludeLoggerKeys === true)
        Array.prototype.push.apply(keysToIgnore, LOGGER_KEYS);
      let result = "";
      const { plain, errors } = Object.entries(input).reduce(({ plain: plain2, errors: errors2 }, [k, v]) => {
        if (keysToIgnore.includes(k) === false) {
          const pretty = typeof customPrettifiers[k] === "function" ? customPrettifiers[k](v, k, input) : v;
          if (errorLikeKeys.includes(k)) {
            errors2[k] = pretty;
          } else {
            plain2[k] = pretty;
          }
        }
        return { plain: plain2, errors: errors2 };
      }, { plain: {}, errors: {} });
      if (singleLine) {
        if (Object.keys(plain).length > 0) {
          result += colorizer.greyMessage(stringifySafe(plain));
        }
        result += eol;
      } else {
        Object.entries(plain).forEach(([keyName, keyValue]) => {
          const lines = typeof customPrettifiers[keyName] === "function" ? keyValue : stringifySafe(keyValue, null, 2);
          if (lines === void 0)
            return;
          const joinedLines = joinLinesWithIndentation({ input: lines, ident, eol });
          result += `${ident}${keyName}: ${joinedLines}${eol}`;
        });
      }
      Object.entries(errors).forEach(([keyName, keyValue]) => {
        const lines = typeof customPrettifiers[keyName] === "function" ? keyValue : stringifySafe(keyValue, null, 2);
        if (lines === void 0)
          return;
        result += prettifyError({ keyName, lines, eol, ident });
      });
      return result;
    }
    function prettifyTime({ log, timestampKey = TIMESTAMP_KEY, translateFormat = void 0 }) {
      let time = null;
      if (timestampKey in log) {
        time = log[timestampKey];
      } else if ("timestamp" in log) {
        time = log.timestamp;
      }
      if (time === null)
        return void 0;
      if (translateFormat) {
        return "[" + formatTime(time, translateFormat) + "]";
      }
      return `[${time}]`;
    }
    function prettifyError({ keyName, lines, eol, ident }) {
      let result = "";
      const joinedLines = joinLinesWithIndentation({ input: lines, ident, eol });
      const splitLines = `${ident}${keyName}: ${joinedLines}${eol}`.split(eol);
      for (let j = 0; j < splitLines.length; j += 1) {
        if (j !== 0)
          result += eol;
        const line = splitLines[j];
        if (/^\s*"stack"/.test(line)) {
          const matches = /^(\s*"stack":)\s*(".*"),?$/.exec(line);
          if (matches && matches.length === 3) {
            const indentSize = /^\s*/.exec(line)[0].length + 4;
            const indentation = " ".repeat(indentSize);
            const stackMessage = matches[2];
            result += matches[1] + eol + indentation + JSON.parse(stackMessage).replace(/\n/g, eol + indentation);
          }
        } else {
          result += line;
        }
      }
      return result;
    }
    function deleteLogProperty(log, property) {
      const props = property.split(".");
      const propToDelete = props.pop();
      props.forEach((prop) => {
        if (!Object.prototype.hasOwnProperty.call(log, prop)) {
          return;
        }
        log = log[prop];
      });
      delete log[propToDelete];
    }
    function filterLog(log, ignoreKeys) {
      const logCopy = clone(log);
      ignoreKeys.forEach((ignoreKey) => {
        deleteLogProperty(logCopy, ignoreKey);
      });
      return logCopy;
    }
  }
});

// node_modules/@hapi/bourne/lib/index.js
var require_lib = __commonJS({
  "node_modules/@hapi/bourne/lib/index.js"(exports) {
    "use strict";
    var internals = {
      suspectRx: /"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*\:/
    };
    exports.parse = function(text, ...args) {
      const firstOptions = typeof args[0] === "object" && args[0];
      const reviver = args.length > 1 || !firstOptions ? args[0] : void 0;
      const options = args.length > 1 && args[1] || firstOptions || {};
      const obj = JSON.parse(text, reviver);
      if (options.protoAction === "ignore") {
        return obj;
      }
      if (!obj || typeof obj !== "object") {
        return obj;
      }
      if (!text.match(internals.suspectRx)) {
        return obj;
      }
      exports.scan(obj, options);
      return obj;
    };
    exports.scan = function(obj, options = {}) {
      let next = [obj];
      while (next.length) {
        const nodes = next;
        next = [];
        for (const node of nodes) {
          if (Object.prototype.hasOwnProperty.call(node, "__proto__")) {
            if (options.protoAction !== "remove") {
              throw new SyntaxError("Object contains forbidden prototype property");
            }
            delete node.__proto__;
          }
          for (const key in node) {
            const value = node[key];
            if (value && typeof value === "object") {
              next.push(node[key]);
            }
          }
        }
      }
    };
    exports.safeParse = function(text, reviver) {
      try {
        return exports.parse(text, reviver);
      } catch (ignoreError) {
        return null;
      }
    };
  }
});

// node_modules/pino-pretty/index.js
var require_pino_pretty = __commonJS({
  "node_modules/pino-pretty/index.js"(exports, module2) {
    "use strict";
    var chalk = require_source();
    var jmespath = require_jmespath();
    var colors = require_colors();
    var { ERROR_LIKE_KEYS, MESSAGE_KEY, TIMESTAMP_KEY } = require_constants();
    var {
      isObject,
      prettifyErrorLog,
      prettifyLevel,
      prettifyMessage,
      prettifyMetadata,
      prettifyObject,
      prettifyTime,
      filterLog
    } = require_utils();
    var bourne = require_lib();
    var jsonParser = (input) => {
      try {
        return { value: bourne.parse(input, { protoAction: "remove" }) };
      } catch (err) {
        return { err };
      }
    };
    var defaultOptions = {
      colorize: chalk.supportsColor,
      crlf: false,
      errorLikeObjectKeys: ERROR_LIKE_KEYS,
      errorProps: "",
      levelFirst: false,
      messageKey: MESSAGE_KEY,
      messageFormat: false,
      timestampKey: TIMESTAMP_KEY,
      translateTime: false,
      useMetadata: false,
      outputStream: process.stdout,
      customPrettifiers: {},
      hideObject: false,
      singleLine: false
    };
    module2.exports = function prettyFactory(options) {
      const opts = Object.assign({}, defaultOptions, options);
      const EOL = opts.crlf ? "\r\n" : "\n";
      const IDENT = "    ";
      const messageKey = opts.messageKey;
      const levelKey = opts.levelKey;
      const levelLabel = opts.levelLabel;
      const messageFormat = opts.messageFormat;
      const timestampKey = opts.timestampKey;
      const errorLikeObjectKeys = opts.errorLikeObjectKeys;
      const errorProps = opts.errorProps.split(",");
      const customPrettifiers = opts.customPrettifiers;
      const ignoreKeys = opts.ignore ? new Set(opts.ignore.split(",")) : void 0;
      const hideObject = opts.hideObject;
      const singleLine = opts.singleLine;
      const colorizer = colors(opts.colorize);
      const search = opts.search;
      return pretty;
      function pretty(inputData) {
        let log;
        if (!isObject(inputData)) {
          const parsed = jsonParser(inputData);
          if (parsed.err || !isObject(parsed.value)) {
            return inputData + EOL;
          }
          log = parsed.value;
        } else {
          log = inputData;
        }
        if (search && !jmespath.search(log, search)) {
          return;
        }
        const prettifiedMessage = prettifyMessage({ log, messageKey, colorizer, messageFormat, levelLabel });
        if (ignoreKeys) {
          log = filterLog(log, ignoreKeys);
        }
        const prettifiedLevel = prettifyLevel({ log, colorizer, levelKey });
        const prettifiedMetadata = prettifyMetadata({ log });
        const prettifiedTime = prettifyTime({ log, translateFormat: opts.translateTime, timestampKey });
        let line = "";
        if (opts.levelFirst && prettifiedLevel) {
          line = `${prettifiedLevel}`;
        }
        if (prettifiedTime && line === "") {
          line = `${prettifiedTime}`;
        } else if (prettifiedTime) {
          line = `${line} ${prettifiedTime}`;
        }
        if (!opts.levelFirst && prettifiedLevel) {
          if (line.length > 0) {
            line = `${line} ${prettifiedLevel}`;
          } else {
            line = prettifiedLevel;
          }
        }
        if (prettifiedMetadata) {
          if (line.length > 0) {
            line = `${line} ${prettifiedMetadata}:`;
          } else {
            line = prettifiedMetadata;
          }
        }
        if (line.endsWith(":") === false && line !== "") {
          line += ":";
        }
        if (prettifiedMessage) {
          if (line.length > 0) {
            line = `${line} ${prettifiedMessage}`;
          } else {
            line = prettifiedMessage;
          }
        }
        if (line.length > 0 && !singleLine) {
          line += EOL;
        }
        if (log.type === "Error" && log.stack) {
          const prettifiedErrorLog = prettifyErrorLog({
            log,
            errorLikeKeys: errorLikeObjectKeys,
            errorProperties: errorProps,
            ident: IDENT,
            eol: EOL
          });
          line += prettifiedErrorLog;
        } else if (!hideObject) {
          const skipKeys = [messageKey, levelKey, timestampKey].filter((key) => typeof log[key] === "string" || typeof log[key] === "number");
          const prettifiedObject = prettifyObject({
            input: log,
            skipKeys,
            customPrettifiers,
            errorLikeKeys: errorLikeObjectKeys,
            eol: EOL,
            ident: IDENT,
            singleLine,
            colorizer
          });
          if (singleLine && !/^\s$/.test(prettifiedObject)) {
            line += " ";
          }
          line += prettifiedObject;
        }
        return line;
      }
    };
  }
});

// node_modules/pino/lib/tools.js
var require_tools = __commonJS({
  "node_modules/pino/lib/tools.js"(exports, module2) {
    "use strict";
    var format = require_quick_format_unescaped();
    var { mapHttpRequest, mapHttpResponse } = require_pino_std_serializers();
    var SonicBoom = require_sonic_boom();
    var stringifySafe = require_fast_safe_stringify();
    var {
      lsCacheSym,
      chindingsSym,
      parsedChindingsSym,
      writeSym,
      serializersSym,
      formatOptsSym,
      endSym,
      stringifiersSym,
      stringifySym,
      wildcardFirstSym,
      needsMetadataGsym,
      redactFmtSym,
      streamSym,
      nestedKeySym,
      formattersSym,
      messageKeySym
    } = require_symbols();
    function noop() {
    }
    function genLog(level, hook) {
      if (!hook)
        return LOG;
      return function hookWrappedLog(...args) {
        hook.call(this, args, LOG, level);
      };
      function LOG(o, ...n) {
        if (typeof o === "object") {
          let msg = o;
          if (o !== null) {
            if (o.method && o.headers && o.socket) {
              o = mapHttpRequest(o);
            } else if (typeof o.setHeader === "function") {
              o = mapHttpResponse(o);
            }
          }
          if (this[nestedKeySym])
            o = { [this[nestedKeySym]]: o };
          let formatParams;
          if (msg === null && n.length === 0) {
            formatParams = [null];
          } else {
            msg = n.shift();
            formatParams = n;
          }
          this[writeSym](o, format(msg, formatParams, this[formatOptsSym]), level);
        } else {
          this[writeSym](null, format(o, n, this[formatOptsSym]), level);
        }
      }
    }
    function asString(str) {
      let result = "";
      let last = 0;
      let found = false;
      let point = 255;
      const l = str.length;
      if (l > 100) {
        return JSON.stringify(str);
      }
      for (var i = 0; i < l && point >= 32; i++) {
        point = str.charCodeAt(i);
        if (point === 34 || point === 92) {
          result += str.slice(last, i) + "\\";
          last = i;
          found = true;
        }
      }
      if (!found) {
        result = str;
      } else {
        result += str.slice(last);
      }
      return point < 32 ? JSON.stringify(str) : '"' + result + '"';
    }
    function asJson(obj, msg, num, time) {
      const stringify2 = this[stringifySym];
      const stringifiers = this[stringifiersSym];
      const end = this[endSym];
      const chindings = this[chindingsSym];
      const serializers = this[serializersSym];
      const formatters = this[formattersSym];
      const messageKey = this[messageKeySym];
      let data = this[lsCacheSym][num] + time;
      data = data + chindings;
      let value;
      const notHasOwnProperty = obj.hasOwnProperty === void 0;
      if (formatters.log) {
        obj = formatters.log(obj);
      }
      if (msg !== void 0) {
        obj[messageKey] = msg;
      }
      const wildcardStringifier = stringifiers[wildcardFirstSym];
      for (const key in obj) {
        value = obj[key];
        if ((notHasOwnProperty || obj.hasOwnProperty(key)) && value !== void 0) {
          value = serializers[key] ? serializers[key](value) : value;
          const stringifier = stringifiers[key] || wildcardStringifier;
          switch (typeof value) {
            case "undefined":
            case "function":
              continue;
            case "number":
              if (Number.isFinite(value) === false) {
                value = null;
              }
            case "boolean":
              if (stringifier)
                value = stringifier(value);
              break;
            case "string":
              value = (stringifier || asString)(value);
              break;
            default:
              value = (stringifier || stringify2)(value);
          }
          if (value === void 0)
            continue;
          data += ',"' + key + '":' + value;
        }
      }
      return data + end;
    }
    function asChindings(instance, bindings) {
      let value;
      let data = instance[chindingsSym];
      const stringify2 = instance[stringifySym];
      const stringifiers = instance[stringifiersSym];
      const wildcardStringifier = stringifiers[wildcardFirstSym];
      const serializers = instance[serializersSym];
      const formatter = instance[formattersSym].bindings;
      bindings = formatter(bindings);
      for (const key in bindings) {
        value = bindings[key];
        const valid = key !== "level" && key !== "serializers" && key !== "formatters" && key !== "customLevels" && bindings.hasOwnProperty(key) && value !== void 0;
        if (valid === true) {
          value = serializers[key] ? serializers[key](value) : value;
          value = (stringifiers[key] || wildcardStringifier || stringify2)(value);
          if (value === void 0)
            continue;
          data += ',"' + key + '":' + value;
        }
      }
      return data;
    }
    function getPrettyStream(opts, prettifier, dest, instance) {
      if (prettifier && typeof prettifier === "function") {
        prettifier = prettifier.bind(instance);
        return prettifierMetaWrapper(prettifier(opts), dest, opts);
      }
      try {
        const prettyFactory = require_pino_pretty().prettyFactory || require_pino_pretty();
        prettyFactory.asMetaWrapper = prettifierMetaWrapper;
        return prettifierMetaWrapper(prettyFactory(opts), dest, opts);
      } catch (e) {
        if (e.message.startsWith("Cannot find module 'pino-pretty'")) {
          throw Error("Missing `pino-pretty` module: `pino-pretty` must be installed separately");
        }
        ;
        throw e;
      }
    }
    function prettifierMetaWrapper(pretty, dest, opts) {
      opts = Object.assign({ suppressFlushSyncWarning: false }, opts);
      let warned = false;
      return {
        [needsMetadataGsym]: true,
        lastLevel: 0,
        lastMsg: null,
        lastObj: null,
        lastLogger: null,
        flushSync() {
          if (opts.suppressFlushSyncWarning || warned) {
            return;
          }
          warned = true;
          setMetadataProps(dest, this);
          dest.write(pretty(Object.assign({
            level: 40,
            msg: "pino.final with prettyPrint does not support flushing",
            time: Date.now()
          }, this.chindings())));
        },
        chindings() {
          const lastLogger = this.lastLogger;
          let chindings = null;
          if (!lastLogger) {
            return null;
          }
          if (lastLogger.hasOwnProperty(parsedChindingsSym)) {
            chindings = lastLogger[parsedChindingsSym];
          } else {
            chindings = JSON.parse("{" + lastLogger[chindingsSym].substr(1) + "}");
            lastLogger[parsedChindingsSym] = chindings;
          }
          return chindings;
        },
        write(chunk) {
          const lastLogger = this.lastLogger;
          const chindings = this.chindings();
          let time = this.lastTime;
          if (time.match(/^\d+/)) {
            time = parseInt(time);
          } else {
            time = time.slice(1, -1);
          }
          const lastObj = this.lastObj;
          const lastMsg = this.lastMsg;
          const errorProps = null;
          const formatters = lastLogger[formattersSym];
          const formattedObj = formatters.log ? formatters.log(lastObj) : lastObj;
          const messageKey = lastLogger[messageKeySym];
          if (lastMsg && formattedObj && !formattedObj.hasOwnProperty(messageKey)) {
            formattedObj[messageKey] = lastMsg;
          }
          const obj = Object.assign({
            level: this.lastLevel,
            time
          }, formattedObj, errorProps);
          const serializers = lastLogger[serializersSym];
          const keys = Object.keys(serializers);
          for (var i = 0; i < keys.length; i++) {
            const key = keys[i];
            if (obj[key] !== void 0) {
              obj[key] = serializers[key](obj[key]);
            }
          }
          for (const key in chindings) {
            if (!obj.hasOwnProperty(key)) {
              obj[key] = chindings[key];
            }
          }
          const stringifiers = lastLogger[stringifiersSym];
          const redact = stringifiers[redactFmtSym];
          const formatted = pretty(typeof redact === "function" ? redact(obj) : obj);
          if (formatted === void 0)
            return;
          setMetadataProps(dest, this);
          dest.write(formatted);
        }
      };
    }
    function hasBeenTampered(stream) {
      return stream.write !== stream.constructor.prototype.write;
    }
    function buildSafeSonicBoom(opts) {
      const stream = new SonicBoom(opts);
      stream.on("error", filterBrokenPipe);
      return stream;
      function filterBrokenPipe(err) {
        if (err.code === "EPIPE") {
          stream.write = noop;
          stream.end = noop;
          stream.flushSync = noop;
          stream.destroy = noop;
          return;
        }
        stream.removeListener("error", filterBrokenPipe);
        stream.emit("error", err);
      }
    }
    function createArgsNormalizer(defaultOptions) {
      return function normalizeArgs(instance, opts = {}, stream) {
        if (typeof opts === "string") {
          stream = buildSafeSonicBoom({ dest: opts, sync: true });
          opts = {};
        } else if (typeof stream === "string") {
          stream = buildSafeSonicBoom({ dest: stream, sync: true });
        } else if (opts instanceof SonicBoom || opts.writable || opts._writableState) {
          stream = opts;
          opts = null;
        }
        opts = Object.assign({}, defaultOptions, opts);
        if ("extreme" in opts) {
          throw Error("The extreme option has been removed, use pino.destination({ sync: false }) instead");
        }
        if ("onTerminated" in opts) {
          throw Error("The onTerminated option has been removed, use pino.final instead");
        }
        if ("changeLevelName" in opts) {
          process.emitWarning(
            "The changeLevelName option is deprecated and will be removed in v7. Use levelKey instead.",
            { code: "changeLevelName_deprecation" }
          );
          opts.levelKey = opts.changeLevelName;
          delete opts.changeLevelName;
        }
        const { enabled, prettyPrint, prettifier, messageKey } = opts;
        if (enabled === false)
          opts.level = "silent";
        stream = stream || process.stdout;
        if (stream === process.stdout && stream.fd >= 0 && !hasBeenTampered(stream)) {
          stream = buildSafeSonicBoom({ fd: stream.fd, sync: true });
        }
        if (prettyPrint) {
          const prettyOpts = Object.assign({ messageKey }, prettyPrint);
          stream = getPrettyStream(prettyOpts, prettifier, stream, instance);
        }
        return { opts, stream };
      };
    }
    function final(logger, handler) {
      if (typeof logger === "undefined" || typeof logger.child !== "function") {
        throw Error("expected a pino logger instance");
      }
      const hasHandler = typeof handler !== "undefined";
      if (hasHandler && typeof handler !== "function") {
        throw Error("if supplied, the handler parameter should be a function");
      }
      const stream = logger[streamSym];
      if (typeof stream.flushSync !== "function") {
        throw Error("final requires a stream that has a flushSync method, such as pino.destination");
      }
      const finalLogger = new Proxy(logger, {
        get: (logger2, key) => {
          if (key in logger2.levels.values) {
            return (...args) => {
              logger2[key](...args);
              stream.flushSync();
            };
          }
          return logger2[key];
        }
      });
      if (!hasHandler) {
        return finalLogger;
      }
      return (err = null, ...args) => {
        try {
          stream.flushSync();
        } catch (e) {
        }
        return handler(err, finalLogger, ...args);
      };
    }
    function stringify(obj) {
      try {
        return JSON.stringify(obj);
      } catch (_) {
        return stringifySafe(obj);
      }
    }
    function buildFormatters(level, bindings, log) {
      return {
        level,
        bindings,
        log
      };
    }
    function setMetadataProps(dest, that) {
      if (dest[needsMetadataGsym] === true) {
        dest.lastLevel = that.lastLevel;
        dest.lastMsg = that.lastMsg;
        dest.lastObj = that.lastObj;
        dest.lastTime = that.lastTime;
        dest.lastLogger = that.lastLogger;
      }
    }
    module2.exports = {
      noop,
      buildSafeSonicBoom,
      getPrettyStream,
      asChindings,
      asJson,
      genLog,
      createArgsNormalizer,
      final,
      stringify,
      buildFormatters
    };
  }
});

// node_modules/pino/lib/levels.js
var require_levels = __commonJS({
  "node_modules/pino/lib/levels.js"(exports, module2) {
    "use strict";
    var flatstr = require_flatstr();
    var {
      lsCacheSym,
      levelValSym,
      useOnlyCustomLevelsSym,
      streamSym,
      formattersSym,
      hooksSym
    } = require_symbols();
    var { noop, genLog } = require_tools();
    var levels = {
      trace: 10,
      debug: 20,
      info: 30,
      warn: 40,
      error: 50,
      fatal: 60
    };
    var levelMethods = {
      fatal: (hook) => {
        const logFatal = genLog(levels.fatal, hook);
        return function(...args) {
          const stream = this[streamSym];
          logFatal.call(this, ...args);
          if (typeof stream.flushSync === "function") {
            try {
              stream.flushSync();
            } catch (e) {
            }
          }
        };
      },
      error: (hook) => genLog(levels.error, hook),
      warn: (hook) => genLog(levels.warn, hook),
      info: (hook) => genLog(levels.info, hook),
      debug: (hook) => genLog(levels.debug, hook),
      trace: (hook) => genLog(levels.trace, hook)
    };
    var nums = Object.keys(levels).reduce((o, k) => {
      o[levels[k]] = k;
      return o;
    }, {});
    var initialLsCache = Object.keys(nums).reduce((o, k) => {
      o[k] = flatstr('{"level":' + Number(k));
      return o;
    }, {});
    function genLsCache(instance) {
      const formatter = instance[formattersSym].level;
      const { labels } = instance.levels;
      const cache = {};
      for (const label in labels) {
        const level = formatter(labels[label], Number(label));
        cache[label] = JSON.stringify(level).slice(0, -1);
      }
      instance[lsCacheSym] = cache;
      return instance;
    }
    function isStandardLevel(level, useOnlyCustomLevels) {
      if (useOnlyCustomLevels) {
        return false;
      }
      switch (level) {
        case "fatal":
        case "error":
        case "warn":
        case "info":
        case "debug":
        case "trace":
          return true;
        default:
          return false;
      }
    }
    function setLevel(level) {
      const { labels, values } = this.levels;
      if (typeof level === "number") {
        if (labels[level] === void 0)
          throw Error("unknown level value" + level);
        level = labels[level];
      }
      if (values[level] === void 0)
        throw Error("unknown level " + level);
      const preLevelVal = this[levelValSym];
      const levelVal = this[levelValSym] = values[level];
      const useOnlyCustomLevelsVal = this[useOnlyCustomLevelsSym];
      const hook = this[hooksSym].logMethod;
      for (const key in values) {
        if (levelVal > values[key]) {
          this[key] = noop;
          continue;
        }
        this[key] = isStandardLevel(key, useOnlyCustomLevelsVal) ? levelMethods[key](hook) : genLog(values[key], hook);
      }
      this.emit(
        "level-change",
        level,
        levelVal,
        labels[preLevelVal],
        preLevelVal
      );
    }
    function getLevel(level) {
      const { levels: levels2, levelVal } = this;
      return levels2 && levels2.labels ? levels2.labels[levelVal] : "";
    }
    function isLevelEnabled(logLevel) {
      const { values } = this.levels;
      const logLevelVal = values[logLevel];
      return logLevelVal !== void 0 && logLevelVal >= this[levelValSym];
    }
    function mappings(customLevels = null, useOnlyCustomLevels = false) {
      const customNums = customLevels ? Object.keys(customLevels).reduce((o, k) => {
        o[customLevels[k]] = k;
        return o;
      }, {}) : null;
      const labels = Object.assign(
        Object.create(Object.prototype, { Infinity: { value: "silent" } }),
        useOnlyCustomLevels ? null : nums,
        customNums
      );
      const values = Object.assign(
        Object.create(Object.prototype, { silent: { value: Infinity } }),
        useOnlyCustomLevels ? null : levels,
        customLevels
      );
      return { labels, values };
    }
    function assertDefaultLevelFound(defaultLevel, customLevels, useOnlyCustomLevels) {
      if (typeof defaultLevel === "number") {
        const values = [].concat(
          Object.keys(customLevels || {}).map((key) => customLevels[key]),
          useOnlyCustomLevels ? [] : Object.keys(nums).map((level) => +level),
          Infinity
        );
        if (!values.includes(defaultLevel)) {
          throw Error(`default level:${defaultLevel} must be included in custom levels`);
        }
        return;
      }
      const labels = Object.assign(
        Object.create(Object.prototype, { silent: { value: Infinity } }),
        useOnlyCustomLevels ? null : levels,
        customLevels
      );
      if (!(defaultLevel in labels)) {
        throw Error(`default level:${defaultLevel} must be included in custom levels`);
      }
    }
    function assertNoLevelCollisions(levels2, customLevels) {
      const { labels, values } = levels2;
      for (const k in customLevels) {
        if (k in values) {
          throw Error("levels cannot be overridden");
        }
        if (customLevels[k] in labels) {
          throw Error("pre-existing level values cannot be used for new levels");
        }
      }
    }
    module2.exports = {
      initialLsCache,
      genLsCache,
      levelMethods,
      getLevel,
      setLevel,
      isLevelEnabled,
      mappings,
      assertNoLevelCollisions,
      assertDefaultLevelFound
    };
  }
});

// node_modules/pino/package.json
var require_package = __commonJS({
  "node_modules/pino/package.json"(exports, module2) {
    module2.exports = {
      name: "pino",
      version: "6.14.0",
      description: "super fast, all natural json logger",
      main: "pino.js",
      browser: "./browser.js",
      files: [
        "pino.js",
        "bin.js",
        "browser.js",
        "pretty.js",
        "usage.txt",
        "test",
        "docs",
        "example.js",
        "lib"
      ],
      scripts: {
        docs: "docsify serve",
        "browser-test": "airtap --local 8080 test/browser*test.js",
        lint: "eslint .",
        test: "npm run lint && tap --100 test/*test.js test/*/*test.js",
        "test-ci": "npm run lint && tap test/*test.js test/*/*test.js --coverage-report=lcovonly",
        "cov-ui": "tap --coverage-report=html test/*test.js test/*/*test.js",
        bench: "node benchmarks/utils/runbench all",
        "bench-basic": "node benchmarks/utils/runbench basic",
        "bench-object": "node benchmarks/utils/runbench object",
        "bench-deep-object": "node benchmarks/utils/runbench deep-object",
        "bench-multi-arg": "node benchmarks/utils/runbench multi-arg",
        "bench-longs-tring": "node benchmarks/utils/runbench long-string",
        "bench-child": "node benchmarks/utils/runbench child",
        "bench-child-child": "node benchmarks/utils/runbench child-child",
        "bench-child-creation": "node benchmarks/utils/runbench child-creation",
        "bench-formatters": "node benchmarks/utils/runbench formatters",
        "update-bench-doc": "node benchmarks/utils/generate-benchmark-doc > docs/benchmarks.md"
      },
      bin: {
        pino: "./bin.js"
      },
      precommit: "test",
      repository: {
        type: "git",
        url: "git+https://github.com/pinojs/pino.git"
      },
      keywords: [
        "fast",
        "logger",
        "stream",
        "json"
      ],
      author: "Matteo Collina <hello@matteocollina.com>",
      contributors: [
        "David Mark Clements <huperekchuno@googlemail.com>",
        "James Sumners <james.sumners@gmail.com>",
        "Thomas Watson Steen <w@tson.dk> (https://twitter.com/wa7son)"
      ],
      license: "MIT",
      bugs: {
        url: "https://github.com/pinojs/pino/issues"
      },
      homepage: "http://getpino.io",
      devDependencies: {
        airtap: "4.0.3",
        benchmark: "^2.1.4",
        bole: "^4.0.0",
        bunyan: "^1.8.14",
        "docsify-cli": "^4.4.1",
        eslint: "^7.17.0",
        "eslint-config-standard": "^16.0.2",
        "eslint-plugin-import": "^2.22.1",
        "eslint-plugin-node": "^11.1.0",
        "eslint-plugin-promise": "^5.1.0",
        execa: "^5.0.0",
        fastbench: "^1.0.1",
        "flush-write-stream": "^2.0.0",
        "import-fresh": "^3.2.1",
        log: "^6.0.0",
        loglevel: "^1.6.7",
        "pino-pretty": "^5.0.0",
        "pre-commit": "^1.2.2",
        proxyquire: "^2.1.3",
        pump: "^3.0.0",
        semver: "^7.0.0",
        split2: "^3.1.1",
        steed: "^1.1.3",
        "strip-ansi": "^6.0.0",
        tap: "^15.0.1",
        tape: "^5.0.0",
        through2: "^4.0.0",
        winston: "^3.3.3"
      },
      dependencies: {
        "fast-redact": "^3.0.0",
        "fast-safe-stringify": "^2.0.8",
        "process-warning": "^1.0.0",
        flatstr: "^1.0.12",
        "pino-std-serializers": "^3.1.0",
        "quick-format-unescaped": "^4.0.3",
        "sonic-boom": "^1.0.2"
      }
    };
  }
});

// node_modules/pino/lib/meta.js
var require_meta = __commonJS({
  "node_modules/pino/lib/meta.js"(exports, module2) {
    "use strict";
    var { version } = require_package();
    module2.exports = { version };
  }
});

// node_modules/pino/lib/proto.js
var require_proto = __commonJS({
  "node_modules/pino/lib/proto.js"(exports, module2) {
    "use strict";
    var { EventEmitter } = require("events");
    var SonicBoom = require_sonic_boom();
    var flatstr = require_flatstr();
    var warning = require_deprecations();
    var {
      lsCacheSym,
      levelValSym,
      setLevelSym,
      getLevelSym,
      chindingsSym,
      parsedChindingsSym,
      mixinSym,
      asJsonSym,
      writeSym,
      mixinMergeStrategySym,
      timeSym,
      timeSliceIndexSym,
      streamSym,
      serializersSym,
      formattersSym,
      useOnlyCustomLevelsSym,
      needsMetadataGsym,
      redactFmtSym,
      stringifySym,
      formatOptsSym,
      stringifiersSym
    } = require_symbols();
    var {
      getLevel,
      setLevel,
      isLevelEnabled,
      mappings,
      initialLsCache,
      genLsCache,
      assertNoLevelCollisions
    } = require_levels();
    var {
      asChindings,
      asJson,
      buildFormatters,
      stringify
    } = require_tools();
    var {
      version
    } = require_meta();
    var redaction = require_redaction();
    var constructor = class Pino {
    };
    var prototype = {
      constructor,
      child,
      bindings,
      setBindings,
      flush,
      isLevelEnabled,
      version,
      get level() {
        return this[getLevelSym]();
      },
      set level(lvl) {
        this[setLevelSym](lvl);
      },
      get levelVal() {
        return this[levelValSym];
      },
      set levelVal(n) {
        throw Error("levelVal is read-only");
      },
      [lsCacheSym]: initialLsCache,
      [writeSym]: write,
      [asJsonSym]: asJson,
      [getLevelSym]: getLevel,
      [setLevelSym]: setLevel
    };
    Object.setPrototypeOf(prototype, EventEmitter.prototype);
    module2.exports = function() {
      return Object.create(prototype);
    };
    var resetChildingsFormatter = (bindings2) => bindings2;
    function child(bindings2, options) {
      if (!bindings2) {
        throw Error("missing bindings for child Pino");
      }
      options = options || {};
      const serializers = this[serializersSym];
      const formatters = this[formattersSym];
      const instance = Object.create(this);
      if (bindings2.hasOwnProperty("serializers") === true) {
        warning.emit("PINODEP004");
        options.serializers = bindings2.serializers;
      }
      if (bindings2.hasOwnProperty("formatters") === true) {
        warning.emit("PINODEP005");
        options.formatters = bindings2.formatters;
      }
      if (bindings2.hasOwnProperty("customLevels") === true) {
        warning.emit("PINODEP006");
        options.customLevels = bindings2.customLevels;
      }
      if (bindings2.hasOwnProperty("level") === true) {
        warning.emit("PINODEP007");
        options.level = bindings2.level;
      }
      if (options.hasOwnProperty("serializers") === true) {
        instance[serializersSym] = /* @__PURE__ */ Object.create(null);
        for (const k in serializers) {
          instance[serializersSym][k] = serializers[k];
        }
        const parentSymbols = Object.getOwnPropertySymbols(serializers);
        for (var i = 0; i < parentSymbols.length; i++) {
          const ks = parentSymbols[i];
          instance[serializersSym][ks] = serializers[ks];
        }
        for (const bk in options.serializers) {
          instance[serializersSym][bk] = options.serializers[bk];
        }
        const bindingsSymbols = Object.getOwnPropertySymbols(options.serializers);
        for (var bi = 0; bi < bindingsSymbols.length; bi++) {
          const bks = bindingsSymbols[bi];
          instance[serializersSym][bks] = options.serializers[bks];
        }
      } else
        instance[serializersSym] = serializers;
      if (options.hasOwnProperty("formatters")) {
        const { level, bindings: chindings, log } = options.formatters;
        instance[formattersSym] = buildFormatters(
          level || formatters.level,
          chindings || resetChildingsFormatter,
          log || formatters.log
        );
      } else {
        instance[formattersSym] = buildFormatters(
          formatters.level,
          resetChildingsFormatter,
          formatters.log
        );
      }
      if (options.hasOwnProperty("customLevels") === true) {
        assertNoLevelCollisions(this.levels, options.customLevels);
        instance.levels = mappings(options.customLevels, instance[useOnlyCustomLevelsSym]);
        genLsCache(instance);
      }
      if (typeof options.redact === "object" && options.redact !== null || Array.isArray(options.redact)) {
        instance.redact = options.redact;
        const stringifiers = redaction(instance.redact, stringify);
        const formatOpts = { stringify: stringifiers[redactFmtSym] };
        instance[stringifySym] = stringify;
        instance[stringifiersSym] = stringifiers;
        instance[formatOptsSym] = formatOpts;
      }
      instance[chindingsSym] = asChindings(instance, bindings2);
      const childLevel = options.level || this.level;
      instance[setLevelSym](childLevel);
      return instance;
    }
    function bindings() {
      const chindings = this[chindingsSym];
      const chindingsJson = `{${chindings.substr(1)}}`;
      const bindingsFromJson = JSON.parse(chindingsJson);
      delete bindingsFromJson.pid;
      delete bindingsFromJson.hostname;
      return bindingsFromJson;
    }
    function setBindings(newBindings) {
      const chindings = asChindings(this, newBindings);
      this[chindingsSym] = chindings;
      delete this[parsedChindingsSym];
    }
    function defaultMixinMergeStrategy(mergeObject, mixinObject) {
      return Object.assign(mixinObject, mergeObject);
    }
    function write(_obj, msg, num) {
      const t = this[timeSym]();
      const mixin = this[mixinSym];
      const mixinMergeStrategy = this[mixinMergeStrategySym] || defaultMixinMergeStrategy;
      const objError = _obj instanceof Error;
      let obj;
      if (_obj === void 0 || _obj === null) {
        obj = mixin ? mixin({}) : {};
      } else {
        obj = mixinMergeStrategy(_obj, mixin ? mixin(_obj) : {});
        if (!msg && objError) {
          msg = _obj.message;
        }
        if (objError) {
          obj.stack = _obj.stack;
          if (!obj.type) {
            obj.type = "Error";
          }
        }
      }
      const s = this[asJsonSym](obj, msg, num, t);
      const stream = this[streamSym];
      if (stream[needsMetadataGsym] === true) {
        stream.lastLevel = num;
        stream.lastObj = obj;
        stream.lastMsg = msg;
        stream.lastTime = t.slice(this[timeSliceIndexSym]);
        stream.lastLogger = this;
      }
      if (stream instanceof SonicBoom)
        stream.write(s);
      else
        stream.write(flatstr(s));
    }
    function flush() {
      const stream = this[streamSym];
      if ("flush" in stream)
        stream.flush();
    }
  }
});

// node_modules/pino/pino.js
var require_pino = __commonJS({
  "node_modules/pino/pino.js"(exports, module2) {
    "use strict";
    var os = require("os");
    var stdSerializers = require_pino_std_serializers();
    var redaction = require_redaction();
    var time = require_time();
    var proto = require_proto();
    var symbols = require_symbols();
    var { assertDefaultLevelFound, mappings, genLsCache } = require_levels();
    var {
      createArgsNormalizer,
      asChindings,
      final,
      stringify,
      buildSafeSonicBoom,
      buildFormatters,
      noop
    } = require_tools();
    var { version } = require_meta();
    var { mixinMergeStrategySym } = require_symbols();
    var {
      chindingsSym,
      redactFmtSym,
      serializersSym,
      timeSym,
      timeSliceIndexSym,
      streamSym,
      stringifySym,
      stringifiersSym,
      setLevelSym,
      endSym,
      formatOptsSym,
      messageKeySym,
      nestedKeySym,
      mixinSym,
      useOnlyCustomLevelsSym,
      formattersSym,
      hooksSym
    } = symbols;
    var { epochTime, nullTime } = time;
    var { pid } = process;
    var hostname = os.hostname();
    var defaultErrorSerializer = stdSerializers.err;
    var defaultOptions = {
      level: "info",
      messageKey: "msg",
      nestedKey: null,
      enabled: true,
      prettyPrint: false,
      base: { pid, hostname },
      serializers: Object.assign(/* @__PURE__ */ Object.create(null), {
        err: defaultErrorSerializer
      }),
      formatters: Object.assign(/* @__PURE__ */ Object.create(null), {
        bindings(bindings) {
          return bindings;
        },
        level(label, number) {
          return { level: number };
        }
      }),
      hooks: {
        logMethod: void 0
      },
      timestamp: epochTime,
      name: void 0,
      redact: null,
      customLevels: null,
      levelKey: void 0,
      useOnlyCustomLevels: false
    };
    var normalize = createArgsNormalizer(defaultOptions);
    var serializers = Object.assign(/* @__PURE__ */ Object.create(null), stdSerializers);
    function pino(...args) {
      const instance = {};
      const { opts, stream } = normalize(instance, ...args);
      const {
        redact,
        crlf,
        serializers: serializers2,
        timestamp,
        messageKey,
        nestedKey,
        base,
        name,
        level,
        customLevels,
        useLevelLabels,
        changeLevelName,
        levelKey,
        mixin,
        mixinMergeStrategy,
        useOnlyCustomLevels,
        formatters,
        hooks
      } = opts;
      const allFormatters = buildFormatters(
        formatters.level,
        formatters.bindings,
        formatters.log
      );
      if (useLevelLabels && !(changeLevelName || levelKey)) {
        process.emitWarning("useLevelLabels is deprecated, use the formatters.level option instead", "Warning", "PINODEP001");
        allFormatters.level = labelsFormatter;
      } else if ((changeLevelName || levelKey) && !useLevelLabels) {
        process.emitWarning("changeLevelName and levelKey are deprecated, use the formatters.level option instead", "Warning", "PINODEP002");
        allFormatters.level = levelNameFormatter(changeLevelName || levelKey);
      } else if ((changeLevelName || levelKey) && useLevelLabels) {
        process.emitWarning("useLevelLabels is deprecated, use the formatters.level option instead", "Warning", "PINODEP001");
        process.emitWarning("changeLevelName and levelKey are deprecated, use the formatters.level option instead", "Warning", "PINODEP002");
        allFormatters.level = levelNameLabelFormatter(changeLevelName || levelKey);
      }
      if (serializers2[Symbol.for("pino.*")]) {
        process.emitWarning("The pino.* serializer is deprecated, use the formatters.log options instead", "Warning", "PINODEP003");
        allFormatters.log = serializers2[Symbol.for("pino.*")];
      }
      if (!allFormatters.bindings) {
        allFormatters.bindings = defaultOptions.formatters.bindings;
      }
      if (!allFormatters.level) {
        allFormatters.level = defaultOptions.formatters.level;
      }
      const stringifiers = redact ? redaction(redact, stringify) : {};
      const formatOpts = redact ? { stringify: stringifiers[redactFmtSym] } : { stringify };
      const end = "}" + (crlf ? "\r\n" : "\n");
      const coreChindings = asChindings.bind(null, {
        [chindingsSym]: "",
        [serializersSym]: serializers2,
        [stringifiersSym]: stringifiers,
        [stringifySym]: stringify,
        [formattersSym]: allFormatters
      });
      let chindings = "";
      if (base !== null) {
        if (name === void 0) {
          chindings = coreChindings(base);
        } else {
          chindings = coreChindings(Object.assign({}, base, { name }));
        }
      }
      const time2 = timestamp instanceof Function ? timestamp : timestamp ? epochTime : nullTime;
      const timeSliceIndex = time2().indexOf(":") + 1;
      if (useOnlyCustomLevels && !customLevels)
        throw Error("customLevels is required if useOnlyCustomLevels is set true");
      if (mixin && typeof mixin !== "function")
        throw Error(`Unknown mixin type "${typeof mixin}" - expected "function"`);
      assertDefaultLevelFound(level, customLevels, useOnlyCustomLevels);
      const levels = mappings(customLevels, useOnlyCustomLevels);
      Object.assign(instance, {
        levels,
        [useOnlyCustomLevelsSym]: useOnlyCustomLevels,
        [streamSym]: stream,
        [timeSym]: time2,
        [timeSliceIndexSym]: timeSliceIndex,
        [stringifySym]: stringify,
        [stringifiersSym]: stringifiers,
        [endSym]: end,
        [formatOptsSym]: formatOpts,
        [messageKeySym]: messageKey,
        [nestedKeySym]: nestedKey,
        [serializersSym]: serializers2,
        [mixinSym]: mixin,
        [mixinMergeStrategySym]: mixinMergeStrategy,
        [chindingsSym]: chindings,
        [formattersSym]: allFormatters,
        [hooksSym]: hooks,
        silent: noop
      });
      Object.setPrototypeOf(instance, proto());
      genLsCache(instance);
      instance[setLevelSym](level);
      return instance;
    }
    function labelsFormatter(label, number) {
      return { level: label };
    }
    function levelNameFormatter(name) {
      return function(label, number) {
        return { [name]: number };
      };
    }
    function levelNameLabelFormatter(name) {
      return function(label, number) {
        return { [name]: label };
      };
    }
    module2.exports = pino;
    module2.exports.extreme = (dest = process.stdout.fd) => {
      process.emitWarning(
        "The pino.extreme() option is deprecated and will be removed in v7. Use pino.destination({ sync: false }) instead.",
        { code: "extreme_deprecation" }
      );
      return buildSafeSonicBoom({ dest, minLength: 4096, sync: false });
    };
    module2.exports.destination = (dest = process.stdout.fd) => {
      if (typeof dest === "object") {
        dest.dest = dest.dest || process.stdout.fd;
        return buildSafeSonicBoom(dest);
      } else {
        return buildSafeSonicBoom({ dest, minLength: 0, sync: true });
      }
    };
    module2.exports.final = final;
    module2.exports.levels = mappings();
    module2.exports.stdSerializers = serializers;
    module2.exports.stdTimeFunctions = Object.assign({}, time);
    module2.exports.symbols = symbols;
    module2.exports.version = version;
    module2.exports.default = pino;
    module2.exports.pino = pino;
  }
});

// node_modules/@sqltools/log/dist/lib/factory.js
var require_factory2 = __commonJS({
  "node_modules/@sqltools/log/dist/lib/factory.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    exports.__esModule = true;
    var pino_1 = __importDefault(require_pino());
    function factory(opts, stream) {
      if (opts === void 0) {
        opts = {};
      }
      var logger = pino_1["default"](__assign({ name: "ls", base: {}, level: process.env.NODE_ENV === "development" ? "debug" : "info", formatters: {
        level: function(level) {
          return { level };
        }
      }, prettyPrint: true }, opts), stream);
      logger.show = function() {
        return void 0;
      };
      return logger;
    }
    exports["default"] = factory;
  }
});

// node_modules/@sqltools/log/dist/lib/general.js
var require_general = __commonJS({
  "node_modules/@sqltools/log/dist/lib/general.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    exports.__esModule = true;
    var factory_1 = __importDefault(require_factory2());
    exports["default"] = factory_1["default"]();
  }
});

// node_modules/@sqltools/log/dist/index.js
var require_dist = __commonJS({
  "node_modules/@sqltools/log/dist/index.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    exports.__esModule = true;
    exports.createLogger = void 0;
    var logger;
    if (false) {
      logger = null["default"];
    } else {
      logger = require_general()["default"];
    }
    function createLogger(ns, bindings) {
      if (bindings === void 0) {
        bindings = {};
      }
      if (!ns)
        return logger;
      return logger.child(__assign(__assign({}, bindings), { ns }));
    }
    exports.createLogger = createLogger;
    exports["default"] = logger;
  }
});

// node_modules/vscode-uri/lib/umd/index.js
var require_umd = __commonJS({
  "node_modules/vscode-uri/lib/umd/index.js"(exports, module2) {
    !function(t, e) {
      if ("object" == typeof exports && "object" == typeof module2)
        module2.exports = e();
      else if ("function" == typeof define && define.amd)
        define([], e);
      else {
        var r = e();
        for (var n in r)
          ("object" == typeof exports ? exports : t)[n] = r[n];
      }
    }(exports, () => (() => {
      "use strict";
      var t = { 470: (t2) => {
        function e2(t3) {
          if ("string" != typeof t3)
            throw new TypeError("Path must be a string. Received " + JSON.stringify(t3));
        }
        function r2(t3, e3) {
          for (var r3, n3 = "", i = 0, o = -1, s = 0, a = 0; a <= t3.length; ++a) {
            if (a < t3.length)
              r3 = t3.charCodeAt(a);
            else {
              if (47 === r3)
                break;
              r3 = 47;
            }
            if (47 === r3) {
              if (o === a - 1 || 1 === s)
                ;
              else if (o !== a - 1 && 2 === s) {
                if (n3.length < 2 || 2 !== i || 46 !== n3.charCodeAt(n3.length - 1) || 46 !== n3.charCodeAt(n3.length - 2)) {
                  if (n3.length > 2) {
                    var h = n3.lastIndexOf("/");
                    if (h !== n3.length - 1) {
                      -1 === h ? (n3 = "", i = 0) : i = (n3 = n3.slice(0, h)).length - 1 - n3.lastIndexOf("/"), o = a, s = 0;
                      continue;
                    }
                  } else if (2 === n3.length || 1 === n3.length) {
                    n3 = "", i = 0, o = a, s = 0;
                    continue;
                  }
                }
                e3 && (n3.length > 0 ? n3 += "/.." : n3 = "..", i = 2);
              } else
                n3.length > 0 ? n3 += "/" + t3.slice(o + 1, a) : n3 = t3.slice(o + 1, a), i = a - o - 1;
              o = a, s = 0;
            } else
              46 === r3 && -1 !== s ? ++s : s = -1;
          }
          return n3;
        }
        var n2 = { resolve: function() {
          for (var t3, n3 = "", i = false, o = arguments.length - 1; o >= -1 && !i; o--) {
            var s;
            o >= 0 ? s = arguments[o] : (void 0 === t3 && (t3 = process.cwd()), s = t3), e2(s), 0 !== s.length && (n3 = s + "/" + n3, i = 47 === s.charCodeAt(0));
          }
          return n3 = r2(n3, !i), i ? n3.length > 0 ? "/" + n3 : "/" : n3.length > 0 ? n3 : ".";
        }, normalize: function(t3) {
          if (e2(t3), 0 === t3.length)
            return ".";
          var n3 = 47 === t3.charCodeAt(0), i = 47 === t3.charCodeAt(t3.length - 1);
          return 0 !== (t3 = r2(t3, !n3)).length || n3 || (t3 = "."), t3.length > 0 && i && (t3 += "/"), n3 ? "/" + t3 : t3;
        }, isAbsolute: function(t3) {
          return e2(t3), t3.length > 0 && 47 === t3.charCodeAt(0);
        }, join: function() {
          if (0 === arguments.length)
            return ".";
          for (var t3, r3 = 0; r3 < arguments.length; ++r3) {
            var i = arguments[r3];
            e2(i), i.length > 0 && (void 0 === t3 ? t3 = i : t3 += "/" + i);
          }
          return void 0 === t3 ? "." : n2.normalize(t3);
        }, relative: function(t3, r3) {
          if (e2(t3), e2(r3), t3 === r3)
            return "";
          if ((t3 = n2.resolve(t3)) === (r3 = n2.resolve(r3)))
            return "";
          for (var i = 1; i < t3.length && 47 === t3.charCodeAt(i); ++i)
            ;
          for (var o = t3.length, s = o - i, a = 1; a < r3.length && 47 === r3.charCodeAt(a); ++a)
            ;
          for (var h = r3.length - a, c = s < h ? s : h, f = -1, u = 0; u <= c; ++u) {
            if (u === c) {
              if (h > c) {
                if (47 === r3.charCodeAt(a + u))
                  return r3.slice(a + u + 1);
                if (0 === u)
                  return r3.slice(a + u);
              } else
                s > c && (47 === t3.charCodeAt(i + u) ? f = u : 0 === u && (f = 0));
              break;
            }
            var l = t3.charCodeAt(i + u);
            if (l !== r3.charCodeAt(a + u))
              break;
            47 === l && (f = u);
          }
          var d = "";
          for (u = i + f + 1; u <= o; ++u)
            u !== o && 47 !== t3.charCodeAt(u) || (0 === d.length ? d += ".." : d += "/..");
          return d.length > 0 ? d + r3.slice(a + f) : (a += f, 47 === r3.charCodeAt(a) && ++a, r3.slice(a));
        }, _makeLong: function(t3) {
          return t3;
        }, dirname: function(t3) {
          if (e2(t3), 0 === t3.length)
            return ".";
          for (var r3 = t3.charCodeAt(0), n3 = 47 === r3, i = -1, o = true, s = t3.length - 1; s >= 1; --s)
            if (47 === (r3 = t3.charCodeAt(s))) {
              if (!o) {
                i = s;
                break;
              }
            } else
              o = false;
          return -1 === i ? n3 ? "/" : "." : n3 && 1 === i ? "//" : t3.slice(0, i);
        }, basename: function(t3, r3) {
          if (void 0 !== r3 && "string" != typeof r3)
            throw new TypeError('"ext" argument must be a string');
          e2(t3);
          var n3, i = 0, o = -1, s = true;
          if (void 0 !== r3 && r3.length > 0 && r3.length <= t3.length) {
            if (r3.length === t3.length && r3 === t3)
              return "";
            var a = r3.length - 1, h = -1;
            for (n3 = t3.length - 1; n3 >= 0; --n3) {
              var c = t3.charCodeAt(n3);
              if (47 === c) {
                if (!s) {
                  i = n3 + 1;
                  break;
                }
              } else
                -1 === h && (s = false, h = n3 + 1), a >= 0 && (c === r3.charCodeAt(a) ? -1 == --a && (o = n3) : (a = -1, o = h));
            }
            return i === o ? o = h : -1 === o && (o = t3.length), t3.slice(i, o);
          }
          for (n3 = t3.length - 1; n3 >= 0; --n3)
            if (47 === t3.charCodeAt(n3)) {
              if (!s) {
                i = n3 + 1;
                break;
              }
            } else
              -1 === o && (s = false, o = n3 + 1);
          return -1 === o ? "" : t3.slice(i, o);
        }, extname: function(t3) {
          e2(t3);
          for (var r3 = -1, n3 = 0, i = -1, o = true, s = 0, a = t3.length - 1; a >= 0; --a) {
            var h = t3.charCodeAt(a);
            if (47 !== h)
              -1 === i && (o = false, i = a + 1), 46 === h ? -1 === r3 ? r3 = a : 1 !== s && (s = 1) : -1 !== r3 && (s = -1);
            else if (!o) {
              n3 = a + 1;
              break;
            }
          }
          return -1 === r3 || -1 === i || 0 === s || 1 === s && r3 === i - 1 && r3 === n3 + 1 ? "" : t3.slice(r3, i);
        }, format: function(t3) {
          if (null === t3 || "object" != typeof t3)
            throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof t3);
          return function(t4, e3) {
            var r3 = e3.dir || e3.root, n3 = e3.base || (e3.name || "") + (e3.ext || "");
            return r3 ? r3 === e3.root ? r3 + n3 : r3 + "/" + n3 : n3;
          }(0, t3);
        }, parse: function(t3) {
          e2(t3);
          var r3 = { root: "", dir: "", base: "", ext: "", name: "" };
          if (0 === t3.length)
            return r3;
          var n3, i = t3.charCodeAt(0), o = 47 === i;
          o ? (r3.root = "/", n3 = 1) : n3 = 0;
          for (var s = -1, a = 0, h = -1, c = true, f = t3.length - 1, u = 0; f >= n3; --f)
            if (47 !== (i = t3.charCodeAt(f)))
              -1 === h && (c = false, h = f + 1), 46 === i ? -1 === s ? s = f : 1 !== u && (u = 1) : -1 !== s && (u = -1);
            else if (!c) {
              a = f + 1;
              break;
            }
          return -1 === s || -1 === h || 0 === u || 1 === u && s === h - 1 && s === a + 1 ? -1 !== h && (r3.base = r3.name = 0 === a && o ? t3.slice(1, h) : t3.slice(a, h)) : (0 === a && o ? (r3.name = t3.slice(1, s), r3.base = t3.slice(1, h)) : (r3.name = t3.slice(a, s), r3.base = t3.slice(a, h)), r3.ext = t3.slice(s, h)), a > 0 ? r3.dir = t3.slice(0, a - 1) : o && (r3.dir = "/"), r3;
        }, sep: "/", delimiter: ":", win32: null, posix: null };
        n2.posix = n2, t2.exports = n2;
      }, 674: (t2, e2) => {
        if (Object.defineProperty(e2, "__esModule", { value: true }), e2.isWindows = void 0, "object" == typeof process)
          e2.isWindows = "win32" === process.platform;
        else if ("object" == typeof navigator) {
          let t3 = navigator.userAgent;
          e2.isWindows = t3.indexOf("Windows") >= 0;
        }
      }, 796: (t2, e2, r2) => {
        Object.defineProperty(e2, "__esModule", { value: true }), e2.uriToFsPath = e2.URI = void 0;
        const n2 = r2(674), i = /^\w[\w\d+.-]*$/, o = /^\//, s = /^\/\//;
        function a(t3, e3) {
          if (!t3.scheme && e3)
            throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${t3.authority}", path: "${t3.path}", query: "${t3.query}", fragment: "${t3.fragment}"}`);
          if (t3.scheme && !i.test(t3.scheme))
            throw new Error("[UriError]: Scheme contains illegal characters.");
          if (t3.path) {
            if (t3.authority) {
              if (!o.test(t3.path))
                throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
            } else if (s.test(t3.path))
              throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
          }
        }
        const h = "", c = "/", f = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
        class u {
          constructor(t3, e3, r3, n3, i2, o2 = false) {
            __publicField(this, "scheme");
            __publicField(this, "authority");
            __publicField(this, "path");
            __publicField(this, "query");
            __publicField(this, "fragment");
            "object" == typeof t3 ? (this.scheme = t3.scheme || h, this.authority = t3.authority || h, this.path = t3.path || h, this.query = t3.query || h, this.fragment = t3.fragment || h) : (this.scheme = function(t4, e4) {
              return t4 || e4 ? t4 : "file";
            }(t3, o2), this.authority = e3 || h, this.path = function(t4, e4) {
              switch (t4) {
                case "https":
                case "http":
                case "file":
                  e4 ? e4[0] !== c && (e4 = c + e4) : e4 = c;
              }
              return e4;
            }(this.scheme, r3 || h), this.query = n3 || h, this.fragment = i2 || h, a(this, o2));
          }
          static isUri(t3) {
            return t3 instanceof u || !!t3 && "string" == typeof t3.authority && "string" == typeof t3.fragment && "string" == typeof t3.path && "string" == typeof t3.query && "string" == typeof t3.scheme && "string" == typeof t3.fsPath && "function" == typeof t3.with && "function" == typeof t3.toString;
          }
          get fsPath() {
            return v(this, false);
          }
          with(t3) {
            if (!t3)
              return this;
            let { scheme: e3, authority: r3, path: n3, query: i2, fragment: o2 } = t3;
            return void 0 === e3 ? e3 = this.scheme : null === e3 && (e3 = h), void 0 === r3 ? r3 = this.authority : null === r3 && (r3 = h), void 0 === n3 ? n3 = this.path : null === n3 && (n3 = h), void 0 === i2 ? i2 = this.query : null === i2 && (i2 = h), void 0 === o2 ? o2 = this.fragment : null === o2 && (o2 = h), e3 === this.scheme && r3 === this.authority && n3 === this.path && i2 === this.query && o2 === this.fragment ? this : new d(e3, r3, n3, i2, o2);
          }
          static parse(t3, e3 = false) {
            const r3 = f.exec(t3);
            return r3 ? new d(r3[2] || h, w(r3[4] || h), w(r3[5] || h), w(r3[7] || h), w(r3[9] || h), e3) : new d(h, h, h, h, h);
          }
          static file(t3) {
            let e3 = h;
            if (n2.isWindows && (t3 = t3.replace(/\\/g, c)), t3[0] === c && t3[1] === c) {
              const r3 = t3.indexOf(c, 2);
              -1 === r3 ? (e3 = t3.substring(2), t3 = c) : (e3 = t3.substring(2, r3), t3 = t3.substring(r3) || c);
            }
            return new d("file", e3, t3, h, h);
          }
          static from(t3) {
            const e3 = new d(t3.scheme, t3.authority, t3.path, t3.query, t3.fragment);
            return a(e3, true), e3;
          }
          toString(t3 = false) {
            return y(this, t3);
          }
          toJSON() {
            return this;
          }
          static revive(t3) {
            if (t3) {
              if (t3 instanceof u)
                return t3;
              {
                const e3 = new d(t3);
                return e3._formatted = t3.external, e3._fsPath = t3._sep === l ? t3.fsPath : null, e3;
              }
            }
            return t3;
          }
        }
        e2.URI = u;
        const l = n2.isWindows ? 1 : void 0;
        class d extends u {
          constructor() {
            super(...arguments);
            __publicField(this, "_formatted", null);
            __publicField(this, "_fsPath", null);
          }
          get fsPath() {
            return this._fsPath || (this._fsPath = v(this, false)), this._fsPath;
          }
          toString(t3 = false) {
            return t3 ? y(this, true) : (this._formatted || (this._formatted = y(this, false)), this._formatted);
          }
          toJSON() {
            const t3 = { $mid: 1 };
            return this._fsPath && (t3.fsPath = this._fsPath, t3._sep = l), this._formatted && (t3.external = this._formatted), this.path && (t3.path = this.path), this.scheme && (t3.scheme = this.scheme), this.authority && (t3.authority = this.authority), this.query && (t3.query = this.query), this.fragment && (t3.fragment = this.fragment), t3;
          }
        }
        const p = { 58: "%3A", 47: "%2F", 63: "%3F", 35: "%23", 91: "%5B", 93: "%5D", 64: "%40", 33: "%21", 36: "%24", 38: "%26", 39: "%27", 40: "%28", 41: "%29", 42: "%2A", 43: "%2B", 44: "%2C", 59: "%3B", 61: "%3D", 32: "%20" };
        function g(t3, e3, r3) {
          let n3, i2 = -1;
          for (let o2 = 0; o2 < t3.length; o2++) {
            const s2 = t3.charCodeAt(o2);
            if (s2 >= 97 && s2 <= 122 || s2 >= 65 && s2 <= 90 || s2 >= 48 && s2 <= 57 || 45 === s2 || 46 === s2 || 95 === s2 || 126 === s2 || e3 && 47 === s2 || r3 && 91 === s2 || r3 && 93 === s2 || r3 && 58 === s2)
              -1 !== i2 && (n3 += encodeURIComponent(t3.substring(i2, o2)), i2 = -1), void 0 !== n3 && (n3 += t3.charAt(o2));
            else {
              void 0 === n3 && (n3 = t3.substr(0, o2));
              const e4 = p[s2];
              void 0 !== e4 ? (-1 !== i2 && (n3 += encodeURIComponent(t3.substring(i2, o2)), i2 = -1), n3 += e4) : -1 === i2 && (i2 = o2);
            }
          }
          return -1 !== i2 && (n3 += encodeURIComponent(t3.substring(i2))), void 0 !== n3 ? n3 : t3;
        }
        function m(t3) {
          let e3;
          for (let r3 = 0; r3 < t3.length; r3++) {
            const n3 = t3.charCodeAt(r3);
            35 === n3 || 63 === n3 ? (void 0 === e3 && (e3 = t3.substr(0, r3)), e3 += p[n3]) : void 0 !== e3 && (e3 += t3[r3]);
          }
          return void 0 !== e3 ? e3 : t3;
        }
        function v(t3, e3) {
          let r3;
          return r3 = t3.authority && t3.path.length > 1 && "file" === t3.scheme ? `//${t3.authority}${t3.path}` : 47 === t3.path.charCodeAt(0) && (t3.path.charCodeAt(1) >= 65 && t3.path.charCodeAt(1) <= 90 || t3.path.charCodeAt(1) >= 97 && t3.path.charCodeAt(1) <= 122) && 58 === t3.path.charCodeAt(2) ? e3 ? t3.path.substr(1) : t3.path[1].toLowerCase() + t3.path.substr(2) : t3.path, n2.isWindows && (r3 = r3.replace(/\//g, "\\")), r3;
        }
        function y(t3, e3) {
          const r3 = e3 ? m : g;
          let n3 = "", { scheme: i2, authority: o2, path: s2, query: a2, fragment: h2 } = t3;
          if (i2 && (n3 += i2, n3 += ":"), (o2 || "file" === i2) && (n3 += c, n3 += c), o2) {
            let t4 = o2.indexOf("@");
            if (-1 !== t4) {
              const e4 = o2.substr(0, t4);
              o2 = o2.substr(t4 + 1), t4 = e4.lastIndexOf(":"), -1 === t4 ? n3 += r3(e4, false, false) : (n3 += r3(e4.substr(0, t4), false, false), n3 += ":", n3 += r3(e4.substr(t4 + 1), false, true)), n3 += "@";
            }
            o2 = o2.toLowerCase(), t4 = o2.lastIndexOf(":"), -1 === t4 ? n3 += r3(o2, false, true) : (n3 += r3(o2.substr(0, t4), false, true), n3 += o2.substr(t4));
          }
          if (s2) {
            if (s2.length >= 3 && 47 === s2.charCodeAt(0) && 58 === s2.charCodeAt(2)) {
              const t4 = s2.charCodeAt(1);
              t4 >= 65 && t4 <= 90 && (s2 = `/${String.fromCharCode(t4 + 32)}:${s2.substr(3)}`);
            } else if (s2.length >= 2 && 58 === s2.charCodeAt(1)) {
              const t4 = s2.charCodeAt(0);
              t4 >= 65 && t4 <= 90 && (s2 = `${String.fromCharCode(t4 + 32)}:${s2.substr(2)}`);
            }
            n3 += r3(s2, true, false);
          }
          return a2 && (n3 += "?", n3 += r3(a2, false, false)), h2 && (n3 += "#", n3 += e3 ? h2 : g(h2, false, false)), n3;
        }
        function b(t3) {
          try {
            return decodeURIComponent(t3);
          } catch {
            return t3.length > 3 ? t3.substr(0, 3) + b(t3.substr(3)) : t3;
          }
        }
        e2.uriToFsPath = v;
        const C = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
        function w(t3) {
          return t3.match(C) ? t3.replace(C, (t4) => b(t4)) : t3;
        }
      }, 679: function(t2, e2, r2) {
        var n2 = this && this.__createBinding || (Object.create ? function(t3, e3, r3, n3) {
          void 0 === n3 && (n3 = r3);
          var i2 = Object.getOwnPropertyDescriptor(e3, r3);
          i2 && !("get" in i2 ? !e3.__esModule : i2.writable || i2.configurable) || (i2 = { enumerable: true, get: function() {
            return e3[r3];
          } }), Object.defineProperty(t3, n3, i2);
        } : function(t3, e3, r3, n3) {
          void 0 === n3 && (n3 = r3), t3[n3] = e3[r3];
        }), i = this && this.__setModuleDefault || (Object.create ? function(t3, e3) {
          Object.defineProperty(t3, "default", { enumerable: true, value: e3 });
        } : function(t3, e3) {
          t3.default = e3;
        }), o = this && this.__importStar || function(t3) {
          if (t3 && t3.__esModule)
            return t3;
          var e3 = {};
          if (null != t3)
            for (var r3 in t3)
              "default" !== r3 && Object.prototype.hasOwnProperty.call(t3, r3) && n2(e3, t3, r3);
          return i(e3, t3), e3;
        };
        Object.defineProperty(e2, "__esModule", { value: true }), e2.Utils = void 0;
        const s = o(r2(470)), a = s.posix || s, h = "/";
        var c;
        !function(t3) {
          t3.joinPath = function(t4, ...e3) {
            return t4.with({ path: a.join(t4.path, ...e3) });
          }, t3.resolvePath = function(t4, ...e3) {
            let r3 = t4.path, n3 = false;
            r3[0] !== h && (r3 = h + r3, n3 = true);
            let i2 = a.resolve(r3, ...e3);
            return n3 && i2[0] === h && !t4.authority && (i2 = i2.substring(1)), t4.with({ path: i2 });
          }, t3.dirname = function(t4) {
            if (0 === t4.path.length || t4.path === h)
              return t4;
            let e3 = a.dirname(t4.path);
            return 1 === e3.length && 46 === e3.charCodeAt(0) && (e3 = ""), t4.with({ path: e3 });
          }, t3.basename = function(t4) {
            return a.basename(t4.path);
          }, t3.extname = function(t4) {
            return a.extname(t4.path);
          };
        }(c || (e2.Utils = c = {}));
      } }, e = {};
      function r(n2) {
        var i = e[n2];
        if (void 0 !== i)
          return i.exports;
        var o = e[n2] = { exports: {} };
        return t[n2].call(o.exports, o, o.exports, r), o.exports;
      }
      var n = {};
      return (() => {
        var t2 = n;
        Object.defineProperty(t2, "__esModule", { value: true }), t2.Utils = t2.URI = void 0;
        const e2 = r(796);
        Object.defineProperty(t2, "URI", { enumerable: true, get: function() {
          return e2.URI;
        } });
        const i = r(679);
        Object.defineProperty(t2, "Utils", { enumerable: true, get: function() {
          return i.Utils;
        } });
      })(), n;
    })());
  }
});

// node_modules/@sqltools/base-driver/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/@sqltools/base-driver/dist/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var electron_not_supported_1 = __importDefault(require_electron_not_supported());
    var missing_module_1 = __importDefault(require_missing_module());
    var require_1 = __importStar(require_require());
    var log_1 = require_dist();
    var path_1 = __importDefault(require("path"));
    var fs_1 = __importDefault(require("fs"));
    var vscode_uri_1 = require_umd();
    var AbstractDriver2 = class {
      constructor(credentials, getWorkspaceFolders) {
        this.credentials = credentials;
        this.getWorkspaceFolders = getWorkspaceFolders;
        this.deps = [];
        this.queryResults = (query, opt) => __awaiter(this, void 0, void 0, function* () {
          const result = yield this.singleQuery(query, opt);
          if (result.error)
            throw result.rawError;
          return result.results;
        });
        this.requireDep = (name) => {
          return require_1.default(name);
        };
        this.resolveDep = (name) => {
          return require_1.sqltoolsResolve(name);
        };
        this.log = log_1.createLogger(credentials.driver.toLowerCase());
      }
      getId() {
        return this.credentials.id;
      }
      singleQuery(query, opt) {
        return this.query(query, opt).then(([res]) => res);
      }
      describeTable(metadata, opt) {
        return __awaiter(this, void 0, void 0, function* () {
          const result = yield this.singleQuery(this.queries.describeTable(metadata), opt);
          result.baseQuery = this.queries.describeTable.raw;
          return [result];
        });
      }
      showRecords(table, opt) {
        return __awaiter(this, void 0, void 0, function* () {
          const { limit, page = 0 } = opt;
          const params = Object.assign(Object.assign({}, opt), { limit, table, offset: page * limit });
          if (typeof this.queries.fetchRecords === "function" && typeof this.queries.countRecords === "function") {
            const [records, totalResult] = yield Promise.all([
              this.singleQuery(this.queries.fetchRecords(params), opt),
              this.singleQuery(this.queries.countRecords(params), opt)
            ]);
            records.baseQuery = this.queries.fetchRecords.raw;
            records.pageSize = limit;
            records.page = page;
            records.total = Number(totalResult.results[0].total);
            records.queryType = "showRecords";
            records.queryParams = table;
            return [records];
          }
          return this.query(this.queries.fetchRecords(params), opt);
        });
      }
      checkDependencies() {
        return __awaiter(this, void 0, void 0, function* () {
          if (!this.deps || this.deps.length === 0)
            return;
          if (Number(process.env.IS_NODE_RUNTIME || "0") !== 1) {
            throw new electron_not_supported_1.default();
          }
          this.deps.forEach((dep) => {
            let mustUpgrade = false;
            switch (dep.type) {
              case AbstractDriver2.CONSTANTS.DEPENDENCY_PACKAGE:
                try {
                  const { version } = JSON.parse(fs_1.default.readFileSync(this.resolveDep(dep.name + "/package.json")).toString());
                  if (dep.version && version !== dep.version) {
                    mustUpgrade = true;
                    throw new Error(`Version not matching. We need to upgrade ${dep.name}`);
                  }
                  this.requireDep(dep.name);
                } catch (e) {
                  throw new missing_module_1.default(this.deps, this.credentials, mustUpgrade);
                }
                break;
            }
          });
        });
      }
      getChildrenForItem(_params) {
        this.log.error(`###### Attention ######getChildrenForItem not implemented for ${this.credentials.driver}
####################`);
        return Promise.resolve([]);
      }
      searchItems(_itemType, _search, _extraParams) {
        this.log.error(`###### Attention ######searchItems not implemented for ${this.credentials.driver}
####################`);
        return Promise.resolve([]);
      }
      toAbsolutePath(fsPath) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!path_1.default.isAbsolute(fsPath) && /\$\{workspaceFolder:(.+)}/g.test(fsPath)) {
            const workspaceName = fsPath.match(/\$\{workspaceFolder:(.+)}/)[1];
            if (workspaceName) {
              const workspaceFolders = yield this.getWorkspaceFolders();
              const dbWorkspace = workspaceFolders.find((w) => w.name === workspaceName);
              fsPath = path_1.default.resolve(vscode_uri_1.URI.parse(dbWorkspace.uri, true).fsPath, fsPath.replace(/\$\{workspaceFolder:(.+)}/g, "./"));
            }
          }
          return fsPath;
        });
      }
      prepareMessage(message) {
        return { message: message.toString(), date: new Date() };
      }
    };
    exports.default = AbstractDriver2;
    AbstractDriver2.CONSTANTS = {
      DEPENDENCY_PACKAGE: "package",
      DEPENDENCY_NPM_SCRIPT: "npmscript"
    };
  }
});

// node_modules/uuid/dist/rng.js
var require_rng = __commonJS({
  "node_modules/uuid/dist/rng.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = rng;
    var _crypto = _interopRequireDefault(require("crypto"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function rng() {
      return _crypto.default.randomBytes(16);
    }
    module2.exports = exports.default;
  }
});

// node_modules/uuid/dist/bytesToUuid.js
var require_bytesToUuid = __commonJS({
  "node_modules/uuid/dist/bytesToUuid.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var byteToHex = [];
    for (i = 0; i < 256; ++i) {
      byteToHex[i] = (i + 256).toString(16).substr(1);
    }
    var i;
    function bytesToUuid(buf, offset) {
      var i2 = offset || 0;
      var bth = byteToHex;
      return [bth[buf[i2++]], bth[buf[i2++]], bth[buf[i2++]], bth[buf[i2++]], "-", bth[buf[i2++]], bth[buf[i2++]], "-", bth[buf[i2++]], bth[buf[i2++]], "-", bth[buf[i2++]], bth[buf[i2++]], "-", bth[buf[i2++]], bth[buf[i2++]], bth[buf[i2++]], bth[buf[i2++]], bth[buf[i2++]], bth[buf[i2++]]].join("");
    }
    var _default = bytesToUuid;
    exports.default = _default;
    module2.exports = exports.default;
  }
});

// node_modules/uuid/dist/v1.js
var require_v1 = __commonJS({
  "node_modules/uuid/dist/v1.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _rng = _interopRequireDefault(require_rng());
    var _bytesToUuid = _interopRequireDefault(require_bytesToUuid());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var _nodeId;
    var _clockseq;
    var _lastMSecs = 0;
    var _lastNSecs = 0;
    function v1(options, buf, offset) {
      var i = buf && offset || 0;
      var b = buf || [];
      options = options || {};
      var node = options.node || _nodeId;
      var clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
      if (node == null || clockseq == null) {
        var seedBytes = options.random || (options.rng || _rng.default)();
        if (node == null) {
          node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
        }
        if (clockseq == null) {
          clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
        }
      }
      var msecs = options.msecs !== void 0 ? options.msecs : new Date().getTime();
      var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
      var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
      if (dt < 0 && options.clockseq === void 0) {
        clockseq = clockseq + 1 & 16383;
      }
      if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
        nsecs = 0;
      }
      if (nsecs >= 1e4) {
        throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
      }
      _lastMSecs = msecs;
      _lastNSecs = nsecs;
      _clockseq = clockseq;
      msecs += 122192928e5;
      var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
      b[i++] = tl >>> 24 & 255;
      b[i++] = tl >>> 16 & 255;
      b[i++] = tl >>> 8 & 255;
      b[i++] = tl & 255;
      var tmh = msecs / 4294967296 * 1e4 & 268435455;
      b[i++] = tmh >>> 8 & 255;
      b[i++] = tmh & 255;
      b[i++] = tmh >>> 24 & 15 | 16;
      b[i++] = tmh >>> 16 & 255;
      b[i++] = clockseq >>> 8 | 128;
      b[i++] = clockseq & 255;
      for (var n = 0; n < 6; ++n) {
        b[i + n] = node[n];
      }
      return buf ? buf : (0, _bytesToUuid.default)(b);
    }
    var _default = v1;
    exports.default = _default;
    module2.exports = exports.default;
  }
});

// node_modules/uuid/dist/v35.js
var require_v35 = __commonJS({
  "node_modules/uuid/dist/v35.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = _default;
    exports.URL = exports.DNS = void 0;
    var _bytesToUuid = _interopRequireDefault(require_bytesToUuid());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function uuidToBytes(uuid) {
      var bytes = [];
      uuid.replace(/[a-fA-F0-9]{2}/g, function(hex) {
        bytes.push(parseInt(hex, 16));
      });
      return bytes;
    }
    function stringToBytes(str) {
      str = unescape(encodeURIComponent(str));
      var bytes = new Array(str.length);
      for (var i = 0; i < str.length; i++) {
        bytes[i] = str.charCodeAt(i);
      }
      return bytes;
    }
    var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    exports.DNS = DNS;
    var URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
    exports.URL = URL;
    function _default(name, version, hashfunc) {
      var generateUUID = function(value, namespace, buf, offset) {
        var off = buf && offset || 0;
        if (typeof value == "string")
          value = stringToBytes(value);
        if (typeof namespace == "string")
          namespace = uuidToBytes(namespace);
        if (!Array.isArray(value))
          throw TypeError("value must be an array of bytes");
        if (!Array.isArray(namespace) || namespace.length !== 16)
          throw TypeError("namespace must be uuid string or an Array of 16 byte values");
        var bytes = hashfunc(namespace.concat(value));
        bytes[6] = bytes[6] & 15 | version;
        bytes[8] = bytes[8] & 63 | 128;
        if (buf) {
          for (var idx = 0; idx < 16; ++idx) {
            buf[off + idx] = bytes[idx];
          }
        }
        return buf || (0, _bytesToUuid.default)(bytes);
      };
      try {
        generateUUID.name = name;
      } catch (err) {
      }
      generateUUID.DNS = DNS;
      generateUUID.URL = URL;
      return generateUUID;
    }
  }
});

// node_modules/uuid/dist/md5.js
var require_md5 = __commonJS({
  "node_modules/uuid/dist/md5.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _crypto = _interopRequireDefault(require("crypto"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function md5(bytes) {
      if (Array.isArray(bytes)) {
        bytes = Buffer.from(bytes);
      } else if (typeof bytes === "string") {
        bytes = Buffer.from(bytes, "utf8");
      }
      return _crypto.default.createHash("md5").update(bytes).digest();
    }
    var _default = md5;
    exports.default = _default;
    module2.exports = exports.default;
  }
});

// node_modules/uuid/dist/v3.js
var require_v3 = __commonJS({
  "node_modules/uuid/dist/v3.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _v = _interopRequireDefault(require_v35());
    var _md = _interopRequireDefault(require_md5());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var v3 = (0, _v.default)("v3", 48, _md.default);
    var _default = v3;
    exports.default = _default;
    module2.exports = exports.default;
  }
});

// node_modules/uuid/dist/v4.js
var require_v4 = __commonJS({
  "node_modules/uuid/dist/v4.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _rng = _interopRequireDefault(require_rng());
    var _bytesToUuid = _interopRequireDefault(require_bytesToUuid());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function v4(options, buf, offset) {
      var i = buf && offset || 0;
      if (typeof options == "string") {
        buf = options === "binary" ? new Array(16) : null;
        options = null;
      }
      options = options || {};
      var rnds = options.random || (options.rng || _rng.default)();
      rnds[6] = rnds[6] & 15 | 64;
      rnds[8] = rnds[8] & 63 | 128;
      if (buf) {
        for (var ii = 0; ii < 16; ++ii) {
          buf[i + ii] = rnds[ii];
        }
      }
      return buf || (0, _bytesToUuid.default)(rnds);
    }
    var _default = v4;
    exports.default = _default;
    module2.exports = exports.default;
  }
});

// node_modules/uuid/dist/sha1.js
var require_sha1 = __commonJS({
  "node_modules/uuid/dist/sha1.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _crypto = _interopRequireDefault(require("crypto"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function sha1(bytes) {
      if (Array.isArray(bytes)) {
        bytes = Buffer.from(bytes);
      } else if (typeof bytes === "string") {
        bytes = Buffer.from(bytes, "utf8");
      }
      return _crypto.default.createHash("sha1").update(bytes).digest();
    }
    var _default = sha1;
    exports.default = _default;
    module2.exports = exports.default;
  }
});

// node_modules/uuid/dist/v5.js
var require_v5 = __commonJS({
  "node_modules/uuid/dist/v5.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _v = _interopRequireDefault(require_v35());
    var _sha = _interopRequireDefault(require_sha1());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var v5 = (0, _v.default)("v5", 80, _sha.default);
    var _default = v5;
    exports.default = _default;
    module2.exports = exports.default;
  }
});

// node_modules/uuid/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/uuid/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "v1", {
      enumerable: true,
      get: function() {
        return _v.default;
      }
    });
    Object.defineProperty(exports, "v3", {
      enumerable: true,
      get: function() {
        return _v2.default;
      }
    });
    Object.defineProperty(exports, "v4", {
      enumerable: true,
      get: function() {
        return _v3.default;
      }
    });
    Object.defineProperty(exports, "v5", {
      enumerable: true,
      get: function() {
        return _v4.default;
      }
    });
    var _v = _interopRequireDefault(require_v1());
    var _v2 = _interopRequireDefault(require_v3());
    var _v3 = _interopRequireDefault(require_v4());
    var _v4 = _interopRequireDefault(require_v5());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
  }
});

// node_modules/thrift/lib/nodejs/lib/thrift/thrift.js
var require_thrift = __commonJS({
  "node_modules/thrift/lib/nodejs/lib/thrift/thrift.js"(exports, module2) {
    var util = require("util");
    var Type = exports.Type = {
      STOP: 0,
      VOID: 1,
      BOOL: 2,
      BYTE: 3,
      I08: 3,
      DOUBLE: 4,
      I16: 6,
      I32: 8,
      I64: 10,
      STRING: 11,
      UTF7: 11,
      STRUCT: 12,
      MAP: 13,
      SET: 14,
      LIST: 15,
      UTF8: 16,
      UTF16: 17
    };
    exports.MessageType = {
      CALL: 1,
      REPLY: 2,
      EXCEPTION: 3,
      ONEWAY: 4
    };
    exports.TException = TException;
    function TException(message) {
      Error.call(this);
      if (Error.captureStackTrace !== void 0) {
        Error.captureStackTrace(this, this.constructor);
      }
      this.name = this.constructor.name;
      this.message = message;
    }
    util.inherits(TException, Error);
    var TApplicationExceptionType = exports.TApplicationExceptionType = {
      UNKNOWN: 0,
      UNKNOWN_METHOD: 1,
      INVALID_MESSAGE_TYPE: 2,
      WRONG_METHOD_NAME: 3,
      BAD_SEQUENCE_ID: 4,
      MISSING_RESULT: 5,
      INTERNAL_ERROR: 6,
      PROTOCOL_ERROR: 7,
      INVALID_TRANSFORM: 8,
      INVALID_PROTOCOL: 9,
      UNSUPPORTED_CLIENT_TYPE: 10
    };
    exports.TApplicationException = TApplicationException;
    function TApplicationException(type, message) {
      TException.call(this);
      if (Error.captureStackTrace !== void 0) {
        Error.captureStackTrace(this, this.constructor);
      }
      this.type = type || TApplicationExceptionType.UNKNOWN;
      this.name = this.constructor.name;
      this.message = message;
    }
    util.inherits(TApplicationException, TException);
    TApplicationException.prototype.read = function(input) {
      var ftype;
      var ret = input.readStructBegin("TApplicationException");
      while (1) {
        ret = input.readFieldBegin();
        if (ret.ftype == Type.STOP)
          break;
        switch (ret.fid) {
          case 1:
            if (ret.ftype == Type.STRING) {
              ret = input.readString();
              this.message = ret;
            } else {
              ret = input.skip(ret.ftype);
            }
            break;
          case 2:
            if (ret.ftype == Type.I32) {
              ret = input.readI32();
              this.type = ret;
            } else {
              ret = input.skip(ret.ftype);
            }
            break;
          default:
            ret = input.skip(ret.ftype);
            break;
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
    };
    TApplicationException.prototype.write = function(output) {
      output.writeStructBegin("TApplicationException");
      if (this.message) {
        output.writeFieldBegin("message", Type.STRING, 1);
        output.writeString(this.message);
        output.writeFieldEnd();
      }
      if (this.code) {
        output.writeFieldBegin("type", Type.I32, 2);
        output.writeI32(this.code);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
    };
    var TProtocolExceptionType = exports.TProtocolExceptionType = {
      UNKNOWN: 0,
      INVALID_DATA: 1,
      NEGATIVE_SIZE: 2,
      SIZE_LIMIT: 3,
      BAD_VERSION: 4,
      NOT_IMPLEMENTED: 5,
      DEPTH_LIMIT: 6
    };
    exports.TProtocolException = TProtocolException;
    function TProtocolException(type, message) {
      Error.call(this);
      if (Error.captureStackTrace !== void 0) {
        Error.captureStackTrace(this, this.constructor);
      }
      this.name = this.constructor.name;
      this.type = type;
      this.message = message;
    }
    util.inherits(TProtocolException, Error);
    exports.objectLength = function(obj) {
      return Object.keys(obj).length;
    };
    exports.inherits = function(constructor, superConstructor) {
      util.inherits(constructor, superConstructor);
    };
    var copyList;
    var copyMap;
    copyList = function(lst, types) {
      if (!lst) {
        return lst;
      }
      var type;
      if (types.shift === void 0) {
        type = types;
      } else {
        type = types[0];
      }
      var Type2 = type;
      var len = lst.length, result = [], i, val;
      for (i = 0; i < len; i++) {
        val = lst[i];
        if (type === null) {
          result.push(val);
        } else if (type === copyMap || type === copyList) {
          result.push(type(val, types.slice(1)));
        } else {
          result.push(new Type2(val));
        }
      }
      return result;
    };
    copyMap = function(obj, types) {
      if (!obj) {
        return obj;
      }
      var type;
      if (types.shift === void 0) {
        type = types;
      } else {
        type = types[0];
      }
      var Type2 = type;
      var result = {}, val;
      for (var prop in obj) {
        if (obj.hasOwnProperty(prop)) {
          val = obj[prop];
          if (type === null) {
            result[prop] = val;
          } else if (type === copyMap || type === copyList) {
            result[prop] = type(val, types.slice(1));
          } else {
            result[prop] = new Type2(val);
          }
        }
      }
      return result;
    };
    module2.exports.copyMap = copyMap;
    module2.exports.copyList = copyList;
  }
});

// node_modules/thrift/lib/nodejs/lib/thrift/log.js
var require_log = __commonJS({
  "node_modules/thrift/lib/nodejs/lib/thrift/log.js"(exports) {
    var util = require("util");
    var disabled = function() {
    };
    var logFunc = console.log;
    var logLevel = "error";
    function factory(level) {
      return function() {
        var args = ["thrift: [" + level + "] "].concat(Array.from(arguments));
        return logFunc(util.format.apply(null, args));
      };
    }
    var trace = disabled;
    var debug = disabled;
    var error = disabled;
    var warning = disabled;
    var info = disabled;
    exports.setLogFunc = function(func) {
      logFunc = func;
    };
    var setLogLevel = exports.setLogLevel = function(level) {
      trace = debug = error = warning = info = disabled;
      logLevel = level;
      switch (logLevel) {
        case "trace":
          trace = factory("TRACE");
        case "debug":
          debug = factory("DEBUG");
        case "error":
          error = factory("ERROR");
        case "warning":
          warning = factory("WARN");
        case "info":
          info = factory("INFO");
      }
    };
    setLogLevel(logLevel);
    exports.getLogLevel = function() {
      return logLevel;
    };
    exports.trace = function() {
      return trace.apply(null, arguments);
    };
    exports.debug = function() {
      return debug.apply(null, arguments);
    };
    exports.error = function() {
      return error.apply(null, arguments);
    };
    exports.warning = function() {
      return warning.apply(null, arguments);
    };
    exports.info = function() {
      return info.apply(null, arguments);
    };
  }
});

// node_modules/thrift/lib/nodejs/lib/thrift/binary.js
var require_binary = __commonJS({
  "node_modules/thrift/lib/nodejs/lib/thrift/binary.js"(exports) {
    var POW_8 = Math.pow(2, 8);
    var POW_16 = Math.pow(2, 16);
    var POW_24 = Math.pow(2, 24);
    var POW_32 = Math.pow(2, 32);
    var POW_40 = Math.pow(2, 40);
    var POW_48 = Math.pow(2, 48);
    var POW_52 = Math.pow(2, 52);
    var POW_1022 = Math.pow(2, 1022);
    exports.readByte = function(b) {
      return b > 127 ? b - 256 : b;
    };
    exports.readI16 = function(buff, off) {
      off = off || 0;
      var v = buff[off + 1];
      v += buff[off] << 8;
      if (buff[off] & 128) {
        v -= POW_16;
      }
      return v;
    };
    exports.readI32 = function(buff, off) {
      off = off || 0;
      var v = buff[off + 3];
      v += buff[off + 2] << 8;
      v += buff[off + 1] << 16;
      v += buff[off] * POW_24;
      if (buff[off] & 128) {
        v -= POW_32;
      }
      return v;
    };
    exports.writeI16 = function(buff, v) {
      buff[1] = v & 255;
      v >>= 8;
      buff[0] = v & 255;
      return buff;
    };
    exports.writeI32 = function(buff, v) {
      buff[3] = v & 255;
      v >>= 8;
      buff[2] = v & 255;
      v >>= 8;
      buff[1] = v & 255;
      v >>= 8;
      buff[0] = v & 255;
      return buff;
    };
    exports.readDouble = function(buff, off) {
      off = off || 0;
      var signed = buff[off] & 128;
      var e = (buff[off + 1] & 240) >> 4;
      e += (buff[off] & 127) << 4;
      var m = buff[off + 7];
      m += buff[off + 6] << 8;
      m += buff[off + 5] << 16;
      m += buff[off + 4] * POW_24;
      m += buff[off + 3] * POW_32;
      m += buff[off + 2] * POW_40;
      m += (buff[off + 1] & 15) * POW_48;
      switch (e) {
        case 0:
          e = -1022;
          break;
        case 2047:
          return m ? NaN : signed ? -Infinity : Infinity;
        default:
          m += POW_52;
          e -= 1023;
      }
      if (signed) {
        m *= -1;
      }
      return m * Math.pow(2, e - 52);
    };
    exports.writeDouble = function(buff, v) {
      var m, e, c;
      buff[0] = v < 0 ? 128 : 0;
      v = Math.abs(v);
      if (v !== v) {
        m = 2251799813685248;
        e = 2047;
      } else if (v === Infinity) {
        m = 0;
        e = 2047;
      } else {
        e = Math.floor(Math.log(v) / Math.LN2);
        c = Math.pow(2, -e);
        if (v * c < 1) {
          e--;
          c *= 2;
        }
        if (e + 1023 >= 2047) {
          m = 0;
          e = 2047;
        } else if (e + 1023 >= 1) {
          m = (v * c - 1) * POW_52;
          e += 1023;
        } else {
          m = v * POW_1022 * POW_52;
          e = 0;
        }
      }
      buff[1] = e << 4 & 240;
      buff[0] |= e >> 4 & 127;
      buff[7] = m & 255;
      m = Math.floor(m / POW_8);
      buff[6] = m & 255;
      m = Math.floor(m / POW_8);
      buff[5] = m & 255;
      m = Math.floor(m / POW_8);
      buff[4] = m & 255;
      m >>= 8;
      buff[3] = m & 255;
      m >>= 8;
      buff[2] = m & 255;
      m >>= 8;
      buff[1] |= m & 15;
      return buff;
    };
  }
});

// node_modules/thrift/lib/nodejs/lib/thrift/input_buffer_underrun_error.js
var require_input_buffer_underrun_error = __commonJS({
  "node_modules/thrift/lib/nodejs/lib/thrift/input_buffer_underrun_error.js"(exports, module2) {
    var util = require("util");
    module2.exports = InputBufferUnderrunError;
    function InputBufferUnderrunError(message) {
      Error.call(this);
      if (Error.captureStackTrace !== void 0) {
        Error.captureStackTrace(this, this.constructor);
      }
      this.name = this.constructor.name;
      this.message = message;
    }
    util.inherits(InputBufferUnderrunError, Error);
  }
});

// node_modules/node-int64/Int64.js
var require_Int64 = __commonJS({
  "node_modules/node-int64/Int64.js"(exports, module2) {
    var VAL32 = 4294967296;
    var _HEX = [];
    for (i = 0; i < 256; i++) {
      _HEX[i] = (i > 15 ? "" : "0") + i.toString(16);
    }
    var i;
    var Int64 = module2.exports = function(a1, a2) {
      if (a1 instanceof Buffer) {
        this.buffer = a1;
        this.offset = a2 || 0;
      } else if (Object.prototype.toString.call(a1) == "[object Uint8Array]") {
        this.buffer = new Buffer(a1);
        this.offset = a2 || 0;
      } else {
        this.buffer = this.buffer || new Buffer(8);
        this.offset = 0;
        this.setValue.apply(this, arguments);
      }
    };
    Int64.MAX_INT = Math.pow(2, 53);
    Int64.MIN_INT = -Math.pow(2, 53);
    Int64.prototype = {
      constructor: Int64,
      _2scomp: function() {
        var b = this.buffer, o = this.offset, carry = 1;
        for (var i2 = o + 7; i2 >= o; i2--) {
          var v = (b[i2] ^ 255) + carry;
          b[i2] = v & 255;
          carry = v >> 8;
        }
      },
      setValue: function(hi, lo) {
        var negate = false;
        if (arguments.length == 1) {
          if (typeof hi == "number") {
            negate = hi < 0;
            hi = Math.abs(hi);
            lo = hi % VAL32;
            hi = hi / VAL32;
            if (hi > VAL32)
              throw new RangeError(hi + " is outside Int64 range");
            hi = hi | 0;
          } else if (typeof hi == "string") {
            hi = (hi + "").replace(/^0x/, "");
            lo = hi.substr(-8);
            hi = hi.length > 8 ? hi.substr(0, hi.length - 8) : "";
            hi = parseInt(hi, 16);
            lo = parseInt(lo, 16);
          } else {
            throw new Error(hi + " must be a Number or String");
          }
        }
        var b = this.buffer, o = this.offset;
        for (var i2 = 7; i2 >= 0; i2--) {
          b[o + i2] = lo & 255;
          lo = i2 == 4 ? hi : lo >>> 8;
        }
        if (negate)
          this._2scomp();
      },
      toNumber: function(allowImprecise) {
        var b = this.buffer, o = this.offset;
        var negate = b[o] & 128, x = 0, carry = 1;
        for (var i2 = 7, m = 1; i2 >= 0; i2--, m *= 256) {
          var v = b[o + i2];
          if (negate) {
            v = (v ^ 255) + carry;
            carry = v >> 8;
            v = v & 255;
          }
          x += v * m;
        }
        if (!allowImprecise && x >= Int64.MAX_INT) {
          return negate ? -Infinity : Infinity;
        }
        return negate ? -x : x;
      },
      valueOf: function() {
        return this.toNumber(false);
      },
      toString: function(radix) {
        return this.valueOf().toString(radix || 10);
      },
      toOctetString: function(sep) {
        var out = new Array(8);
        var b = this.buffer, o = this.offset;
        for (var i2 = 0; i2 < 8; i2++) {
          out[i2] = _HEX[b[o + i2]];
        }
        return out.join(sep || "");
      },
      toBuffer: function(rawBuffer) {
        if (rawBuffer && this.offset === 0)
          return this.buffer;
        var out = new Buffer(8);
        this.buffer.copy(out, 0, this.offset, this.offset + 8);
        return out;
      },
      copy: function(targetBuffer, targetOffset) {
        this.buffer.copy(targetBuffer, targetOffset || 0, this.offset, this.offset + 8);
      },
      compare: function(other) {
        if ((this.buffer[this.offset] & 128) != (other.buffer[other.offset] & 128)) {
          return other.buffer[other.offset] - this.buffer[this.offset];
        }
        for (var i2 = 0; i2 < 8; i2++) {
          if (this.buffer[this.offset + i2] !== other.buffer[other.offset + i2]) {
            return this.buffer[this.offset + i2] - other.buffer[other.offset + i2];
          }
        }
        return 0;
      },
      equals: function(other) {
        return this.compare(other) === 0;
      },
      inspect: function() {
        return "[Int64 value:" + this + " octets:" + this.toOctetString(" ") + "]";
      }
    };
  }
});

// node_modules/thrift/lib/nodejs/lib/thrift/compact_protocol.js
var require_compact_protocol = __commonJS({
  "node_modules/thrift/lib/nodejs/lib/thrift/compact_protocol.js"(exports, module2) {
    var log = require_log();
    var Int64 = require_Int64();
    var Thrift = require_thrift();
    var Type = Thrift.Type;
    module2.exports = TCompactProtocol;
    var POW_8 = Math.pow(2, 8);
    var POW_24 = Math.pow(2, 24);
    var POW_32 = Math.pow(2, 32);
    var POW_40 = Math.pow(2, 40);
    var POW_48 = Math.pow(2, 48);
    var POW_52 = Math.pow(2, 52);
    var POW_1022 = Math.pow(2, 1022);
    function TCompactProtocol(trans) {
      this.trans = trans;
      this.lastField_ = [];
      this.lastFieldId_ = 0;
      this.string_limit_ = 0;
      this.string_buf_ = null;
      this.string_buf_size_ = 0;
      this.container_limit_ = 0;
      this.booleanField_ = {
        name: null,
        hasBoolValue: false
      };
      this.boolValue_ = {
        hasBoolValue: false,
        boolValue: false
      };
    }
    TCompactProtocol.PROTOCOL_ID = -126;
    TCompactProtocol.VERSION_N = 1;
    TCompactProtocol.VERSION_MASK = 31;
    TCompactProtocol.TYPE_MASK = -32;
    TCompactProtocol.TYPE_BITS = 7;
    TCompactProtocol.TYPE_SHIFT_AMOUNT = 5;
    TCompactProtocol.Types = {
      CT_STOP: 0,
      CT_BOOLEAN_TRUE: 1,
      CT_BOOLEAN_FALSE: 2,
      CT_BYTE: 3,
      CT_I16: 4,
      CT_I32: 5,
      CT_I64: 6,
      CT_DOUBLE: 7,
      CT_BINARY: 8,
      CT_LIST: 9,
      CT_SET: 10,
      CT_MAP: 11,
      CT_STRUCT: 12
    };
    TCompactProtocol.TTypeToCType = [
      TCompactProtocol.Types.CT_STOP,
      0,
      TCompactProtocol.Types.CT_BOOLEAN_TRUE,
      TCompactProtocol.Types.CT_BYTE,
      TCompactProtocol.Types.CT_DOUBLE,
      0,
      TCompactProtocol.Types.CT_I16,
      0,
      TCompactProtocol.Types.CT_I32,
      0,
      TCompactProtocol.Types.CT_I64,
      TCompactProtocol.Types.CT_BINARY,
      TCompactProtocol.Types.CT_STRUCT,
      TCompactProtocol.Types.CT_MAP,
      TCompactProtocol.Types.CT_SET,
      TCompactProtocol.Types.CT_LIST
    ];
    TCompactProtocol.prototype.getTransport = function() {
      return this.trans;
    };
    TCompactProtocol.prototype.getCompactType = function(ttype) {
      return TCompactProtocol.TTypeToCType[ttype];
    };
    TCompactProtocol.prototype.getTType = function(type) {
      switch (type) {
        case Type.STOP:
          return Type.STOP;
        case TCompactProtocol.Types.CT_BOOLEAN_FALSE:
        case TCompactProtocol.Types.CT_BOOLEAN_TRUE:
          return Type.BOOL;
        case TCompactProtocol.Types.CT_BYTE:
          return Type.BYTE;
        case TCompactProtocol.Types.CT_I16:
          return Type.I16;
        case TCompactProtocol.Types.CT_I32:
          return Type.I32;
        case TCompactProtocol.Types.CT_I64:
          return Type.I64;
        case TCompactProtocol.Types.CT_DOUBLE:
          return Type.DOUBLE;
        case TCompactProtocol.Types.CT_BINARY:
          return Type.STRING;
        case TCompactProtocol.Types.CT_LIST:
          return Type.LIST;
        case TCompactProtocol.Types.CT_SET:
          return Type.SET;
        case TCompactProtocol.Types.CT_MAP:
          return Type.MAP;
        case TCompactProtocol.Types.CT_STRUCT:
          return Type.STRUCT;
        default:
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.INVALID_DATA, "Unknown type: " + type);
      }
      return Type.STOP;
    };
    TCompactProtocol.prototype.flush = function() {
      return this.trans.flush();
    };
    TCompactProtocol.prototype.writeMessageBegin = function(name, type, seqid) {
      this.writeByte(TCompactProtocol.PROTOCOL_ID);
      this.writeByte(TCompactProtocol.VERSION_N & TCompactProtocol.VERSION_MASK | type << TCompactProtocol.TYPE_SHIFT_AMOUNT & TCompactProtocol.TYPE_MASK);
      this.writeVarint32(seqid);
      this.writeString(name);
      if (this._seqid) {
        log.warning("SeqId already set", { "name": name });
      } else {
        this._seqid = seqid;
        this.trans.setCurrSeqId(seqid);
      }
    };
    TCompactProtocol.prototype.writeMessageEnd = function() {
    };
    TCompactProtocol.prototype.writeStructBegin = function(name) {
      this.lastField_.push(this.lastFieldId_);
      this.lastFieldId_ = 0;
    };
    TCompactProtocol.prototype.writeStructEnd = function() {
      this.lastFieldId_ = this.lastField_.pop();
    };
    TCompactProtocol.prototype.writeFieldBegin = function(name, type, id) {
      if (type != Type.BOOL) {
        return this.writeFieldBeginInternal(name, type, id, -1);
      }
      this.booleanField_.name = name;
      this.booleanField_.fieldType = type;
      this.booleanField_.fieldId = id;
    };
    TCompactProtocol.prototype.writeFieldEnd = function() {
    };
    TCompactProtocol.prototype.writeFieldStop = function() {
      this.writeByte(TCompactProtocol.Types.CT_STOP);
    };
    TCompactProtocol.prototype.writeMapBegin = function(keyType, valType, size) {
      if (size === 0) {
        this.writeByte(0);
      } else {
        this.writeVarint32(size);
        this.writeByte(this.getCompactType(keyType) << 4 | this.getCompactType(valType));
      }
    };
    TCompactProtocol.prototype.writeMapEnd = function() {
    };
    TCompactProtocol.prototype.writeListBegin = function(elemType, size) {
      this.writeCollectionBegin(elemType, size);
    };
    TCompactProtocol.prototype.writeListEnd = function() {
    };
    TCompactProtocol.prototype.writeSetBegin = function(elemType, size) {
      this.writeCollectionBegin(elemType, size);
    };
    TCompactProtocol.prototype.writeSetEnd = function() {
    };
    TCompactProtocol.prototype.writeBool = function(value) {
      if (this.booleanField_.name !== null) {
        this.writeFieldBeginInternal(
          this.booleanField_.name,
          this.booleanField_.fieldType,
          this.booleanField_.fieldId,
          value ? TCompactProtocol.Types.CT_BOOLEAN_TRUE : TCompactProtocol.Types.CT_BOOLEAN_FALSE
        );
        this.booleanField_.name = null;
      } else {
        this.writeByte(value ? TCompactProtocol.Types.CT_BOOLEAN_TRUE : TCompactProtocol.Types.CT_BOOLEAN_FALSE);
      }
    };
    TCompactProtocol.prototype.writeByte = function(b) {
      this.trans.write(new Buffer([b]));
    };
    TCompactProtocol.prototype.writeI16 = function(i16) {
      this.writeVarint32(this.i32ToZigzag(i16));
    };
    TCompactProtocol.prototype.writeI32 = function(i32) {
      this.writeVarint32(this.i32ToZigzag(i32));
    };
    TCompactProtocol.prototype.writeI64 = function(i64) {
      this.writeVarint64(this.i64ToZigzag(i64));
    };
    TCompactProtocol.prototype.writeDouble = function(v) {
      var buff = new Buffer(8);
      var m, e, c;
      buff[7] = v < 0 ? 128 : 0;
      v = Math.abs(v);
      if (v !== v) {
        m = 2251799813685248;
        e = 2047;
      } else if (v === Infinity) {
        m = 0;
        e = 2047;
      } else {
        e = Math.floor(Math.log(v) / Math.LN2);
        c = Math.pow(2, -e);
        if (v * c < 1) {
          e--;
          c *= 2;
        }
        if (e + 1023 >= 2047) {
          m = 0;
          e = 2047;
        } else if (e + 1023 >= 1) {
          m = (v * c - 1) * POW_52;
          e += 1023;
        } else {
          m = v * POW_1022 * POW_52;
          e = 0;
        }
      }
      buff[6] = e << 4 & 240;
      buff[7] |= e >> 4 & 127;
      buff[0] = m & 255;
      m = Math.floor(m / POW_8);
      buff[1] = m & 255;
      m = Math.floor(m / POW_8);
      buff[2] = m & 255;
      m = Math.floor(m / POW_8);
      buff[3] = m & 255;
      m >>= 8;
      buff[4] = m & 255;
      m >>= 8;
      buff[5] = m & 255;
      m >>= 8;
      buff[6] |= m & 15;
      this.trans.write(buff);
    };
    TCompactProtocol.prototype.writeStringOrBinary = function(name, encoding, arg) {
      if (typeof arg === "string") {
        this.writeVarint32(Buffer.byteLength(arg, encoding));
        this.trans.write(new Buffer(arg, encoding));
      } else if (arg instanceof Buffer || Object.prototype.toString.call(arg) == "[object Uint8Array]") {
        this.writeVarint32(arg.length);
        this.trans.write(arg);
      } else {
        throw new Error(name + " called without a string/Buffer argument: " + arg);
      }
    };
    TCompactProtocol.prototype.writeString = function(arg) {
      this.writeStringOrBinary("writeString", "utf8", arg);
    };
    TCompactProtocol.prototype.writeBinary = function(arg) {
      this.writeStringOrBinary("writeBinary", "binary", arg);
    };
    TCompactProtocol.prototype.writeFieldBeginInternal = function(name, fieldType, fieldId, typeOverride) {
      var typeToWrite = typeOverride == -1 ? this.getCompactType(fieldType) : typeOverride;
      if (fieldId > this.lastFieldId_ && fieldId - this.lastFieldId_ <= 15) {
        this.writeByte(fieldId - this.lastFieldId_ << 4 | typeToWrite);
      } else {
        this.writeByte(typeToWrite);
        this.writeI16(fieldId);
      }
      this.lastFieldId_ = fieldId;
    };
    TCompactProtocol.prototype.writeCollectionBegin = function(elemType, size) {
      if (size <= 14) {
        this.writeByte(size << 4 | this.getCompactType(elemType));
      } else {
        this.writeByte(240 | this.getCompactType(elemType));
        this.writeVarint32(size);
      }
    };
    TCompactProtocol.prototype.writeVarint32 = function(n) {
      var buf = new Buffer(5);
      var wsize = 0;
      while (true) {
        if ((n & ~127) === 0) {
          buf[wsize++] = n;
          break;
        } else {
          buf[wsize++] = n & 127 | 128;
          n = n >>> 7;
        }
      }
      var wbuf = new Buffer(wsize);
      buf.copy(wbuf, 0, 0, wsize);
      this.trans.write(wbuf);
    };
    TCompactProtocol.prototype.writeVarint64 = function(n) {
      if (typeof n === "number") {
        n = new Int64(n);
      }
      if (!(n instanceof Int64)) {
        throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.INVALID_DATA, "Expected Int64 or Number, found: " + n);
      }
      var buf = new Buffer(10);
      var wsize = 0;
      var hi = n.buffer.readUInt32BE(0, true);
      var lo = n.buffer.readUInt32BE(4, true);
      var mask = 0;
      while (true) {
        if ((lo & ~127) === 0 && hi === 0) {
          buf[wsize++] = lo;
          break;
        } else {
          buf[wsize++] = lo & 127 | 128;
          mask = hi << 25;
          lo = lo >>> 7;
          hi = hi >>> 7;
          lo = lo | mask;
        }
      }
      var wbuf = new Buffer(wsize);
      buf.copy(wbuf, 0, 0, wsize);
      this.trans.write(wbuf);
    };
    TCompactProtocol.prototype.i64ToZigzag = function(l) {
      if (typeof l === "string") {
        l = new Int64(parseInt(l, 10));
      } else if (typeof l === "number") {
        l = new Int64(l);
      }
      if (!(l instanceof Int64)) {
        throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.INVALID_DATA, "Expected Int64 or Number, found: " + l);
      }
      var hi = l.buffer.readUInt32BE(0, true);
      var lo = l.buffer.readUInt32BE(4, true);
      var sign = hi >>> 31;
      hi = (hi << 1 | lo >>> 31) ^ (!!sign ? 4294967295 : 0);
      lo = lo << 1 ^ (!!sign ? 4294967295 : 0);
      return new Int64(hi, lo);
    };
    TCompactProtocol.prototype.i32ToZigzag = function(n) {
      return n << 1 ^ (n & 2147483648 ? 4294967295 : 0);
    };
    TCompactProtocol.prototype.readMessageBegin = function() {
      var protocolId = this.trans.readByte();
      if (protocolId != TCompactProtocol.PROTOCOL_ID) {
        throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.BAD_VERSION, "Bad protocol identifier " + protocolId);
      }
      var versionAndType = this.trans.readByte();
      var version = versionAndType & TCompactProtocol.VERSION_MASK;
      if (version != TCompactProtocol.VERSION_N) {
        throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.BAD_VERSION, "Bad protocol version " + version);
      }
      var type = versionAndType >> TCompactProtocol.TYPE_SHIFT_AMOUNT & TCompactProtocol.TYPE_BITS;
      var seqid = this.readVarint32();
      var name = this.readString();
      return { fname: name, mtype: type, rseqid: seqid };
    };
    TCompactProtocol.prototype.readMessageEnd = function() {
    };
    TCompactProtocol.prototype.readStructBegin = function() {
      this.lastField_.push(this.lastFieldId_);
      this.lastFieldId_ = 0;
      return { fname: "" };
    };
    TCompactProtocol.prototype.readStructEnd = function() {
      this.lastFieldId_ = this.lastField_.pop();
    };
    TCompactProtocol.prototype.readFieldBegin = function() {
      var fieldId = 0;
      var b = this.trans.readByte(b);
      var type = b & 15;
      if (type == TCompactProtocol.Types.CT_STOP) {
        return { fname: null, ftype: Thrift.Type.STOP, fid: 0 };
      }
      var modifier = (b & 240) >>> 4;
      if (modifier === 0) {
        fieldId = this.readI16();
      } else {
        fieldId = this.lastFieldId_ + modifier;
      }
      var fieldType = this.getTType(type);
      if (type == TCompactProtocol.Types.CT_BOOLEAN_TRUE || type == TCompactProtocol.Types.CT_BOOLEAN_FALSE) {
        this.boolValue_.hasBoolValue = true;
        this.boolValue_.boolValue = type == TCompactProtocol.Types.CT_BOOLEAN_TRUE ? true : false;
      }
      this.lastFieldId_ = fieldId;
      return { fname: null, ftype: fieldType, fid: fieldId };
    };
    TCompactProtocol.prototype.readFieldEnd = function() {
    };
    TCompactProtocol.prototype.readMapBegin = function() {
      var msize = this.readVarint32();
      if (msize < 0) {
        throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.NEGATIVE_SIZE, "Negative map size");
      }
      var kvType = 0;
      if (msize !== 0) {
        kvType = this.trans.readByte();
      }
      var keyType = this.getTType((kvType & 240) >>> 4);
      var valType = this.getTType(kvType & 15);
      return { ktype: keyType, vtype: valType, size: msize };
    };
    TCompactProtocol.prototype.readMapEnd = function() {
    };
    TCompactProtocol.prototype.readListBegin = function() {
      var size_and_type = this.trans.readByte();
      var lsize = size_and_type >>> 4 & 15;
      if (lsize == 15) {
        lsize = this.readVarint32();
      }
      if (lsize < 0) {
        throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.NEGATIVE_SIZE, "Negative list size");
      }
      var elemType = this.getTType(size_and_type & 15);
      return { etype: elemType, size: lsize };
    };
    TCompactProtocol.prototype.readListEnd = function() {
    };
    TCompactProtocol.prototype.readSetBegin = function() {
      return this.readListBegin();
    };
    TCompactProtocol.prototype.readSetEnd = function() {
    };
    TCompactProtocol.prototype.readBool = function() {
      var value = false;
      var rsize = 0;
      if (this.boolValue_.hasBoolValue === true) {
        value = this.boolValue_.boolValue;
        this.boolValue_.hasBoolValue = false;
      } else {
        var res = this.trans.readByte();
        rsize = res.rsize;
        value = res.value == TCompactProtocol.Types.CT_BOOLEAN_TRUE;
      }
      return value;
    };
    TCompactProtocol.prototype.readByte = function() {
      return this.trans.readByte();
    };
    TCompactProtocol.prototype.readI16 = function() {
      return this.readI32();
    };
    TCompactProtocol.prototype.readI32 = function() {
      return this.zigzagToI32(this.readVarint32());
    };
    TCompactProtocol.prototype.readI64 = function() {
      return this.zigzagToI64(this.readVarint64());
    };
    TCompactProtocol.prototype.readDouble = function() {
      var buff = this.trans.read(8);
      var off = 0;
      var signed = buff[off + 7] & 128;
      var e = (buff[off + 6] & 240) >> 4;
      e += (buff[off + 7] & 127) << 4;
      var m = buff[off];
      m += buff[off + 1] << 8;
      m += buff[off + 2] << 16;
      m += buff[off + 3] * POW_24;
      m += buff[off + 4] * POW_32;
      m += buff[off + 5] * POW_40;
      m += (buff[off + 6] & 15) * POW_48;
      switch (e) {
        case 0:
          e = -1022;
          break;
        case 2047:
          return m ? NaN : signed ? -Infinity : Infinity;
        default:
          m += POW_52;
          e -= 1023;
      }
      if (signed) {
        m *= -1;
      }
      return m * Math.pow(2, e - 52);
    };
    TCompactProtocol.prototype.readBinary = function() {
      var size = this.readVarint32();
      if (size === 0) {
        return new Buffer(0);
      }
      if (size < 0) {
        throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.NEGATIVE_SIZE, "Negative binary size");
      }
      return this.trans.read(size);
    };
    TCompactProtocol.prototype.readString = function() {
      var size = this.readVarint32();
      if (size === 0) {
        return "";
      }
      if (size < 0) {
        throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.NEGATIVE_SIZE, "Negative string size");
      }
      return this.trans.readString(size);
    };
    TCompactProtocol.prototype.readVarint32 = function() {
      return this.readVarint64().toNumber();
    };
    TCompactProtocol.prototype.readVarint64 = function() {
      var rsize = 0;
      var lo = 0;
      var hi = 0;
      var shift = 0;
      while (true) {
        var b = this.trans.readByte();
        rsize++;
        if (shift <= 25) {
          lo = lo | (b & 127) << shift;
        } else if (25 < shift && shift < 32) {
          lo = lo | (b & 127) << shift;
          hi = hi | (b & 127) >>> 32 - shift;
        } else {
          hi = hi | (b & 127) << shift - 32;
        }
        shift += 7;
        if (!(b & 128)) {
          break;
        }
        if (rsize >= 10) {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.INVALID_DATA, "Variable-length int over 10 bytes.");
        }
      }
      return new Int64(hi, lo);
    };
    TCompactProtocol.prototype.zigzagToI32 = function(n) {
      return n >>> 1 ^ -1 * (n & 1);
    };
    TCompactProtocol.prototype.zigzagToI64 = function(n) {
      var hi = n.buffer.readUInt32BE(0, true);
      var lo = n.buffer.readUInt32BE(4, true);
      var neg = new Int64(hi & 0, lo & 1);
      neg._2scomp();
      var hi_neg = neg.buffer.readUInt32BE(0, true);
      var lo_neg = neg.buffer.readUInt32BE(4, true);
      var hi_lo = hi << 31;
      hi = hi >>> 1 ^ hi_neg;
      lo = (lo >>> 1 | hi_lo) ^ lo_neg;
      return new Int64(hi, lo);
    };
    TCompactProtocol.prototype.skip = function(type) {
      switch (type) {
        case Type.BOOL:
          this.readBool();
          break;
        case Type.BYTE:
          this.readByte();
          break;
        case Type.I16:
          this.readI16();
          break;
        case Type.I32:
          this.readI32();
          break;
        case Type.I64:
          this.readI64();
          break;
        case Type.DOUBLE:
          this.readDouble();
          break;
        case Type.STRING:
          this.readString();
          break;
        case Type.STRUCT:
          this.readStructBegin();
          while (true) {
            var r = this.readFieldBegin();
            if (r.ftype === Type.STOP) {
              break;
            }
            this.skip(r.ftype);
            this.readFieldEnd();
          }
          this.readStructEnd();
          break;
        case Type.MAP:
          var mapBegin = this.readMapBegin();
          for (var i = 0; i < mapBegin.size; ++i) {
            this.skip(mapBegin.ktype);
            this.skip(mapBegin.vtype);
          }
          this.readMapEnd();
          break;
        case Type.SET:
          var setBegin = this.readSetBegin();
          for (var i2 = 0; i2 < setBegin.size; ++i2) {
            this.skip(setBegin.etype);
          }
          this.readSetEnd();
          break;
        case Type.LIST:
          var listBegin = this.readListBegin();
          for (var i3 = 0; i3 < listBegin.size; ++i3) {
            this.skip(listBegin.etype);
          }
          this.readListEnd();
          break;
        default:
          throw new Error("Invalid type: " + type);
      }
    };
  }
});

// node_modules/thrift/lib/nodejs/lib/thrift/binary_protocol.js
var require_binary_protocol = __commonJS({
  "node_modules/thrift/lib/nodejs/lib/thrift/binary_protocol.js"(exports, module2) {
    var log = require_log();
    var binary = require_binary();
    var Int64 = require_Int64();
    var Thrift = require_thrift();
    var Type = Thrift.Type;
    module2.exports = TBinaryProtocol;
    var VERSION_MASK = -65536;
    var VERSION_1 = -2147418112;
    var TYPE_MASK = 255;
    TBinaryProtocol.VERSION_MASK = VERSION_MASK;
    TBinaryProtocol.VERSION_1 = VERSION_1;
    TBinaryProtocol.TYPE_MASK = TYPE_MASK;
    function TBinaryProtocol(trans, strictRead, strictWrite) {
      this.trans = trans;
      this.strictRead = strictRead !== void 0 ? strictRead : false;
      this.strictWrite = strictWrite !== void 0 ? strictWrite : true;
      this._seqid = null;
    }
    TBinaryProtocol.prototype.flush = function() {
      return this.trans.flush();
    };
    TBinaryProtocol.prototype.writeMessageBegin = function(name, type, seqid) {
      if (this.strictWrite) {
        this.writeI32(VERSION_1 | type);
        this.writeString(name);
        this.writeI32(seqid);
      } else {
        this.writeString(name);
        this.writeByte(type);
        this.writeI32(seqid);
      }
      if (this._seqid !== null) {
        log.warning("SeqId already set", { "name": name });
      } else {
        this._seqid = seqid;
        this.trans.setCurrSeqId(seqid);
      }
    };
    TBinaryProtocol.prototype.writeMessageEnd = function() {
      if (this._seqid !== null) {
        this._seqid = null;
      } else {
        log.warning("No seqid to unset");
      }
    };
    TBinaryProtocol.prototype.writeStructBegin = function(name) {
    };
    TBinaryProtocol.prototype.writeStructEnd = function() {
    };
    TBinaryProtocol.prototype.writeFieldBegin = function(name, type, id) {
      this.writeByte(type);
      this.writeI16(id);
    };
    TBinaryProtocol.prototype.writeFieldEnd = function() {
    };
    TBinaryProtocol.prototype.writeFieldStop = function() {
      this.writeByte(Type.STOP);
    };
    TBinaryProtocol.prototype.writeMapBegin = function(ktype, vtype, size) {
      this.writeByte(ktype);
      this.writeByte(vtype);
      this.writeI32(size);
    };
    TBinaryProtocol.prototype.writeMapEnd = function() {
    };
    TBinaryProtocol.prototype.writeListBegin = function(etype, size) {
      this.writeByte(etype);
      this.writeI32(size);
    };
    TBinaryProtocol.prototype.writeListEnd = function() {
    };
    TBinaryProtocol.prototype.writeSetBegin = function(etype, size) {
      this.writeByte(etype);
      this.writeI32(size);
    };
    TBinaryProtocol.prototype.writeSetEnd = function() {
    };
    TBinaryProtocol.prototype.writeBool = function(bool) {
      if (bool) {
        this.writeByte(1);
      } else {
        this.writeByte(0);
      }
    };
    TBinaryProtocol.prototype.writeByte = function(b) {
      this.trans.write(new Buffer([b]));
    };
    TBinaryProtocol.prototype.writeI16 = function(i16) {
      this.trans.write(binary.writeI16(new Buffer(2), i16));
    };
    TBinaryProtocol.prototype.writeI32 = function(i32) {
      this.trans.write(binary.writeI32(new Buffer(4), i32));
    };
    TBinaryProtocol.prototype.writeI64 = function(i64) {
      if (i64.buffer) {
        this.trans.write(i64.buffer);
      } else {
        this.trans.write(new Int64(i64).buffer);
      }
    };
    TBinaryProtocol.prototype.writeDouble = function(dub) {
      this.trans.write(binary.writeDouble(new Buffer(8), dub));
    };
    TBinaryProtocol.prototype.writeStringOrBinary = function(name, encoding, arg) {
      if (typeof arg === "string") {
        this.writeI32(Buffer.byteLength(arg, encoding));
        this.trans.write(new Buffer(arg, encoding));
      } else if (arg instanceof Buffer || Object.prototype.toString.call(arg) == "[object Uint8Array]") {
        this.writeI32(arg.length);
        this.trans.write(arg);
      } else {
        throw new Error(name + " called without a string/Buffer argument: " + arg);
      }
    };
    TBinaryProtocol.prototype.writeString = function(arg) {
      this.writeStringOrBinary("writeString", "utf8", arg);
    };
    TBinaryProtocol.prototype.writeBinary = function(arg) {
      this.writeStringOrBinary("writeBinary", "binary", arg);
    };
    TBinaryProtocol.prototype.readMessageBegin = function() {
      var sz = this.readI32();
      var type, name, seqid;
      if (sz < 0) {
        var version = sz & VERSION_MASK;
        if (version != VERSION_1) {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.BAD_VERSION, "Bad version in readMessageBegin: " + sz);
        }
        type = sz & TYPE_MASK;
        name = this.readString();
        seqid = this.readI32();
      } else {
        if (this.strictRead) {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.BAD_VERSION, "No protocol version header");
        }
        name = this.trans.read(sz);
        type = this.readByte();
        seqid = this.readI32();
      }
      return { fname: name, mtype: type, rseqid: seqid };
    };
    TBinaryProtocol.prototype.readMessageEnd = function() {
    };
    TBinaryProtocol.prototype.readStructBegin = function() {
      return { fname: "" };
    };
    TBinaryProtocol.prototype.readStructEnd = function() {
    };
    TBinaryProtocol.prototype.readFieldBegin = function() {
      var type = this.readByte();
      if (type == Type.STOP) {
        return { fname: null, ftype: type, fid: 0 };
      }
      var id = this.readI16();
      return { fname: null, ftype: type, fid: id };
    };
    TBinaryProtocol.prototype.readFieldEnd = function() {
    };
    TBinaryProtocol.prototype.readMapBegin = function() {
      var ktype = this.readByte();
      var vtype = this.readByte();
      var size = this.readI32();
      return { ktype, vtype, size };
    };
    TBinaryProtocol.prototype.readMapEnd = function() {
    };
    TBinaryProtocol.prototype.readListBegin = function() {
      var etype = this.readByte();
      var size = this.readI32();
      return { etype, size };
    };
    TBinaryProtocol.prototype.readListEnd = function() {
    };
    TBinaryProtocol.prototype.readSetBegin = function() {
      var etype = this.readByte();
      var size = this.readI32();
      return { etype, size };
    };
    TBinaryProtocol.prototype.readSetEnd = function() {
    };
    TBinaryProtocol.prototype.readBool = function() {
      var b = this.readByte();
      if (b === 0) {
        return false;
      }
      return true;
    };
    TBinaryProtocol.prototype.readByte = function() {
      return this.trans.readByte();
    };
    TBinaryProtocol.prototype.readI16 = function() {
      return this.trans.readI16();
    };
    TBinaryProtocol.prototype.readI32 = function() {
      return this.trans.readI32();
    };
    TBinaryProtocol.prototype.readI64 = function() {
      var buff = this.trans.read(8);
      return new Int64(buff);
    };
    TBinaryProtocol.prototype.readDouble = function() {
      return this.trans.readDouble();
    };
    TBinaryProtocol.prototype.readBinary = function() {
      var len = this.readI32();
      if (len === 0) {
        return new Buffer(0);
      }
      if (len < 0) {
        throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.NEGATIVE_SIZE, "Negative binary size");
      }
      return this.trans.read(len);
    };
    TBinaryProtocol.prototype.readString = function() {
      var len = this.readI32();
      if (len === 0) {
        return "";
      }
      if (len < 0) {
        throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.NEGATIVE_SIZE, "Negative string size");
      }
      return this.trans.readString(len);
    };
    TBinaryProtocol.prototype.getTransport = function() {
      return this.trans;
    };
    TBinaryProtocol.prototype.skip = function(type) {
      switch (type) {
        case Type.BOOL:
          this.readBool();
          break;
        case Type.BYTE:
          this.readByte();
          break;
        case Type.I16:
          this.readI16();
          break;
        case Type.I32:
          this.readI32();
          break;
        case Type.I64:
          this.readI64();
          break;
        case Type.DOUBLE:
          this.readDouble();
          break;
        case Type.STRING:
          this.readString();
          break;
        case Type.STRUCT:
          this.readStructBegin();
          while (true) {
            var r = this.readFieldBegin();
            if (r.ftype === Type.STOP) {
              break;
            }
            this.skip(r.ftype);
            this.readFieldEnd();
          }
          this.readStructEnd();
          break;
        case Type.MAP:
          var mapBegin = this.readMapBegin();
          for (var i = 0; i < mapBegin.size; ++i) {
            this.skip(mapBegin.ktype);
            this.skip(mapBegin.vtype);
          }
          this.readMapEnd();
          break;
        case Type.SET:
          var setBegin = this.readSetBegin();
          for (var i2 = 0; i2 < setBegin.size; ++i2) {
            this.skip(setBegin.etype);
          }
          this.readSetEnd();
          break;
        case Type.LIST:
          var listBegin = this.readListBegin();
          for (var i3 = 0; i3 < listBegin.size; ++i3) {
            this.skip(listBegin.etype);
          }
          this.readListEnd();
          break;
        default:
          throw new Error("Invalid type: " + type);
      }
    };
  }
});

// node_modules/thrift/lib/nodejs/lib/thrift/header_transport.js
var require_header_transport = __commonJS({
  "node_modules/thrift/lib/nodejs/lib/thrift/header_transport.js"(exports, module2) {
    var util = require("util");
    var TCompactProtocol = require_compact_protocol();
    var TBinaryProtocol = require_binary_protocol();
    var InputBufferUnderrunError = require_input_buffer_underrun_error();
    function THeaderTransportError(message) {
      Error.call(this);
      if (Error.captureStackTrace !== void 0) {
        Error.captureStackTrace(this, this.constructor);
      }
      this.name = this.constructor.name;
      this.message = message;
    }
    util.inherits(THeaderTransportError, Error);
    module2.exports = THeaderTransport;
    var COMPACT_PROTOCOL_OFFSET = 0;
    var COMPACT_PROTOCOL_VERSION_OFFSET = 1;
    var FRAME_SIZE_OFFSET = 0;
    var HEADER_MAGIC_OFFSET = 32 / 8;
    var FLAGS_OFFSET = 48 / 8;
    var SEQID_OFFSET = 64 / 8;
    var HEADER_SIZE_OFFSET = 96 / 8;
    var HEADER_START_OFFSET = 112 / 8;
    var HEADER_MAGIC = 4095;
    var TINFO_HEADER_KEY_VALUE_TYPE = 1;
    var MAX_FRAME_SIZE = 1073741823;
    function VarintHelper(readBuffer) {
      var TBufferedTransport = require_buffered_transport();
      this.outputBuffer = null;
      var _this = this;
      this.transport = new TBufferedTransport(null, function(output) {
        _this.outputBuffer = output;
      });
      this.transport.inBuf = readBuffer || Buffer.alloc(0);
      this.transport.writeCursor = this.transport.inBuf.length;
      this.protocol = new TCompactProtocol(this.transport);
    }
    VarintHelper.prototype.readVarint32 = function() {
      return this.protocol.readVarint32();
    };
    VarintHelper.prototype.writeVarint32 = function(i) {
      this.protocol.writeVarint32(i);
    };
    VarintHelper.prototype.readString = function() {
      return this.protocol.readString();
    };
    VarintHelper.prototype.writeString = function(str) {
      this.protocol.writeString(str);
    };
    VarintHelper.prototype.getOutCount = function() {
      return this.transport.outCount;
    };
    VarintHelper.prototype.write = function(str) {
      this.transport.write(str);
    };
    VarintHelper.prototype.toBuffer = function() {
      this.transport.flush();
      return this.outputBuffer;
    };
    THeaderTransport.SubprotocolId = {
      BINARY: 0,
      JSON: 1,
      COMPACT: 2
    };
    function THeaderTransport() {
      this.maxFrameSize = MAX_FRAME_SIZE;
      this.protocolId = THeaderTransport.SubprotocolId.BINARY;
      this.rheaders = {};
      this.wheaders = {};
      this.inBuf = Buffer.alloc(0);
      this.outCount = 0;
      this.flags = null;
      this.seqid = 0;
      this.shouldWriteHeaders = true;
    }
    var validateHeaders = function(key, value) {
      if (typeof key !== "string" || typeof value !== "string") {
        throw new THeaderTransportError("Header key and values must be strings");
      }
    };
    var validateProtocolId = function(protocolId) {
      var protocols = Object.keys(THeaderTransport.SubprotocolId);
      for (var i = 0; i < protocols.length; i++) {
        if (protocolId === THeaderTransport.SubprotocolId[protocols[i]])
          return true;
      }
      throw new Error(protocolId + " is not a valid protocol id");
    };
    THeaderTransport.prototype.setSeqId = function(seqid) {
      this.seqid = seqid;
    };
    THeaderTransport.prototype.getSeqId = function(seqid) {
      return this.seqid;
    };
    THeaderTransport.prototype.setFlags = function(flags) {
      this.flags = flags;
    };
    THeaderTransport.prototype.getReadHeaders = function() {
      return this.rheaders;
    };
    THeaderTransport.prototype.setReadHeader = function(key, value) {
      validateHeaders(key, value);
      this.rheaders[key] = value;
    };
    THeaderTransport.prototype.clearReadHeaders = function() {
      this.rheaders = {};
    };
    THeaderTransport.prototype.getWriteHeaders = function() {
      return this.wheaders;
    };
    THeaderTransport.prototype.setWriteHeader = function(key, value) {
      validateHeaders(key, value);
      this.wheaders[key] = value;
    };
    THeaderTransport.prototype.clearWriteHeaders = function() {
      this.wheaders = {};
    };
    THeaderTransport.prototype.setMaxFrameSize = function(frameSize) {
      this.maxFrameSize = frameSize;
    };
    THeaderTransport.prototype.setProtocolId = function(protocolId) {
      validateProtocolId(protocolId);
      this.protocolId = protocolId;
    };
    THeaderTransport.prototype.getProtocolId = function() {
      return this.protocolId;
    };
    var isUnframedBinary = function(readBuffer) {
      var version = readBuffer.readInt32BE();
      return (version & TBinaryProtocol.VERSION_MASK) === TBinaryProtocol.VERSION_1;
    };
    var isUnframedCompact = function(readBuffer) {
      var protocolId = readBuffer.readInt8(COMPACT_PROTOCOL_OFFSET);
      var version = readBuffer.readInt8(COMPACT_PROTOCOL_VERSION_OFFSET);
      return protocolId === TCompactProtocol.PROTOCOL_ID && (version & TCompactProtocol.VERSION_MASK) === TCompactProtocol.VERSION_N;
    };
    THeaderTransport.prototype.readHeaders = function() {
      var readBuffer = this.inBuf;
      var isUnframed = false;
      if (isUnframedBinary(readBuffer)) {
        this.setProtocolId(THeaderTransport.SubprotocolId.BINARY);
        isUnframed = true;
      }
      if (isUnframedCompact(readBuffer)) {
        this.setProtocolId(THeaderTransport.SubprotocolId.COMPACT);
        isUnframed = true;
      }
      if (isUnframed) {
        this.shouldWriteHeaders = false;
        return;
      }
      var frameSize = readBuffer.readInt32BE(FRAME_SIZE_OFFSET);
      if (frameSize > this.maxFrameSize) {
        throw new THeaderTransportError("Frame exceeds maximum frame size");
      }
      var headerMagic = readBuffer.readInt16BE(HEADER_MAGIC_OFFSET);
      this.shouldWriteHeaders = headerMagic === HEADER_MAGIC;
      if (!this.shouldWriteHeaders) {
        return;
      }
      this.setFlags(readBuffer.readInt16BE(FLAGS_OFFSET));
      this.setSeqId(readBuffer.readInt32BE(SEQID_OFFSET));
      var headerSize = readBuffer.readInt16BE(HEADER_SIZE_OFFSET) * 4;
      var endOfHeaders = HEADER_START_OFFSET + headerSize;
      if (endOfHeaders > readBuffer.length) {
        throw new THeaderTransportError("Header size is greater than frame size");
      }
      var headerBuffer = Buffer.alloc(headerSize);
      readBuffer.copy(headerBuffer, 0, HEADER_START_OFFSET, endOfHeaders);
      var varintHelper = new VarintHelper(headerBuffer);
      this.setProtocolId(varintHelper.readVarint32());
      var transformCount = varintHelper.readVarint32();
      if (transformCount > 0) {
        throw new THeaderTransportError("Transforms are not yet supported");
      }
      while (true) {
        try {
          var headerType = varintHelper.readVarint32();
          if (headerType !== TINFO_HEADER_KEY_VALUE_TYPE) {
            break;
          }
          var numberOfHeaders = varintHelper.readVarint32();
          for (var i = 0; i < numberOfHeaders; i++) {
            var key = varintHelper.readString();
            var value = varintHelper.readString();
            this.setReadHeader(key, value);
          }
        } catch (e) {
          if (e instanceof InputBufferUnderrunError) {
            break;
          }
          throw e;
        }
      }
      this.read(endOfHeaders);
      return this.getReadHeaders();
    };
    THeaderTransport.prototype.writeHeaders = function() {
      if (!this.shouldWriteHeaders) {
        return;
      }
      var headers = this.getWriteHeaders();
      var varintWriter = new VarintHelper();
      varintWriter.writeVarint32(this.protocolId);
      varintWriter.writeVarint32(0);
      var headerKeys = Object.keys(headers);
      if (headerKeys.length > 0) {
        varintWriter.writeVarint32(TINFO_HEADER_KEY_VALUE_TYPE);
        varintWriter.writeVarint32(headerKeys.length);
        for (var i = 0; i < headerKeys.length; i++) {
          var key = headerKeys[i];
          var value = headers[key];
          varintWriter.writeString(key);
          varintWriter.writeString(value);
        }
      }
      var headerSizeWithoutPadding = varintWriter.getOutCount();
      var paddingNeeded = (4 - headerSizeWithoutPadding % 4) % 4;
      var headerSize = Buffer.alloc(2);
      headerSize.writeInt16BE(Math.floor((headerSizeWithoutPadding + paddingNeeded) / 4));
      var paddingBuffer = Buffer.alloc(paddingNeeded);
      paddingBuffer.fill(0);
      varintWriter.write(paddingBuffer);
      var headerContentBuffer = varintWriter.toBuffer();
      var frameSize = Buffer.alloc(4);
      frameSize.writeInt32BE(10 + this.outCount + headerContentBuffer.length);
      var headerMagic = Buffer.alloc(2);
      headerMagic.writeInt16BE(HEADER_MAGIC);
      var flags = Buffer.alloc(2);
      flags.writeInt16BE(0);
      var seqid = Buffer.alloc(4);
      seqid.writeInt32BE(this.getSeqId());
      var headerBuffer = Buffer.concat([
        frameSize,
        headerMagic,
        flags,
        seqid,
        headerSize,
        headerContentBuffer
      ]);
      this.outBuffers.unshift(headerBuffer);
      this.outCount += headerBuffer.length;
    };
  }
});

// node_modules/thrift/lib/nodejs/lib/thrift/buffered_transport.js
var require_buffered_transport = __commonJS({
  "node_modules/thrift/lib/nodejs/lib/thrift/buffered_transport.js"(exports, module2) {
    var binary = require_binary();
    var InputBufferUnderrunError = require_input_buffer_underrun_error();
    var THeaderTransport = require_header_transport();
    module2.exports = TBufferedTransport;
    function TBufferedTransport(buffer, callback) {
      this.defaultReadBufferSize = 1024;
      this.writeBufferSize = 512;
      this.inBuf = new Buffer(this.defaultReadBufferSize);
      this.readCursor = 0;
      this.writeCursor = 0;
      this.outBuffers = [];
      this.outCount = 0;
      this.onFlush = callback;
    }
    TBufferedTransport.prototype = new THeaderTransport();
    TBufferedTransport.prototype.reset = function() {
      this.inBuf = new Buffer(this.defaultReadBufferSize);
      this.readCursor = 0;
      this.writeCursor = 0;
      this.outBuffers = [];
      this.outCount = 0;
    };
    TBufferedTransport.receiver = function(callback, seqid) {
      var reader = new TBufferedTransport();
      return function(data) {
        if (reader.writeCursor + data.length > reader.inBuf.length) {
          var buf = new Buffer(reader.writeCursor + data.length);
          reader.inBuf.copy(buf, 0, 0, reader.writeCursor);
          reader.inBuf = buf;
        }
        data.copy(reader.inBuf, reader.writeCursor, 0);
        reader.writeCursor += data.length;
        callback(reader, seqid);
      };
    };
    TBufferedTransport.prototype.commitPosition = function() {
      var unreadSize = this.writeCursor - this.readCursor;
      var bufSize = unreadSize * 2 > this.defaultReadBufferSize ? unreadSize * 2 : this.defaultReadBufferSize;
      var buf = new Buffer(bufSize);
      if (unreadSize > 0) {
        this.inBuf.copy(buf, 0, this.readCursor, this.writeCursor);
      }
      this.readCursor = 0;
      this.writeCursor = unreadSize;
      this.inBuf = buf;
    };
    TBufferedTransport.prototype.rollbackPosition = function() {
      this.readCursor = 0;
    };
    TBufferedTransport.prototype.isOpen = function() {
      return true;
    };
    TBufferedTransport.prototype.open = function() {
    };
    TBufferedTransport.prototype.close = function() {
    };
    TBufferedTransport.prototype.setCurrSeqId = function(seqid) {
      this._seqid = seqid;
    };
    TBufferedTransport.prototype.ensureAvailable = function(len) {
      if (this.readCursor + len > this.writeCursor) {
        throw new InputBufferUnderrunError();
      }
    };
    TBufferedTransport.prototype.read = function(len) {
      this.ensureAvailable(len);
      var buf = new Buffer(len);
      this.inBuf.copy(buf, 0, this.readCursor, this.readCursor + len);
      this.readCursor += len;
      return buf;
    };
    TBufferedTransport.prototype.readByte = function() {
      this.ensureAvailable(1);
      return binary.readByte(this.inBuf[this.readCursor++]);
    };
    TBufferedTransport.prototype.readI16 = function() {
      this.ensureAvailable(2);
      var i16 = binary.readI16(this.inBuf, this.readCursor);
      this.readCursor += 2;
      return i16;
    };
    TBufferedTransport.prototype.readI32 = function() {
      this.ensureAvailable(4);
      var i32 = binary.readI32(this.inBuf, this.readCursor);
      this.readCursor += 4;
      return i32;
    };
    TBufferedTransport.prototype.readDouble = function() {
      this.ensureAvailable(8);
      var d = binary.readDouble(this.inBuf, this.readCursor);
      this.readCursor += 8;
      return d;
    };
    TBufferedTransport.prototype.readString = function(len) {
      this.ensureAvailable(len);
      var str = this.inBuf.toString("utf8", this.readCursor, this.readCursor + len);
      this.readCursor += len;
      return str;
    };
    TBufferedTransport.prototype.borrow = function() {
      var obj = { buf: this.inBuf, readIndex: this.readCursor, writeIndex: this.writeCursor };
      return obj;
    };
    TBufferedTransport.prototype.consume = function(bytesConsumed) {
      this.readCursor += bytesConsumed;
    };
    TBufferedTransport.prototype.write = function(buf) {
      if (typeof buf === "string") {
        buf = new Buffer(buf, "utf8");
      }
      this.outBuffers.push(buf);
      this.outCount += buf.length;
    };
    TBufferedTransport.prototype.flush = function() {
      var seqid = this._seqid;
      this._seqid = null;
      if (this.outCount < 1) {
        return;
      }
      var msg = new Buffer(this.outCount), pos = 0;
      this.outBuffers.forEach(function(buf) {
        buf.copy(msg, pos, 0);
        pos += buf.length;
      });
      if (this.onFlush) {
        this.onFlush(msg, seqid);
      }
      this.outBuffers = [];
      this.outCount = 0;
    };
  }
});

// node_modules/thrift/lib/nodejs/lib/thrift/create_client.js
var require_create_client = __commonJS({
  "node_modules/thrift/lib/nodejs/lib/thrift/create_client.js"(exports, module2) {
    module2.exports = createClient;
    function createClient(ServiceClient, connection) {
      if (ServiceClient.Client) {
        ServiceClient = ServiceClient.Client;
      }
      var writeCb = function(buf, seqid) {
        connection.write(buf, seqid);
      };
      var transport = new connection.transport(void 0, writeCb);
      var client = new ServiceClient(transport, connection.protocol);
      transport.client = client;
      connection.client = client;
      return client;
    }
  }
});

// node_modules/thrift/lib/nodejs/lib/thrift/connection.js
var require_connection3 = __commonJS({
  "node_modules/thrift/lib/nodejs/lib/thrift/connection.js"(exports) {
    var util = require("util");
    var EventEmitter = require("events").EventEmitter;
    var constants = require("constants");
    var net = require("net");
    var tls = require("tls");
    var thrift = require_thrift();
    var log = require_log();
    var TBufferedTransport = require_buffered_transport();
    var TBinaryProtocol = require_binary_protocol();
    var InputBufferUnderrunError = require_input_buffer_underrun_error();
    var createClient = require_create_client();
    var binary = require_binary();
    var Connection = exports.Connection = function(stream, options) {
      var self2 = this;
      EventEmitter.call(this);
      this.seqId2Service = {};
      this.connection = stream;
      this.ssl = stream.encrypted;
      this.options = options || {};
      this.transport = this.options.transport || TBufferedTransport;
      this.protocol = this.options.protocol || TBinaryProtocol;
      this.offline_queue = [];
      this.connected = false;
      this.initialize_retry_vars();
      this._debug = this.options.debug || false;
      if (this.options.max_attempts && !isNaN(this.options.max_attempts) && this.options.max_attempts > 0) {
        this.max_attempts = +this.options.max_attempts;
      }
      this.retry_max_delay = null;
      if (this.options.retry_max_delay !== void 0 && !isNaN(this.options.retry_max_delay) && this.options.retry_max_delay > 0) {
        this.retry_max_delay = this.options.retry_max_delay;
      }
      this.connect_timeout = false;
      if (this.options.connect_timeout && !isNaN(this.options.connect_timeout) && this.options.connect_timeout > 0) {
        this.connect_timeout = +this.options.connect_timeout;
      }
      this.connection.addListener(this.ssl ? "secureConnect" : "connect", function() {
        self2.connected = true;
        this.setTimeout(self2.options.timeout || 0);
        this.setNoDelay();
        this.frameLeft = 0;
        this.framePos = 0;
        this.frame = null;
        self2.initialize_retry_vars();
        self2.flush_offline_queue();
        self2.emit("connect");
      });
      this.connection.addListener("error", function(err) {
        if (self2.connection.listeners("error").length === 1 || self2.listeners("error").length > 0) {
          self2.emit("error", err);
        }
      });
      this.connection.addListener("close", function() {
        self2.connection_gone();
      });
      this.connection.addListener("timeout", function() {
        self2.emit("timeout");
      });
      this.connection.addListener("data", self2.transport.receiver(function(transport_with_data) {
        var message = new self2.protocol(transport_with_data);
        try {
          while (true) {
            var header = message.readMessageBegin();
            var dummy_seqid = header.rseqid * -1;
            var client = self2.client;
            var service_name = self2.seqId2Service[header.rseqid];
            if (service_name) {
              client = self2.client[service_name];
            }
            client._reqs[dummy_seqid] = function(err, success) {
              transport_with_data.commitPosition();
              var callback = client._reqs[header.rseqid];
              delete client._reqs[header.rseqid];
              if (service_name) {
                delete self2.seqId2Service[header.rseqid];
              }
              if (callback) {
                callback(err, success);
              }
            };
            if (client["recv_" + header.fname]) {
              client["recv_" + header.fname](message, header.mtype, dummy_seqid);
            } else {
              delete client._reqs[dummy_seqid];
              self2.emit(
                "error",
                new thrift.TApplicationException(
                  thrift.TApplicationExceptionType.WRONG_METHOD_NAME,
                  "Received a response to an unknown RPC function"
                )
              );
            }
          }
        } catch (e) {
          if (e instanceof InputBufferUnderrunError) {
            transport_with_data.rollbackPosition();
          } else {
            self2.emit("error", e);
          }
        }
      }));
    };
    util.inherits(Connection, EventEmitter);
    Connection.prototype.end = function() {
      this.connection.end();
    };
    Connection.prototype.destroy = function() {
      this.connection.destroy();
    };
    Connection.prototype.initialize_retry_vars = function() {
      this.retry_timer = null;
      this.retry_totaltime = 0;
      this.retry_delay = 150;
      this.retry_backoff = 1.7;
      this.attempts = 0;
    };
    Connection.prototype.flush_offline_queue = function() {
      var self2 = this;
      var offline_queue = this.offline_queue;
      this.offline_queue = [];
      offline_queue.forEach(function(data) {
        self2.write(data);
      });
    };
    Connection.prototype.write = function(data) {
      if (!this.connected) {
        this.offline_queue.push(data);
        return;
      }
      this.connection.write(data);
    };
    Connection.prototype.connection_gone = function() {
      var self2 = this;
      this.connected = false;
      if (this.retry_timer) {
        return;
      }
      if (!this.max_attempts || this.ssl) {
        self2.emit("close");
        return;
      }
      if (this.retry_max_delay !== null && this.retry_delay >= this.retry_max_delay) {
        this.retry_delay = this.retry_max_delay;
      } else {
        this.retry_delay = Math.floor(this.retry_delay * this.retry_backoff);
      }
      log.debug("Retry connection in " + this.retry_delay + " ms");
      if (this.max_attempts && this.attempts >= this.max_attempts) {
        this.retry_timer = null;
        console.error("thrift: Couldn't get thrift connection after " + this.max_attempts + " attempts.");
        self2.emit("close");
        return;
      }
      this.attempts += 1;
      this.emit("reconnecting", {
        delay: self2.retry_delay,
        attempt: self2.attempts
      });
      this.retry_timer = setTimeout(function() {
        if (self2.connection.destroyed) {
          self2.retry_timer = null;
          return;
        }
        log.debug("Retrying connection...");
        self2.retry_totaltime += self2.retry_delay;
        if (self2.connect_timeout && self2.retry_totaltime >= self2.connect_timeout) {
          self2.retry_timer = null;
          console.error("thrift: Couldn't get thrift connection after " + self2.retry_totaltime + "ms.");
          self2.emit("close");
          return;
        }
        if (self2.path !== void 0) {
          self2.connection.connect(self2.path);
        } else {
          self2.connection.connect(self2.port, self2.host);
        }
        self2.retry_timer = null;
      }, this.retry_delay);
    };
    exports.createConnection = function(host, port, options) {
      var stream = net.createConnection({
        port,
        host,
        timeout: options.connect_timeout || options.timeout || 0
      });
      var connection = new Connection(stream, options);
      connection.host = host;
      connection.port = port;
      return connection;
    };
    exports.createUDSConnection = function(path, options) {
      var stream = net.createConnection(path);
      var connection = new Connection(stream, options);
      connection.path = path;
      return connection;
    };
    exports.createSSLConnection = function(host, port, options) {
      if (!("secureProtocol" in options) && !("secureOptions" in options)) {
        options.secureProtocol = "SSLv23_method";
        options.secureOptions = constants.SSL_OP_NO_SSLv2 | constants.SSL_OP_NO_SSLv3;
      }
      var stream = tls.connect(port, host, options);
      var connection = new Connection(stream, options);
      connection.host = host;
      connection.port = port;
      return connection;
    };
    exports.createClient = createClient;
    var child_process = require("child_process");
    var StdIOConnection = exports.StdIOConnection = function(command, options) {
      var command_parts = command.split(" ");
      command = command_parts[0];
      var args = command_parts.splice(1, command_parts.length - 1);
      var child = this.child = child_process.spawn(command, args);
      var self2 = this;
      EventEmitter.call(this);
      this.connection = child.stdin;
      this.options = options || {};
      this.transport = this.options.transport || TBufferedTransport;
      this.protocol = this.options.protocol || TBinaryProtocol;
      this.offline_queue = [];
      if (log.getLogLevel() === "debug") {
        this.child.stderr.on("data", function(err) {
          log.debug(err.toString(), "CHILD ERROR");
        });
        this.child.on("exit", function(code, signal) {
          log.debug(code + ":" + signal, "CHILD EXITED");
        });
      }
      this.frameLeft = 0;
      this.framePos = 0;
      this.frame = null;
      this.connected = true;
      self2.flush_offline_queue();
      this.connection.addListener("error", function(err) {
        self2.emit("error", err);
      });
      this.connection.addListener("close", function() {
        self2.emit("close");
      });
      child.stdout.addListener("data", self2.transport.receiver(function(transport_with_data) {
        var message = new self2.protocol(transport_with_data);
        try {
          var header = message.readMessageBegin();
          var dummy_seqid = header.rseqid * -1;
          var client = self2.client;
          client._reqs[dummy_seqid] = function(err, success) {
            transport_with_data.commitPosition();
            var callback = client._reqs[header.rseqid];
            delete client._reqs[header.rseqid];
            if (callback) {
              callback(err, success);
            }
          };
          client["recv_" + header.fname](message, header.mtype, dummy_seqid);
        } catch (e) {
          if (e instanceof InputBufferUnderrunError) {
            transport_with_data.rollbackPosition();
          } else {
            throw e;
          }
        }
      }));
    };
    util.inherits(StdIOConnection, EventEmitter);
    StdIOConnection.prototype.end = function() {
      this.connection.end();
    };
    StdIOConnection.prototype.flush_offline_queue = function() {
      var self2 = this;
      var offline_queue = this.offline_queue;
      this.offline_queue = [];
      offline_queue.forEach(function(data) {
        self2.write(data);
      });
    };
    StdIOConnection.prototype.write = function(data) {
      if (!this.connected) {
        this.offline_queue.push(data);
        return;
      }
      this.connection.write(data);
    };
    exports.createStdIOConnection = function(command, options) {
      return new StdIOConnection(command, options);
    };
    exports.createStdIOClient = createClient;
  }
});

// node_modules/thrift/lib/nodejs/lib/thrift/http_connection.js
var require_http_connection = __commonJS({
  "node_modules/thrift/lib/nodejs/lib/thrift/http_connection.js"(exports) {
    var util = require("util");
    var http = require("http");
    var https = require("https");
    var EventEmitter = require("events").EventEmitter;
    var thrift = require_thrift();
    var TBufferedTransport = require_buffered_transport();
    var TBinaryProtocol = require_binary_protocol();
    var InputBufferUnderrunError = require_input_buffer_underrun_error();
    var createClient = require_create_client();
    var HttpConnection = exports.HttpConnection = function(options) {
      EventEmitter.call(this);
      var self2 = this;
      this.options = options || {};
      this.host = this.options.host;
      this.port = this.options.port;
      this.socketPath = this.options.socketPath;
      this.https = this.options.https || false;
      this.transport = this.options.transport || TBufferedTransport;
      this.protocol = this.options.protocol || TBinaryProtocol;
      this.nodeOptions = {
        host: this.host,
        port: this.port,
        socketPath: this.socketPath,
        path: this.options.path || "/",
        method: "POST",
        headers: this.options.headers || {},
        responseType: this.options.responseType || null
      };
      for (var attrname in this.options.nodeOptions) {
        this.nodeOptions[attrname] = this.options.nodeOptions[attrname];
      }
      if (!this.nodeOptions.headers["Connection"]) {
        this.nodeOptions.headers["Connection"] = "keep-alive";
      }
      this.seqId2Service = {};
      function decodeCallback(transport_with_data) {
        var proto = new self2.protocol(transport_with_data);
        try {
          while (true) {
            var header = proto.readMessageBegin();
            var dummy_seqid = header.rseqid * -1;
            var client = self2.client;
            var service_name = self2.seqId2Service[header.rseqid];
            if (service_name) {
              client = self2.client[service_name];
              delete self2.seqId2Service[header.rseqid];
            }
            client._reqs[dummy_seqid] = function(err, success) {
              transport_with_data.commitPosition();
              var clientCallback = client._reqs[header.rseqid];
              delete client._reqs[header.rseqid];
              if (clientCallback) {
                process.nextTick(function() {
                  clientCallback(err, success);
                });
              }
            };
            if (client["recv_" + header.fname]) {
              client["recv_" + header.fname](proto, header.mtype, dummy_seqid);
            } else {
              delete client._reqs[dummy_seqid];
              self2.emit(
                "error",
                new thrift.TApplicationException(
                  thrift.TApplicationExceptionType.WRONG_METHOD_NAME,
                  "Received a response to an unknown RPC function"
                )
              );
            }
          }
        } catch (e) {
          if (e instanceof InputBufferUnderrunError) {
            transport_with_data.rollbackPosition();
          } else {
            self2.emit("error", e);
          }
        }
      }
      this.responseCallback = function(response) {
        var data = [];
        var dataLen = 0;
        if (response.statusCode !== 200) {
          this.emit("error", new THTTPException(response));
        }
        response.on("error", function(e) {
          self2.emit("error", e);
        });
        response.on("data", function(chunk) {
          if (typeof chunk == "string" || Object.prototype.toString.call(chunk) == "[object Uint8Array]") {
            data.push(new Buffer(chunk));
          } else {
            data.push(chunk);
          }
          dataLen += chunk.length;
        });
        response.on("end", function() {
          var buf = new Buffer(dataLen);
          for (var i = 0, len = data.length, pos = 0; i < len; i++) {
            data[i].copy(buf, pos);
            pos += data[i].length;
          }
          self2.transport.receiver(decodeCallback)(buf);
        });
      };
    };
    util.inherits(HttpConnection, EventEmitter);
    HttpConnection.prototype.write = function(data) {
      var self2 = this;
      var opts = self2.nodeOptions;
      opts.headers["Content-length"] = data.length;
      if (!opts.headers["Content-Type"])
        opts.headers["Content-Type"] = "application/x-thrift";
      var req = self2.https ? https.request(opts, self2.responseCallback) : http.request(opts, self2.responseCallback);
      req.on("error", function(err) {
        self2.emit("error", err);
      });
      req.write(data);
      req.end();
    };
    exports.createHttpConnection = function(host, port, options) {
      options.host = host;
      options.port = port || 80;
      return new HttpConnection(options);
    };
    exports.createHttpUDSConnection = function(path, options) {
      options.socketPath = path;
      return new HttpConnection(options);
    };
    exports.createHttpClient = createClient;
    function THTTPException(response) {
      thrift.TApplicationException.call(this);
      if (Error.captureStackTrace !== void 0) {
        Error.captureStackTrace(this, this.constructor);
      }
      this.name = this.constructor.name;
      this.statusCode = response.statusCode;
      this.response = response;
      this.type = thrift.TApplicationExceptionType.PROTOCOL_ERROR;
      this.message = "Received a response with a bad HTTP status code: " + response.statusCode;
    }
    util.inherits(THTTPException, thrift.TApplicationException);
  }
});

// node_modules/async-limiter/index.js
var require_async_limiter = __commonJS({
  "node_modules/async-limiter/index.js"(exports, module2) {
    "use strict";
    function Queue(options) {
      if (!(this instanceof Queue)) {
        return new Queue(options);
      }
      options = options || {};
      this.concurrency = options.concurrency || Infinity;
      this.pending = 0;
      this.jobs = [];
      this.cbs = [];
      this._done = done.bind(this);
    }
    var arrayAddMethods = [
      "push",
      "unshift",
      "splice"
    ];
    arrayAddMethods.forEach(function(method) {
      Queue.prototype[method] = function() {
        var methodResult = Array.prototype[method].apply(this.jobs, arguments);
        this._run();
        return methodResult;
      };
    });
    Object.defineProperty(Queue.prototype, "length", {
      get: function() {
        return this.pending + this.jobs.length;
      }
    });
    Queue.prototype._run = function() {
      if (this.pending === this.concurrency) {
        return;
      }
      if (this.jobs.length) {
        var job = this.jobs.shift();
        this.pending++;
        job(this._done);
        this._run();
      }
      if (this.pending === 0) {
        while (this.cbs.length !== 0) {
          var cb = this.cbs.pop();
          process.nextTick(cb);
        }
      }
    };
    Queue.prototype.onDone = function(cb) {
      if (typeof cb === "function") {
        this.cbs.push(cb);
        this._run();
      }
    };
    function done() {
      this.pending--;
      this._run();
    }
    module2.exports = Queue;
  }
});

// node_modules/ws/lib/buffer-util.js
var require_buffer_util = __commonJS({
  "node_modules/ws/lib/buffer-util.js"(exports, module2) {
    "use strict";
    function concat(list, totalLength) {
      const target = Buffer.allocUnsafe(totalLength);
      var offset = 0;
      for (var i = 0; i < list.length; i++) {
        const buf = list[i];
        buf.copy(target, offset);
        offset += buf.length;
      }
      return target;
    }
    function _mask(source, mask, output, offset, length) {
      for (var i = 0; i < length; i++) {
        output[offset + i] = source[i] ^ mask[i & 3];
      }
    }
    function _unmask(buffer, mask) {
      const length = buffer.length;
      for (var i = 0; i < length; i++) {
        buffer[i] ^= mask[i & 3];
      }
    }
    try {
      const bufferUtil = require("bufferutil");
      const bu = bufferUtil.BufferUtil || bufferUtil;
      module2.exports = {
        mask(source, mask, output, offset, length) {
          if (length < 48)
            _mask(source, mask, output, offset, length);
          else
            bu.mask(source, mask, output, offset, length);
        },
        unmask(buffer, mask) {
          if (buffer.length < 32)
            _unmask(buffer, mask);
          else
            bu.unmask(buffer, mask);
        },
        concat
      };
    } catch (e) {
      module2.exports = { concat, mask: _mask, unmask: _unmask };
    }
  }
});

// node_modules/ws/lib/constants.js
var require_constants2 = __commonJS({
  "node_modules/ws/lib/constants.js"(exports, module2) {
    "use strict";
    module2.exports = {
      BINARY_TYPES: ["nodebuffer", "arraybuffer", "fragments"],
      GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
      kStatusCode: Symbol("status-code"),
      kWebSocket: Symbol("websocket"),
      EMPTY_BUFFER: Buffer.alloc(0),
      NOOP: () => {
      }
    };
  }
});

// node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = __commonJS({
  "node_modules/ws/lib/permessage-deflate.js"(exports, module2) {
    "use strict";
    var Limiter = require_async_limiter();
    var zlib = require("zlib");
    var bufferUtil = require_buffer_util();
    var constants = require_constants2();
    var TRAILER = Buffer.from([0, 0, 255, 255]);
    var EMPTY_BLOCK = Buffer.from([0]);
    var kPerMessageDeflate = Symbol("permessage-deflate");
    var kWriteInProgress = Symbol("write-in-progress");
    var kPendingClose = Symbol("pending-close");
    var kTotalLength = Symbol("total-length");
    var kCallback = Symbol("callback");
    var kBuffers = Symbol("buffers");
    var kError = Symbol("error");
    var zlibLimiter;
    var PerMessageDeflate = class {
      constructor(options, isServer, maxPayload) {
        this._maxPayload = maxPayload | 0;
        this._options = options || {};
        this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
        this._isServer = !!isServer;
        this._deflate = null;
        this._inflate = null;
        this.params = null;
        if (!zlibLimiter) {
          const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
          zlibLimiter = new Limiter({ concurrency });
        }
      }
      static get extensionName() {
        return "permessage-deflate";
      }
      offer() {
        const params = {};
        if (this._options.serverNoContextTakeover) {
          params.server_no_context_takeover = true;
        }
        if (this._options.clientNoContextTakeover) {
          params.client_no_context_takeover = true;
        }
        if (this._options.serverMaxWindowBits) {
          params.server_max_window_bits = this._options.serverMaxWindowBits;
        }
        if (this._options.clientMaxWindowBits) {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        } else if (this._options.clientMaxWindowBits == null) {
          params.client_max_window_bits = true;
        }
        return params;
      }
      accept(configurations) {
        configurations = this.normalizeParams(configurations);
        this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
        return this.params;
      }
      cleanup() {
        if (this._inflate) {
          if (this._inflate[kWriteInProgress]) {
            this._inflate[kPendingClose] = true;
          } else {
            this._inflate.close();
            this._inflate = null;
          }
        }
        if (this._deflate) {
          if (this._deflate[kWriteInProgress]) {
            this._deflate[kPendingClose] = true;
          } else {
            this._deflate.close();
            this._deflate = null;
          }
        }
      }
      acceptAsServer(offers) {
        const opts = this._options;
        const accepted = offers.find((params) => {
          if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
            return false;
          }
          return true;
        });
        if (!accepted) {
          throw new Error("None of the extension offers can be accepted");
        }
        if (opts.serverNoContextTakeover) {
          accepted.server_no_context_takeover = true;
        }
        if (opts.clientNoContextTakeover) {
          accepted.client_no_context_takeover = true;
        }
        if (typeof opts.serverMaxWindowBits === "number") {
          accepted.server_max_window_bits = opts.serverMaxWindowBits;
        }
        if (typeof opts.clientMaxWindowBits === "number") {
          accepted.client_max_window_bits = opts.clientMaxWindowBits;
        } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
          delete accepted.client_max_window_bits;
        }
        return accepted;
      }
      acceptAsClient(response) {
        const params = response[0];
        if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
          throw new Error('Unexpected parameter "client_no_context_takeover"');
        }
        if (!params.client_max_window_bits) {
          if (typeof this._options.clientMaxWindowBits === "number") {
            params.client_max_window_bits = this._options.clientMaxWindowBits;
          }
        } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
          throw new Error(
            'Unexpected or invalid parameter "client_max_window_bits"'
          );
        }
        return params;
      }
      normalizeParams(configurations) {
        configurations.forEach((params) => {
          Object.keys(params).forEach((key) => {
            var value = params[key];
            if (value.length > 1) {
              throw new Error(`Parameter "${key}" must have only a single value`);
            }
            value = value[0];
            if (key === "client_max_window_bits") {
              if (value !== true) {
                const num = +value;
                if (!Number.isInteger(num) || num < 8 || num > 15) {
                  throw new TypeError(
                    `Invalid value for parameter "${key}": ${value}`
                  );
                }
                value = num;
              } else if (!this._isServer) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else if (key === "server_max_window_bits") {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
              value = num;
            } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
              if (value !== true) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else {
              throw new Error(`Unknown parameter "${key}"`);
            }
            params[key] = value;
          });
        });
        return configurations;
      }
      decompress(data, fin, callback) {
        zlibLimiter.push((done) => {
          this._decompress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      compress(data, fin, callback) {
        zlibLimiter.push((done) => {
          this._compress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      _decompress(data, fin, callback) {
        const endpoint = this._isServer ? "client" : "server";
        if (!this._inflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._inflate = zlib.createInflateRaw(
            Object.assign({}, this._options.zlibInflateOptions, { windowBits })
          );
          this._inflate[kPerMessageDeflate] = this;
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          this._inflate.on("error", inflateOnError);
          this._inflate.on("data", inflateOnData);
        }
        this._inflate[kCallback] = callback;
        this._inflate[kWriteInProgress] = true;
        this._inflate.write(data);
        if (fin)
          this._inflate.write(TRAILER);
        this._inflate.flush(() => {
          const err = this._inflate[kError];
          if (err) {
            this._inflate.close();
            this._inflate = null;
            callback(err);
            return;
          }
          const data2 = bufferUtil.concat(
            this._inflate[kBuffers],
            this._inflate[kTotalLength]
          );
          if (fin && this.params[`${endpoint}_no_context_takeover`] || this._inflate[kPendingClose]) {
            this._inflate.close();
            this._inflate = null;
          } else {
            this._inflate[kWriteInProgress] = false;
            this._inflate[kTotalLength] = 0;
            this._inflate[kBuffers] = [];
          }
          callback(null, data2);
        });
      }
      _compress(data, fin, callback) {
        if (!data || data.length === 0) {
          process.nextTick(callback, null, EMPTY_BLOCK);
          return;
        }
        const endpoint = this._isServer ? "server" : "client";
        if (!this._deflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._deflate = zlib.createDeflateRaw(
            Object.assign(
              {
                memLevel: this._options.memLevel,
                level: this._options.level
              },
              this._options.zlibDeflateOptions,
              { windowBits }
            )
          );
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          this._deflate.on("data", deflateOnData);
        }
        this._deflate[kWriteInProgress] = true;
        this._deflate.write(data);
        this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
          var data2 = bufferUtil.concat(
            this._deflate[kBuffers],
            this._deflate[kTotalLength]
          );
          if (fin)
            data2 = data2.slice(0, data2.length - 4);
          if (fin && this.params[`${endpoint}_no_context_takeover`] || this._deflate[kPendingClose]) {
            this._deflate.close();
            this._deflate = null;
          } else {
            this._deflate[kWriteInProgress] = false;
            this._deflate[kTotalLength] = 0;
            this._deflate[kBuffers] = [];
          }
          callback(null, data2);
        });
      }
    };
    module2.exports = PerMessageDeflate;
    function deflateOnData(chunk) {
      this[kBuffers].push(chunk);
      this[kTotalLength] += chunk.length;
    }
    function inflateOnData(chunk) {
      this[kTotalLength] += chunk.length;
      if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
        this[kBuffers].push(chunk);
        return;
      }
      this[kError] = new RangeError("Max payload size exceeded");
      this[kError][constants.kStatusCode] = 1009;
      this.removeListener("data", inflateOnData);
      this.reset();
    }
    function inflateOnError(err) {
      this[kPerMessageDeflate]._inflate = null;
      err[constants.kStatusCode] = 1007;
      this[kCallback](err);
    }
  }
});

// node_modules/ws/lib/event-target.js
var require_event_target = __commonJS({
  "node_modules/ws/lib/event-target.js"(exports, module2) {
    "use strict";
    var Event = class {
      constructor(type, target) {
        this.target = target;
        this.type = type;
      }
    };
    var MessageEvent = class extends Event {
      constructor(data, target) {
        super("message", target);
        this.data = data;
      }
    };
    var CloseEvent = class extends Event {
      constructor(code, reason, target) {
        super("close", target);
        this.wasClean = target._closeFrameReceived && target._closeFrameSent;
        this.reason = reason;
        this.code = code;
      }
    };
    var OpenEvent = class extends Event {
      constructor(target) {
        super("open", target);
      }
    };
    var ErrorEvent = class extends Event {
      constructor(error, target) {
        super("error", target);
        this.message = error.message;
        this.error = error;
      }
    };
    var EventTarget = {
      addEventListener(method, listener) {
        if (typeof listener !== "function")
          return;
        function onMessage(data) {
          listener.call(this, new MessageEvent(data, this));
        }
        function onClose(code, message) {
          listener.call(this, new CloseEvent(code, message, this));
        }
        function onError(error) {
          listener.call(this, new ErrorEvent(error, this));
        }
        function onOpen() {
          listener.call(this, new OpenEvent(this));
        }
        if (method === "message") {
          onMessage._listener = listener;
          this.on(method, onMessage);
        } else if (method === "close") {
          onClose._listener = listener;
          this.on(method, onClose);
        } else if (method === "error") {
          onError._listener = listener;
          this.on(method, onError);
        } else if (method === "open") {
          onOpen._listener = listener;
          this.on(method, onOpen);
        } else {
          this.on(method, listener);
        }
      },
      removeEventListener(method, listener) {
        const listeners = this.listeners(method);
        for (var i = 0; i < listeners.length; i++) {
          if (listeners[i] === listener || listeners[i]._listener === listener) {
            this.removeListener(method, listeners[i]);
          }
        }
      }
    };
    module2.exports = EventTarget;
  }
});

// node_modules/ws/lib/extension.js
var require_extension = __commonJS({
  "node_modules/ws/lib/extension.js"(exports, module2) {
    "use strict";
    var tokenChars = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      0,
      1,
      0
    ];
    function push(dest, name, elem) {
      if (Object.prototype.hasOwnProperty.call(dest, name))
        dest[name].push(elem);
      else
        dest[name] = [elem];
    }
    function parse(header) {
      const offers = {};
      if (header === void 0 || header === "")
        return offers;
      var params = {};
      var mustUnescape = false;
      var isEscaping = false;
      var inQuotes = false;
      var extensionName;
      var paramName;
      var start = -1;
      var end = -1;
      for (var i = 0; i < header.length; i++) {
        const code = header.charCodeAt(i);
        if (extensionName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (code === 32 || code === 9) {
            if (end === -1 && start !== -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            const name = header.slice(start, end);
            if (code === 44) {
              push(offers, name, params);
              params = {};
            } else {
              extensionName = name;
            }
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else if (paramName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (code === 32 || code === 9) {
            if (end === -1 && start !== -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            push(params, header.slice(start, end), true);
            if (code === 44) {
              push(offers, extensionName, params);
              params = {};
              extensionName = void 0;
            }
            start = end = -1;
          } else if (code === 61 && start !== -1 && end === -1) {
            paramName = header.slice(start, i);
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else {
          if (isEscaping) {
            if (tokenChars[code] !== 1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (start === -1)
              start = i;
            else if (!mustUnescape)
              mustUnescape = true;
            isEscaping = false;
          } else if (inQuotes) {
            if (tokenChars[code] === 1) {
              if (start === -1)
                start = i;
            } else if (code === 34 && start !== -1) {
              inQuotes = false;
              end = i;
            } else if (code === 92) {
              isEscaping = true;
            } else {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
          } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
            inQuotes = true;
          } else if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (start !== -1 && (code === 32 || code === 9)) {
            if (end === -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            var value = header.slice(start, end);
            if (mustUnescape) {
              value = value.replace(/\\/g, "");
              mustUnescape = false;
            }
            push(params, paramName, value);
            if (code === 44) {
              push(offers, extensionName, params);
              params = {};
              extensionName = void 0;
            }
            paramName = void 0;
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        }
      }
      if (start === -1 || inQuotes) {
        throw new SyntaxError("Unexpected end of input");
      }
      if (end === -1)
        end = i;
      const token = header.slice(start, end);
      if (extensionName === void 0) {
        push(offers, token, {});
      } else {
        if (paramName === void 0) {
          push(params, token, true);
        } else if (mustUnescape) {
          push(params, paramName, token.replace(/\\/g, ""));
        } else {
          push(params, paramName, token);
        }
        push(offers, extensionName, params);
      }
      return offers;
    }
    function format(extensions) {
      return Object.keys(extensions).map((extension) => {
        var configurations = extensions[extension];
        if (!Array.isArray(configurations))
          configurations = [configurations];
        return configurations.map((params) => {
          return [extension].concat(Object.keys(params).map((k) => {
            var values = params[k];
            if (!Array.isArray(values))
              values = [values];
            return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
          })).join("; ");
        }).join(", ");
      }).join(", ");
    }
    module2.exports = { format, parse };
  }
});

// node_modules/ws/lib/validation.js
var require_validation = __commonJS({
  "node_modules/ws/lib/validation.js"(exports) {
    "use strict";
    try {
      const isValidUTF8 = require("utf-8-validate");
      exports.isValidUTF8 = typeof isValidUTF8 === "object" ? isValidUTF8.Validation.isValidUTF8 : isValidUTF8;
    } catch (e) {
      exports.isValidUTF8 = () => true;
    }
    exports.isValidStatusCode = (code) => {
      return code >= 1e3 && code <= 1013 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;
    };
  }
});

// node_modules/ws/lib/receiver.js
var require_receiver = __commonJS({
  "node_modules/ws/lib/receiver.js"(exports, module2) {
    "use strict";
    var stream = require("stream");
    var PerMessageDeflate = require_permessage_deflate();
    var bufferUtil = require_buffer_util();
    var validation = require_validation();
    var constants = require_constants2();
    var GET_INFO = 0;
    var GET_PAYLOAD_LENGTH_16 = 1;
    var GET_PAYLOAD_LENGTH_64 = 2;
    var GET_MASK = 3;
    var GET_DATA = 4;
    var INFLATING = 5;
    var Receiver = class extends stream.Writable {
      constructor(binaryType, extensions, maxPayload) {
        super();
        this._binaryType = binaryType || constants.BINARY_TYPES[0];
        this[constants.kWebSocket] = void 0;
        this._extensions = extensions || {};
        this._maxPayload = maxPayload | 0;
        this._bufferedBytes = 0;
        this._buffers = [];
        this._compressed = false;
        this._payloadLength = 0;
        this._mask = void 0;
        this._fragmented = 0;
        this._masked = false;
        this._fin = false;
        this._opcode = 0;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragments = [];
        this._state = GET_INFO;
        this._loop = false;
      }
      _write(chunk, encoding, cb) {
        if (this._opcode === 8)
          return cb();
        this._bufferedBytes += chunk.length;
        this._buffers.push(chunk);
        this.startLoop(cb);
      }
      consume(n) {
        this._bufferedBytes -= n;
        if (n === this._buffers[0].length)
          return this._buffers.shift();
        if (n < this._buffers[0].length) {
          const buf = this._buffers[0];
          this._buffers[0] = buf.slice(n);
          return buf.slice(0, n);
        }
        const dst = Buffer.allocUnsafe(n);
        do {
          const buf = this._buffers[0];
          if (n >= buf.length) {
            this._buffers.shift().copy(dst, dst.length - n);
          } else {
            buf.copy(dst, dst.length - n, 0, n);
            this._buffers[0] = buf.slice(n);
          }
          n -= buf.length;
        } while (n > 0);
        return dst;
      }
      startLoop(cb) {
        var err;
        this._loop = true;
        do {
          switch (this._state) {
            case GET_INFO:
              err = this.getInfo();
              break;
            case GET_PAYLOAD_LENGTH_16:
              err = this.getPayloadLength16();
              break;
            case GET_PAYLOAD_LENGTH_64:
              err = this.getPayloadLength64();
              break;
            case GET_MASK:
              this.getMask();
              break;
            case GET_DATA:
              err = this.getData(cb);
              break;
            default:
              this._loop = false;
              return;
          }
        } while (this._loop);
        cb(err);
      }
      getInfo() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        const buf = this.consume(2);
        if ((buf[0] & 48) !== 0) {
          this._loop = false;
          return error(RangeError, "RSV2 and RSV3 must be clear", true, 1002);
        }
        const compressed = (buf[0] & 64) === 64;
        if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
          this._loop = false;
          return error(RangeError, "RSV1 must be clear", true, 1002);
        }
        this._fin = (buf[0] & 128) === 128;
        this._opcode = buf[0] & 15;
        this._payloadLength = buf[1] & 127;
        if (this._opcode === 0) {
          if (compressed) {
            this._loop = false;
            return error(RangeError, "RSV1 must be clear", true, 1002);
          }
          if (!this._fragmented) {
            this._loop = false;
            return error(RangeError, "invalid opcode 0", true, 1002);
          }
          this._opcode = this._fragmented;
        } else if (this._opcode === 1 || this._opcode === 2) {
          if (this._fragmented) {
            this._loop = false;
            return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002);
          }
          this._compressed = compressed;
        } else if (this._opcode > 7 && this._opcode < 11) {
          if (!this._fin) {
            this._loop = false;
            return error(RangeError, "FIN must be set", true, 1002);
          }
          if (compressed) {
            this._loop = false;
            return error(RangeError, "RSV1 must be clear", true, 1002);
          }
          if (this._payloadLength > 125) {
            this._loop = false;
            return error(
              RangeError,
              `invalid payload length ${this._payloadLength}`,
              true,
              1002
            );
          }
        } else {
          this._loop = false;
          return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002);
        }
        if (!this._fin && !this._fragmented)
          this._fragmented = this._opcode;
        this._masked = (buf[1] & 128) === 128;
        if (this._payloadLength === 126)
          this._state = GET_PAYLOAD_LENGTH_16;
        else if (this._payloadLength === 127)
          this._state = GET_PAYLOAD_LENGTH_64;
        else
          return this.haveLength();
      }
      getPayloadLength16() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        this._payloadLength = this.consume(2).readUInt16BE(0);
        return this.haveLength();
      }
      getPayloadLength64() {
        if (this._bufferedBytes < 8) {
          this._loop = false;
          return;
        }
        const buf = this.consume(8);
        const num = buf.readUInt32BE(0);
        if (num > Math.pow(2, 53 - 32) - 1) {
          this._loop = false;
          return error(
            RangeError,
            "Unsupported WebSocket frame: payload length > 2^53 - 1",
            false,
            1009
          );
        }
        this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
        return this.haveLength();
      }
      haveLength() {
        if (this._payloadLength && this._opcode < 8) {
          this._totalPayloadLength += this._payloadLength;
          if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
            this._loop = false;
            return error(RangeError, "Max payload size exceeded", false, 1009);
          }
        }
        if (this._masked)
          this._state = GET_MASK;
        else
          this._state = GET_DATA;
      }
      getMask() {
        if (this._bufferedBytes < 4) {
          this._loop = false;
          return;
        }
        this._mask = this.consume(4);
        this._state = GET_DATA;
      }
      getData(cb) {
        var data = constants.EMPTY_BUFFER;
        if (this._payloadLength) {
          if (this._bufferedBytes < this._payloadLength) {
            this._loop = false;
            return;
          }
          data = this.consume(this._payloadLength);
          if (this._masked)
            bufferUtil.unmask(data, this._mask);
        }
        if (this._opcode > 7)
          return this.controlMessage(data);
        if (this._compressed) {
          this._state = INFLATING;
          this.decompress(data, cb);
          return;
        }
        if (data.length) {
          this._messageLength = this._totalPayloadLength;
          this._fragments.push(data);
        }
        return this.dataMessage();
      }
      decompress(data, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        perMessageDeflate.decompress(data, this._fin, (err, buf) => {
          if (err)
            return cb(err);
          if (buf.length) {
            this._messageLength += buf.length;
            if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
              return cb(error(RangeError, "Max payload size exceeded", false, 1009));
            }
            this._fragments.push(buf);
          }
          const er = this.dataMessage();
          if (er)
            return cb(er);
          this.startLoop(cb);
        });
      }
      dataMessage() {
        if (this._fin) {
          const messageLength = this._messageLength;
          const fragments = this._fragments;
          this._totalPayloadLength = 0;
          this._messageLength = 0;
          this._fragmented = 0;
          this._fragments = [];
          if (this._opcode === 2) {
            var data;
            if (this._binaryType === "nodebuffer") {
              data = toBuffer(fragments, messageLength);
            } else if (this._binaryType === "arraybuffer") {
              data = toArrayBuffer(toBuffer(fragments, messageLength));
            } else {
              data = fragments;
            }
            this.emit("message", data);
          } else {
            const buf = toBuffer(fragments, messageLength);
            if (!validation.isValidUTF8(buf)) {
              this._loop = false;
              return error(Error, "invalid UTF-8 sequence", true, 1007);
            }
            this.emit("message", buf.toString());
          }
        }
        this._state = GET_INFO;
      }
      controlMessage(data) {
        if (this._opcode === 8) {
          this._loop = false;
          if (data.length === 0) {
            this.emit("conclude", 1005, "");
            this.end();
          } else if (data.length === 1) {
            return error(RangeError, "invalid payload length 1", true, 1002);
          } else {
            const code = data.readUInt16BE(0);
            if (!validation.isValidStatusCode(code)) {
              return error(RangeError, `invalid status code ${code}`, true, 1002);
            }
            const buf = data.slice(2);
            if (!validation.isValidUTF8(buf)) {
              return error(Error, "invalid UTF-8 sequence", true, 1007);
            }
            this.emit("conclude", code, buf.toString());
            this.end();
          }
          return;
        }
        if (this._opcode === 9)
          this.emit("ping", data);
        else
          this.emit("pong", data);
        this._state = GET_INFO;
      }
    };
    module2.exports = Receiver;
    function error(ErrorCtor, message, prefix, statusCode) {
      const err = new ErrorCtor(
        prefix ? `Invalid WebSocket frame: ${message}` : message
      );
      Error.captureStackTrace(err, error);
      err[constants.kStatusCode] = statusCode;
      return err;
    }
    function toBuffer(fragments, messageLength) {
      if (fragments.length === 1)
        return fragments[0];
      if (fragments.length > 1)
        return bufferUtil.concat(fragments, messageLength);
      return constants.EMPTY_BUFFER;
    }
    function toArrayBuffer(buf) {
      if (buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength) {
        return buf.buffer;
      }
      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
    }
  }
});

// node_modules/ws/lib/sender.js
var require_sender = __commonJS({
  "node_modules/ws/lib/sender.js"(exports, module2) {
    "use strict";
    var crypto = require("crypto");
    var PerMessageDeflate = require_permessage_deflate();
    var bufferUtil = require_buffer_util();
    var validation = require_validation();
    var constants = require_constants2();
    var Sender = class {
      constructor(socket, extensions) {
        this._extensions = extensions || {};
        this._socket = socket;
        this._firstFragment = true;
        this._compress = false;
        this._bufferedBytes = 0;
        this._deflating = false;
        this._queue = [];
      }
      static frame(data, options) {
        const merge = data.length < 1024 || options.mask && options.readOnly;
        var offset = options.mask ? 6 : 2;
        var payloadLength = data.length;
        if (data.length >= 65536) {
          offset += 8;
          payloadLength = 127;
        } else if (data.length > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const target = Buffer.allocUnsafe(merge ? data.length + offset : offset);
        target[0] = options.fin ? options.opcode | 128 : options.opcode;
        if (options.rsv1)
          target[0] |= 64;
        if (payloadLength === 126) {
          target.writeUInt16BE(data.length, 2);
        } else if (payloadLength === 127) {
          target.writeUInt32BE(0, 2);
          target.writeUInt32BE(data.length, 6);
        }
        if (!options.mask) {
          target[1] = payloadLength;
          if (merge) {
            data.copy(target, offset);
            return [target];
          }
          return [target, data];
        }
        const mask = crypto.randomBytes(4);
        target[1] = payloadLength | 128;
        target[offset - 4] = mask[0];
        target[offset - 3] = mask[1];
        target[offset - 2] = mask[2];
        target[offset - 1] = mask[3];
        if (merge) {
          bufferUtil.mask(data, mask, target, offset, data.length);
          return [target];
        }
        bufferUtil.mask(data, mask, data, 0, data.length);
        return [target, data];
      }
      close(code, data, mask, cb) {
        var buf;
        if (code === void 0) {
          buf = constants.EMPTY_BUFFER;
        } else if (typeof code !== "number" || !validation.isValidStatusCode(code)) {
          throw new TypeError("First argument must be a valid error code number");
        } else if (data === void 0 || data === "") {
          buf = Buffer.allocUnsafe(2);
          buf.writeUInt16BE(code, 0);
        } else {
          buf = Buffer.allocUnsafe(2 + Buffer.byteLength(data));
          buf.writeUInt16BE(code, 0);
          buf.write(data, 2);
        }
        if (this._deflating) {
          this.enqueue([this.doClose, buf, mask, cb]);
        } else {
          this.doClose(buf, mask, cb);
        }
      }
      doClose(data, mask, cb) {
        this.sendFrame(Sender.frame(data, {
          fin: true,
          rsv1: false,
          opcode: 8,
          mask,
          readOnly: false
        }), cb);
      }
      ping(data, mask, cb) {
        var readOnly = true;
        if (!Buffer.isBuffer(data)) {
          if (data instanceof ArrayBuffer) {
            data = Buffer.from(data);
          } else if (ArrayBuffer.isView(data)) {
            data = viewToBuffer(data);
          } else {
            data = Buffer.from(data);
            readOnly = false;
          }
        }
        if (this._deflating) {
          this.enqueue([this.doPing, data, mask, readOnly, cb]);
        } else {
          this.doPing(data, mask, readOnly, cb);
        }
      }
      doPing(data, mask, readOnly, cb) {
        this.sendFrame(Sender.frame(data, {
          fin: true,
          rsv1: false,
          opcode: 9,
          mask,
          readOnly
        }), cb);
      }
      pong(data, mask, cb) {
        var readOnly = true;
        if (!Buffer.isBuffer(data)) {
          if (data instanceof ArrayBuffer) {
            data = Buffer.from(data);
          } else if (ArrayBuffer.isView(data)) {
            data = viewToBuffer(data);
          } else {
            data = Buffer.from(data);
            readOnly = false;
          }
        }
        if (this._deflating) {
          this.enqueue([this.doPong, data, mask, readOnly, cb]);
        } else {
          this.doPong(data, mask, readOnly, cb);
        }
      }
      doPong(data, mask, readOnly, cb) {
        this.sendFrame(Sender.frame(data, {
          fin: true,
          rsv1: false,
          opcode: 10,
          mask,
          readOnly
        }), cb);
      }
      send(data, options, cb) {
        var opcode = options.binary ? 2 : 1;
        var rsv1 = options.compress;
        var readOnly = true;
        if (!Buffer.isBuffer(data)) {
          if (data instanceof ArrayBuffer) {
            data = Buffer.from(data);
          } else if (ArrayBuffer.isView(data)) {
            data = viewToBuffer(data);
          } else {
            data = Buffer.from(data);
            readOnly = false;
          }
        }
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        if (this._firstFragment) {
          this._firstFragment = false;
          if (rsv1 && perMessageDeflate) {
            rsv1 = data.length >= perMessageDeflate._threshold;
          }
          this._compress = rsv1;
        } else {
          rsv1 = false;
          opcode = 0;
        }
        if (options.fin)
          this._firstFragment = true;
        if (perMessageDeflate) {
          const opts = {
            fin: options.fin,
            rsv1,
            opcode,
            mask: options.mask,
            readOnly
          };
          if (this._deflating) {
            this.enqueue([this.dispatch, data, this._compress, opts, cb]);
          } else {
            this.dispatch(data, this._compress, opts, cb);
          }
        } else {
          this.sendFrame(Sender.frame(data, {
            fin: options.fin,
            rsv1: false,
            opcode,
            mask: options.mask,
            readOnly
          }), cb);
        }
      }
      dispatch(data, compress, options, cb) {
        if (!compress) {
          this.sendFrame(Sender.frame(data, options), cb);
          return;
        }
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        this._deflating = true;
        perMessageDeflate.compress(data, options.fin, (_, buf) => {
          options.readOnly = false;
          this.sendFrame(Sender.frame(buf, options), cb);
          this._deflating = false;
          this.dequeue();
        });
      }
      dequeue() {
        while (!this._deflating && this._queue.length) {
          const params = this._queue.shift();
          this._bufferedBytes -= params[1].length;
          params[0].apply(this, params.slice(1));
        }
      }
      enqueue(params) {
        this._bufferedBytes += params[1].length;
        this._queue.push(params);
      }
      sendFrame(list, cb) {
        if (list.length === 2) {
          this._socket.write(list[0]);
          this._socket.write(list[1], cb);
        } else {
          this._socket.write(list[0], cb);
        }
      }
    };
    module2.exports = Sender;
    function viewToBuffer(view) {
      const buf = Buffer.from(view.buffer);
      if (view.byteLength !== view.buffer.byteLength) {
        return buf.slice(view.byteOffset, view.byteOffset + view.byteLength);
      }
      return buf;
    }
  }
});

// node_modules/ws/lib/websocket.js
var require_websocket = __commonJS({
  "node_modules/ws/lib/websocket.js"(exports, module2) {
    "use strict";
    var EventEmitter = require("events");
    var crypto = require("crypto");
    var https = require("https");
    var http = require("http");
    var net = require("net");
    var tls = require("tls");
    var url = require("url");
    var PerMessageDeflate = require_permessage_deflate();
    var EventTarget = require_event_target();
    var extension = require_extension();
    var constants = require_constants2();
    var Receiver = require_receiver();
    var Sender = require_sender();
    var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
    var kWebSocket = constants.kWebSocket;
    var protocolVersions = [8, 13];
    var closeTimeout = 30 * 1e3;
    var WebSocket = class extends EventEmitter {
      constructor(address, protocols, options) {
        super();
        this.readyState = WebSocket.CONNECTING;
        this.protocol = "";
        this._binaryType = constants.BINARY_TYPES[0];
        this._closeFrameReceived = false;
        this._closeFrameSent = false;
        this._closeMessage = "";
        this._closeTimer = null;
        this._closeCode = 1006;
        this._extensions = {};
        this._isServer = true;
        this._receiver = null;
        this._sender = null;
        this._socket = null;
        if (address !== null) {
          if (Array.isArray(protocols)) {
            protocols = protocols.join(", ");
          } else if (typeof protocols === "object" && protocols !== null) {
            options = protocols;
            protocols = void 0;
          }
          initAsClient.call(this, address, protocols, options);
        }
      }
      get CONNECTING() {
        return WebSocket.CONNECTING;
      }
      get CLOSING() {
        return WebSocket.CLOSING;
      }
      get CLOSED() {
        return WebSocket.CLOSED;
      }
      get OPEN() {
        return WebSocket.OPEN;
      }
      get binaryType() {
        return this._binaryType;
      }
      set binaryType(type) {
        if (constants.BINARY_TYPES.indexOf(type) < 0)
          return;
        this._binaryType = type;
        if (this._receiver)
          this._receiver._binaryType = type;
      }
      get bufferedAmount() {
        if (!this._socket)
          return 0;
        return (this._socket.bufferSize || 0) + this._sender._bufferedBytes;
      }
      get extensions() {
        return Object.keys(this._extensions).join();
      }
      setSocket(socket, head, maxPayload) {
        const receiver = new Receiver(
          this._binaryType,
          this._extensions,
          maxPayload
        );
        this._sender = new Sender(socket, this._extensions);
        this._receiver = receiver;
        this._socket = socket;
        receiver[kWebSocket] = this;
        socket[kWebSocket] = this;
        receiver.on("conclude", receiverOnConclude);
        receiver.on("drain", receiverOnDrain);
        receiver.on("error", receiverOnError);
        receiver.on("message", receiverOnMessage);
        receiver.on("ping", receiverOnPing);
        receiver.on("pong", receiverOnPong);
        socket.setTimeout(0);
        socket.setNoDelay();
        if (head.length > 0)
          socket.unshift(head);
        socket.on("close", socketOnClose);
        socket.on("data", socketOnData);
        socket.on("end", socketOnEnd);
        socket.on("error", socketOnError);
        this.readyState = WebSocket.OPEN;
        this.emit("open");
      }
      emitClose() {
        this.readyState = WebSocket.CLOSED;
        if (!this._socket) {
          this.emit("close", this._closeCode, this._closeMessage);
          return;
        }
        if (this._extensions[PerMessageDeflate.extensionName]) {
          this._extensions[PerMessageDeflate.extensionName].cleanup();
        }
        this._receiver.removeAllListeners();
        this.emit("close", this._closeCode, this._closeMessage);
      }
      close(code, data) {
        if (this.readyState === WebSocket.CLOSED)
          return;
        if (this.readyState === WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          return abortHandshake(this, this._req, msg);
        }
        if (this.readyState === WebSocket.CLOSING) {
          if (this._closeFrameSent && this._closeFrameReceived)
            this._socket.end();
          return;
        }
        this.readyState = WebSocket.CLOSING;
        this._sender.close(code, data, !this._isServer, (err) => {
          if (err)
            return;
          this._closeFrameSent = true;
          if (this._socket.writable) {
            if (this._closeFrameReceived)
              this._socket.end();
            this._closeTimer = setTimeout(
              this._socket.destroy.bind(this._socket),
              closeTimeout
            );
          }
        });
      }
      ping(data, mask, cb) {
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (this.readyState !== WebSocket.OPEN) {
          const err = new Error(
            `WebSocket is not open: readyState ${this.readyState} (${readyStates[this.readyState]})`
          );
          if (cb)
            return cb(err);
          throw err;
        }
        if (typeof data === "number")
          data = data.toString();
        if (mask === void 0)
          mask = !this._isServer;
        this._sender.ping(data || constants.EMPTY_BUFFER, mask, cb);
      }
      pong(data, mask, cb) {
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (this.readyState !== WebSocket.OPEN) {
          const err = new Error(
            `WebSocket is not open: readyState ${this.readyState} (${readyStates[this.readyState]})`
          );
          if (cb)
            return cb(err);
          throw err;
        }
        if (typeof data === "number")
          data = data.toString();
        if (mask === void 0)
          mask = !this._isServer;
        this._sender.pong(data || constants.EMPTY_BUFFER, mask, cb);
      }
      send(data, options, cb) {
        if (typeof options === "function") {
          cb = options;
          options = {};
        }
        if (this.readyState !== WebSocket.OPEN) {
          const err = new Error(
            `WebSocket is not open: readyState ${this.readyState} (${readyStates[this.readyState]})`
          );
          if (cb)
            return cb(err);
          throw err;
        }
        if (typeof data === "number")
          data = data.toString();
        const opts = Object.assign({
          binary: typeof data !== "string",
          mask: !this._isServer,
          compress: true,
          fin: true
        }, options);
        if (!this._extensions[PerMessageDeflate.extensionName]) {
          opts.compress = false;
        }
        this._sender.send(data || constants.EMPTY_BUFFER, opts, cb);
      }
      terminate() {
        if (this.readyState === WebSocket.CLOSED)
          return;
        if (this.readyState === WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          return abortHandshake(this, this._req, msg);
        }
        if (this._socket) {
          this.readyState = WebSocket.CLOSING;
          this._socket.destroy();
        }
      }
    };
    readyStates.forEach((readyState, i) => {
      WebSocket[readyStates[i]] = i;
    });
    ["open", "error", "close", "message"].forEach((method) => {
      Object.defineProperty(WebSocket.prototype, `on${method}`, {
        get() {
          const listeners = this.listeners(method);
          for (var i = 0; i < listeners.length; i++) {
            if (listeners[i]._listener)
              return listeners[i]._listener;
          }
        },
        set(listener) {
          const listeners = this.listeners(method);
          for (var i = 0; i < listeners.length; i++) {
            if (listeners[i]._listener)
              this.removeListener(method, listeners[i]);
          }
          this.addEventListener(method, listener);
        }
      });
    });
    WebSocket.prototype.addEventListener = EventTarget.addEventListener;
    WebSocket.prototype.removeEventListener = EventTarget.removeEventListener;
    module2.exports = WebSocket;
    function initAsClient(address, protocols, options) {
      options = Object.assign({
        protocolVersion: protocolVersions[1],
        perMessageDeflate: true
      }, options, {
        createConnection: void 0,
        socketPath: void 0,
        hostname: void 0,
        protocol: void 0,
        timeout: void 0,
        method: void 0,
        auth: void 0,
        host: void 0,
        path: void 0,
        port: void 0
      });
      if (protocolVersions.indexOf(options.protocolVersion) === -1) {
        throw new RangeError(
          `Unsupported protocol version: ${options.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`
        );
      }
      this._isServer = false;
      var parsedUrl;
      if (typeof address === "object" && address.href !== void 0) {
        parsedUrl = address;
        this.url = address.href;
      } else {
        parsedUrl = url.parse(address);
        this.url = address;
      }
      const isUnixSocket = parsedUrl.protocol === "ws+unix:";
      if (!parsedUrl.host && (!isUnixSocket || !parsedUrl.pathname)) {
        throw new Error(`Invalid URL: ${this.url}`);
      }
      const isSecure = parsedUrl.protocol === "wss:" || parsedUrl.protocol === "https:";
      const key = crypto.randomBytes(16).toString("base64");
      const httpObj = isSecure ? https : http;
      const path = parsedUrl.search ? `${parsedUrl.pathname || "/"}${parsedUrl.search}` : parsedUrl.pathname || "/";
      var perMessageDeflate;
      options.createConnection = isSecure ? tlsConnect : netConnect;
      options.port = parsedUrl.port || (isSecure ? 443 : 80);
      options.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
      options.headers = Object.assign({
        "Sec-WebSocket-Version": options.protocolVersion,
        "Sec-WebSocket-Key": key,
        "Connection": "Upgrade",
        "Upgrade": "websocket"
      }, options.headers);
      options.path = path;
      if (options.perMessageDeflate) {
        perMessageDeflate = new PerMessageDeflate(
          options.perMessageDeflate !== true ? options.perMessageDeflate : {},
          false
        );
        options.headers["Sec-WebSocket-Extensions"] = extension.format({
          [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
        });
      }
      if (protocols) {
        options.headers["Sec-WebSocket-Protocol"] = protocols;
      }
      if (options.origin) {
        if (options.protocolVersion < 13) {
          options.headers["Sec-WebSocket-Origin"] = options.origin;
        } else {
          options.headers.Origin = options.origin;
        }
      }
      if (parsedUrl.auth) {
        options.auth = parsedUrl.auth;
      } else if (parsedUrl.username || parsedUrl.password) {
        options.auth = `${parsedUrl.username}:${parsedUrl.password}`;
      }
      if (isUnixSocket) {
        const parts = path.split(":");
        if (options.agent == null && process.versions.modules < 57) {
          options._socketPath = parts[0];
        } else {
          options.socketPath = parts[0];
        }
        options.path = parts[1];
      }
      var req = this._req = httpObj.get(options);
      if (options.handshakeTimeout) {
        req.setTimeout(
          options.handshakeTimeout,
          () => abortHandshake(this, req, "Opening handshake has timed out")
        );
      }
      req.on("error", (err) => {
        if (this._req.aborted)
          return;
        req = this._req = null;
        this.readyState = WebSocket.CLOSING;
        this.emit("error", err);
        this.emitClose();
      });
      req.on("response", (res) => {
        if (this.emit("unexpected-response", req, res))
          return;
        abortHandshake(this, req, `Unexpected server response: ${res.statusCode}`);
      });
      req.on("upgrade", (res, socket, head) => {
        this.emit("upgrade", res);
        if (this.readyState !== WebSocket.CONNECTING)
          return;
        req = this._req = null;
        const digest = crypto.createHash("sha1").update(key + constants.GUID, "binary").digest("base64");
        if (res.headers["sec-websocket-accept"] !== digest) {
          abortHandshake(this, socket, "Invalid Sec-WebSocket-Accept header");
          return;
        }
        const serverProt = res.headers["sec-websocket-protocol"];
        const protList = (protocols || "").split(/, */);
        var protError;
        if (!protocols && serverProt) {
          protError = "Server sent a subprotocol but none was requested";
        } else if (protocols && !serverProt) {
          protError = "Server sent no subprotocol";
        } else if (serverProt && protList.indexOf(serverProt) === -1) {
          protError = "Server sent an invalid subprotocol";
        }
        if (protError) {
          abortHandshake(this, socket, protError);
          return;
        }
        if (serverProt)
          this.protocol = serverProt;
        if (perMessageDeflate) {
          try {
            const extensions = extension.parse(
              res.headers["sec-websocket-extensions"]
            );
            if (extensions[PerMessageDeflate.extensionName]) {
              perMessageDeflate.accept(
                extensions[PerMessageDeflate.extensionName]
              );
              this._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
            }
          } catch (err) {
            abortHandshake(this, socket, "Invalid Sec-WebSocket-Extensions header");
            return;
          }
        }
        this.setSocket(socket, head, 0);
      });
    }
    function netConnect(options) {
      options.path = options.socketPath || options._socketPath || void 0;
      return net.connect(options);
    }
    function tlsConnect(options) {
      options.path = options.socketPath || options._socketPath || void 0;
      options.servername = options.servername || options.host;
      return tls.connect(options);
    }
    function abortHandshake(websocket, stream, message) {
      websocket.readyState = WebSocket.CLOSING;
      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshake);
      if (stream.setHeader) {
        stream.abort();
        stream.once("abort", websocket.emitClose.bind(websocket));
        websocket.emit("error", err);
      } else {
        stream.destroy(err);
        stream.once("error", websocket.emit.bind(websocket, "error"));
        stream.once("close", websocket.emitClose.bind(websocket));
      }
    }
    function receiverOnConclude(code, reason) {
      const websocket = this[kWebSocket];
      websocket._socket.removeListener("data", socketOnData);
      websocket._socket.resume();
      websocket._closeFrameReceived = true;
      websocket._closeMessage = reason;
      websocket._closeCode = code;
      if (code === 1005)
        websocket.close();
      else
        websocket.close(code, reason);
    }
    function receiverOnDrain() {
      this[kWebSocket]._socket.resume();
    }
    function receiverOnError(err) {
      const websocket = this[kWebSocket];
      websocket._socket.removeListener("data", socketOnData);
      websocket.readyState = WebSocket.CLOSING;
      websocket._closeCode = err[constants.kStatusCode];
      websocket.emit("error", err);
      websocket._socket.destroy();
    }
    function receiverOnFinish() {
      this[kWebSocket].emitClose();
    }
    function receiverOnMessage(data) {
      this[kWebSocket].emit("message", data);
    }
    function receiverOnPing(data) {
      const websocket = this[kWebSocket];
      websocket.pong(data, !websocket._isServer, constants.NOOP);
      websocket.emit("ping", data);
    }
    function receiverOnPong(data) {
      this[kWebSocket].emit("pong", data);
    }
    function socketOnClose() {
      const websocket = this[kWebSocket];
      this.removeListener("close", socketOnClose);
      this.removeListener("end", socketOnEnd);
      websocket.readyState = WebSocket.CLOSING;
      websocket._socket.read();
      websocket._receiver.end();
      this.removeListener("data", socketOnData);
      this[kWebSocket] = void 0;
      clearTimeout(websocket._closeTimer);
      if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
        websocket.emitClose();
      } else {
        websocket._receiver.on("error", receiverOnFinish);
        websocket._receiver.on("finish", receiverOnFinish);
      }
    }
    function socketOnData(chunk) {
      if (!this[kWebSocket]._receiver.write(chunk)) {
        this.pause();
      }
    }
    function socketOnEnd() {
      const websocket = this[kWebSocket];
      websocket.readyState = WebSocket.CLOSING;
      websocket._receiver.end();
      this.end();
    }
    function socketOnError() {
      const websocket = this[kWebSocket];
      this.removeListener("error", socketOnError);
      this.on("error", constants.NOOP);
      if (websocket) {
        websocket.readyState = WebSocket.CLOSING;
        this.destroy();
      }
    }
  }
});

// node_modules/ws/lib/websocket-server.js
var require_websocket_server = __commonJS({
  "node_modules/ws/lib/websocket-server.js"(exports, module2) {
    "use strict";
    var EventEmitter = require("events");
    var crypto = require("crypto");
    var http = require("http");
    var url = require("url");
    var PerMessageDeflate = require_permessage_deflate();
    var extension = require_extension();
    var constants = require_constants2();
    var WebSocket = require_websocket();
    var WebSocketServer = class extends EventEmitter {
      constructor(options, callback) {
        super();
        options = Object.assign({
          maxPayload: 100 * 1024 * 1024,
          perMessageDeflate: false,
          handleProtocols: null,
          clientTracking: true,
          verifyClient: null,
          noServer: false,
          backlog: null,
          server: null,
          host: null,
          path: null,
          port: null
        }, options);
        if (options.port == null && !options.server && !options.noServer) {
          throw new TypeError(
            'One of the "port", "server", or "noServer" options must be specified'
          );
        }
        if (options.port != null) {
          this._server = http.createServer((req, res) => {
            const body = http.STATUS_CODES[426];
            res.writeHead(426, {
              "Content-Length": body.length,
              "Content-Type": "text/plain"
            });
            res.end(body);
          });
          this._server.listen(options.port, options.host, options.backlog, callback);
        } else if (options.server) {
          this._server = options.server;
        }
        if (this._server) {
          this._removeListeners = addListeners(this._server, {
            listening: this.emit.bind(this, "listening"),
            error: this.emit.bind(this, "error"),
            upgrade: (req, socket, head) => {
              this.handleUpgrade(req, socket, head, (ws) => {
                this.emit("connection", ws, req);
              });
            }
          });
        }
        if (options.perMessageDeflate === true)
          options.perMessageDeflate = {};
        if (options.clientTracking)
          this.clients = /* @__PURE__ */ new Set();
        this.options = options;
      }
      address() {
        if (this.options.noServer) {
          throw new Error('The server is operating in "noServer" mode');
        }
        if (!this._server)
          return null;
        return this._server.address();
      }
      close(cb) {
        if (this.clients) {
          for (const client of this.clients)
            client.terminate();
        }
        const server = this._server;
        if (server) {
          this._removeListeners();
          this._removeListeners = this._server = null;
          if (this.options.port != null)
            return server.close(cb);
        }
        if (cb)
          cb();
      }
      shouldHandle(req) {
        if (this.options.path && url.parse(req.url).pathname !== this.options.path) {
          return false;
        }
        return true;
      }
      handleUpgrade(req, socket, head, cb) {
        socket.on("error", socketOnError);
        const version = +req.headers["sec-websocket-version"];
        const extensions = {};
        if (req.method !== "GET" || req.headers.upgrade.toLowerCase() !== "websocket" || !req.headers["sec-websocket-key"] || version !== 8 && version !== 13 || !this.shouldHandle(req)) {
          return abortHandshake(socket, 400);
        }
        if (this.options.perMessageDeflate) {
          const perMessageDeflate = new PerMessageDeflate(
            this.options.perMessageDeflate,
            true,
            this.options.maxPayload
          );
          try {
            const offers = extension.parse(
              req.headers["sec-websocket-extensions"]
            );
            if (offers[PerMessageDeflate.extensionName]) {
              perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
              extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
            }
          } catch (err) {
            return abortHandshake(socket, 400);
          }
        }
        if (this.options.verifyClient) {
          const info = {
            origin: req.headers[`${version === 8 ? "sec-websocket-origin" : "origin"}`],
            secure: !!(req.connection.authorized || req.connection.encrypted),
            req
          };
          if (this.options.verifyClient.length === 2) {
            this.options.verifyClient(info, (verified, code, message, headers) => {
              if (!verified) {
                return abortHandshake(socket, code || 401, message, headers);
              }
              this.completeUpgrade(extensions, req, socket, head, cb);
            });
            return;
          }
          if (!this.options.verifyClient(info))
            return abortHandshake(socket, 401);
        }
        this.completeUpgrade(extensions, req, socket, head, cb);
      }
      completeUpgrade(extensions, req, socket, head, cb) {
        if (!socket.readable || !socket.writable)
          return socket.destroy();
        const key = crypto.createHash("sha1").update(req.headers["sec-websocket-key"] + constants.GUID, "binary").digest("base64");
        const headers = [
          "HTTP/1.1 101 Switching Protocols",
          "Upgrade: websocket",
          "Connection: Upgrade",
          `Sec-WebSocket-Accept: ${key}`
        ];
        const ws = new WebSocket(null);
        var protocol = req.headers["sec-websocket-protocol"];
        if (protocol) {
          protocol = protocol.split(",").map(trim);
          if (this.options.handleProtocols) {
            protocol = this.options.handleProtocols(protocol, req);
          } else {
            protocol = protocol[0];
          }
          if (protocol) {
            headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
            ws.protocol = protocol;
          }
        }
        if (extensions[PerMessageDeflate.extensionName]) {
          const params = extensions[PerMessageDeflate.extensionName].params;
          const value = extension.format({
            [PerMessageDeflate.extensionName]: [params]
          });
          headers.push(`Sec-WebSocket-Extensions: ${value}`);
          ws._extensions = extensions;
        }
        this.emit("headers", headers, req);
        socket.write(headers.concat("\r\n").join("\r\n"));
        socket.removeListener("error", socketOnError);
        ws.setSocket(socket, head, this.options.maxPayload);
        if (this.clients) {
          this.clients.add(ws);
          ws.on("close", () => this.clients.delete(ws));
        }
        cb(ws);
      }
    };
    module2.exports = WebSocketServer;
    function addListeners(server, map) {
      for (const event of Object.keys(map))
        server.on(event, map[event]);
      return function removeListeners() {
        for (const event of Object.keys(map)) {
          server.removeListener(event, map[event]);
        }
      };
    }
    function socketOnError() {
      this.destroy();
    }
    function abortHandshake(socket, code, message, headers) {
      if (socket.writable) {
        message = message || http.STATUS_CODES[code];
        headers = Object.assign({
          "Connection": "close",
          "Content-type": "text/html",
          "Content-Length": Buffer.byteLength(message)
        }, headers);
        socket.write(
          `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r
` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join("\r\n") + "\r\n\r\n" + message
        );
      }
      socket.removeListener("error", socketOnError);
      socket.destroy();
    }
    function trim(str) {
      return str.trim();
    }
  }
});

// node_modules/ws/index.js
var require_ws = __commonJS({
  "node_modules/ws/index.js"(exports, module2) {
    "use strict";
    var WebSocket = require_websocket();
    WebSocket.Server = require_websocket_server();
    WebSocket.Receiver = require_receiver();
    WebSocket.Sender = require_sender();
    module2.exports = WebSocket;
  }
});

// node_modules/isomorphic-ws/node.js
var require_node2 = __commonJS({
  "node_modules/isomorphic-ws/node.js"(exports, module2) {
    "use strict";
    module2.exports = require_ws();
  }
});

// node_modules/thrift/lib/nodejs/lib/thrift/int64_util.js
var require_int64_util = __commonJS({
  "node_modules/thrift/lib/nodejs/lib/thrift/int64_util.js"(exports, module2) {
    var Int64 = require_Int64();
    var Int64Util = module2.exports = {};
    var POW2_24 = Math.pow(2, 24);
    var POW2_31 = Math.pow(2, 31);
    var POW2_32 = Math.pow(2, 32);
    var POW10_11 = Math.pow(10, 11);
    Int64Util.toDecimalString = function(i64) {
      var b = i64.buffer;
      var o = i64.offset;
      if (!b[o] && !(b[o + 1] & 224) || !~b[o] && !~(b[o + 1] & 224)) {
        return i64.toString();
      } else {
        var negative = b[o] & 128;
        if (negative) {
          var incremented = false;
          var buffer = new Buffer(8);
          for (var i = 7; i >= 0; --i) {
            buffer[i] = ~b[o + i] + (incremented ? 0 : 1) & 255;
            incremented |= b[o + i];
          }
          b = buffer;
        }
        var high2 = b[o + 1] + (b[o] << 8);
        var low = b[o + 7] + (b[o + 6] << 8) + (b[o + 5] << 16) + b[o + 4] * POW2_24 + (b[o + 3] + (b[o + 2] << 8)) * POW2_32 + high2 * 74976710656;
        var high = Math.floor(low / POW10_11) + high2 * 2814;
        low = ("00000000000" + String(low % POW10_11)).slice(-11);
        return (negative ? "-" : "") + String(high) + low;
      }
    };
    Int64Util.fromDecimalString = function(text) {
      var negative = text.charAt(0) === "-";
      if (text.length < (negative ? 17 : 16)) {
        return new Int64(+text);
      } else if (text.length > (negative ? 20 : 19)) {
        throw new RangeError("Too many digits for Int64: " + text);
      } else {
        var high5 = +text.slice(negative ? 1 : 0, -15);
        var low = +text.slice(-15) + high5 * 2764472320;
        var high = Math.floor(low / POW2_32) + high5 * 232830;
        low = low % POW2_32;
        if (high >= POW2_31 && !(negative && high == POW2_31 && low == 0)) {
          throw new RangeError("The magnitude is too large for Int64.");
        }
        if (negative) {
          high = ~high;
          if (low === 0) {
            high = high + 1 & 4294967295;
          } else {
            low = ~low + 1;
          }
          high = 2147483648 | high;
        }
        return new Int64(high, low);
      }
    };
  }
});

// node_modules/thrift/lib/nodejs/lib/thrift/json_parse.js
var require_json_parse = __commonJS({
  "node_modules/thrift/lib/nodejs/lib/thrift/json_parse.js"(exports, module2) {
    var Int64 = require_Int64();
    var Int64Util = require_int64_util();
    var json_parse = module2.exports = function() {
      "use strict";
      var at, ch, escapee = {
        '"': '"',
        "\\": "\\",
        "/": "/",
        b: "\b",
        f: "\f",
        n: "\n",
        r: "\r",
        t: "	"
      }, text, error = function(m) {
        throw new SyntaxError(m);
      }, next = function(c) {
        if (c && c !== ch) {
          error("Expected '" + c + "' instead of '" + ch + "'");
        }
        ch = text.charAt(at);
        at += 1;
        return ch;
      }, number = function() {
        var number2, string2 = "";
        if (ch === "-") {
          string2 = "-";
          next("-");
        }
        while (ch >= "0" && ch <= "9") {
          string2 += ch;
          next();
        }
        if (ch === ".") {
          string2 += ".";
          while (next() && ch >= "0" && ch <= "9") {
            string2 += ch;
          }
        }
        if (ch === "e" || ch === "E") {
          string2 += ch;
          next();
          if (ch === "-" || ch === "+") {
            string2 += ch;
            next();
          }
          while (ch >= "0" && ch <= "9") {
            string2 += ch;
            next();
          }
        }
        number2 = +string2;
        if (!isFinite(number2)) {
          error("Bad number");
        } else if (number2 >= Int64.MAX_INT || number2 <= Int64.MIN_INT) {
          return string2;
        } else {
          return number2;
        }
      }, string = function() {
        var hex, i, string2 = "", uffff;
        if (ch === '"') {
          while (next()) {
            if (ch === '"') {
              next();
              return string2;
            }
            if (ch === "\\") {
              next();
              if (ch === "u") {
                uffff = 0;
                for (i = 0; i < 4; i += 1) {
                  hex = parseInt(next(), 16);
                  if (!isFinite(hex)) {
                    break;
                  }
                  uffff = uffff * 16 + hex;
                }
                string2 += String.fromCharCode(uffff);
              } else if (typeof escapee[ch] === "string") {
                string2 += escapee[ch];
              } else {
                break;
              }
            } else {
              string2 += ch;
            }
          }
        }
        error("Bad string");
      }, white = function() {
        while (ch && ch <= " ") {
          next();
        }
      }, word = function() {
        switch (ch) {
          case "t":
            next("t");
            next("r");
            next("u");
            next("e");
            return true;
          case "f":
            next("f");
            next("a");
            next("l");
            next("s");
            next("e");
            return false;
          case "n":
            next("n");
            next("u");
            next("l");
            next("l");
            return null;
        }
        error("Unexpected '" + ch + "'");
      }, value, array = function() {
        var array2 = [];
        if (ch === "[") {
          next("[");
          white();
          if (ch === "]") {
            next("]");
            return array2;
          }
          while (ch) {
            array2.push(value());
            white();
            if (ch === "]") {
              next("]");
              return array2;
            }
            next(",");
            white();
          }
        }
        error("Bad array");
      }, object = function() {
        var key, object2 = {};
        if (ch === "{") {
          next("{");
          white();
          if (ch === "}") {
            next("}");
            return object2;
          }
          while (ch) {
            key = string();
            white();
            next(":");
            if (Object.hasOwnProperty.call(object2, key)) {
              error('Duplicate key "' + key + '"');
            }
            object2[key] = value();
            white();
            if (ch === "}") {
              next("}");
              return object2;
            }
            next(",");
            white();
          }
        }
        error("Bad object");
      };
      value = function() {
        white();
        switch (ch) {
          case "{":
            return object();
          case "[":
            return array();
          case '"':
            return string();
          case "-":
            return number();
          default:
            return ch >= "0" && ch <= "9" ? number() : word();
        }
      };
      return function(source) {
        var result;
        text = source;
        at = 0;
        ch = " ";
        result = value();
        white();
        if (ch) {
          error("Syntax error");
        }
        return result;
      };
    }();
  }
});

// node_modules/thrift/lib/nodejs/lib/thrift/json_protocol.js
var require_json_protocol = __commonJS({
  "node_modules/thrift/lib/nodejs/lib/thrift/json_protocol.js"(exports, module2) {
    var Int64 = require_Int64();
    var Thrift = require_thrift();
    var Type = Thrift.Type;
    var util = require("util");
    var Int64Util = require_int64_util();
    var json_parse = require_json_parse();
    var InputBufferUnderrunError = require_input_buffer_underrun_error();
    module2.exports = TJSONProtocol;
    function TJSONProtocol(trans) {
      this.tstack = [];
      this.tpos = [];
      this.trans = trans;
    }
    TJSONProtocol.Type = {};
    TJSONProtocol.Type[Type.BOOL] = '"tf"';
    TJSONProtocol.Type[Type.BYTE] = '"i8"';
    TJSONProtocol.Type[Type.I16] = '"i16"';
    TJSONProtocol.Type[Type.I32] = '"i32"';
    TJSONProtocol.Type[Type.I64] = '"i64"';
    TJSONProtocol.Type[Type.DOUBLE] = '"dbl"';
    TJSONProtocol.Type[Type.STRUCT] = '"rec"';
    TJSONProtocol.Type[Type.STRING] = '"str"';
    TJSONProtocol.Type[Type.MAP] = '"map"';
    TJSONProtocol.Type[Type.LIST] = '"lst"';
    TJSONProtocol.Type[Type.SET] = '"set"';
    TJSONProtocol.RType = {};
    TJSONProtocol.RType.tf = Type.BOOL;
    TJSONProtocol.RType.i8 = Type.BYTE;
    TJSONProtocol.RType.i16 = Type.I16;
    TJSONProtocol.RType.i32 = Type.I32;
    TJSONProtocol.RType.i64 = Type.I64;
    TJSONProtocol.RType.dbl = Type.DOUBLE;
    TJSONProtocol.RType.rec = Type.STRUCT;
    TJSONProtocol.RType.str = Type.STRING;
    TJSONProtocol.RType.map = Type.MAP;
    TJSONProtocol.RType.lst = Type.LIST;
    TJSONProtocol.RType.set = Type.SET;
    TJSONProtocol.Version = 1;
    TJSONProtocol.prototype.flush = function() {
      this.writeToTransportIfStackIsFlushable();
      return this.trans.flush();
    };
    TJSONProtocol.prototype.writeToTransportIfStackIsFlushable = function() {
      if (this.tstack.length === 1) {
        this.trans.write(this.tstack.pop());
      }
    };
    TJSONProtocol.prototype.writeMessageBegin = function(name, messageType, seqid) {
      this.tstack.push([TJSONProtocol.Version, '"' + name + '"', messageType, seqid]);
    };
    TJSONProtocol.prototype.writeMessageEnd = function() {
      var obj = this.tstack.pop();
      this.wobj = this.tstack.pop();
      this.wobj.push(obj);
      this.wbuf = "[" + this.wobj.join(",") + "]";
      this.trans.write(this.wbuf);
    };
    TJSONProtocol.prototype.writeStructBegin = function(name) {
      this.tpos.push(this.tstack.length);
      this.tstack.push({});
    };
    TJSONProtocol.prototype.writeStructEnd = function() {
      var p = this.tpos.pop();
      var struct = this.tstack[p];
      var str = "{";
      var first = true;
      for (var key in struct) {
        if (first) {
          first = false;
        } else {
          str += ",";
        }
        str += key + ":" + struct[key];
      }
      str += "}";
      this.tstack[p] = str;
      this.writeToTransportIfStackIsFlushable();
    };
    TJSONProtocol.prototype.writeFieldBegin = function(name, fieldType, fieldId) {
      this.tpos.push(this.tstack.length);
      this.tstack.push({
        "fieldId": '"' + fieldId + '"',
        "fieldType": TJSONProtocol.Type[fieldType]
      });
    };
    TJSONProtocol.prototype.writeFieldEnd = function() {
      var value = this.tstack.pop();
      var fieldInfo = this.tstack.pop();
      if (":" + value === ":[object Object]") {
        this.tstack[this.tstack.length - 1][fieldInfo.fieldId] = "{" + fieldInfo.fieldType + ":" + JSON.stringify(value) + "}";
      } else {
        this.tstack[this.tstack.length - 1][fieldInfo.fieldId] = "{" + fieldInfo.fieldType + ":" + value + "}";
      }
      this.tpos.pop();
      this.writeToTransportIfStackIsFlushable();
    };
    TJSONProtocol.prototype.writeFieldStop = function() {
    };
    TJSONProtocol.prototype.writeMapBegin = function(keyType, valType, size) {
      this.tpos.push(this.tstack.length);
      this.tstack.push([TJSONProtocol.Type[keyType], TJSONProtocol.Type[valType], 0]);
    };
    TJSONProtocol.prototype.writeMapEnd = function() {
      var p = this.tpos.pop();
      if (p == this.tstack.length) {
        return;
      }
      if ((this.tstack.length - p - 1) % 2 !== 0) {
        this.tstack.push("");
      }
      var size = (this.tstack.length - p - 1) / 2;
      this.tstack[p][this.tstack[p].length - 1] = size;
      var map = "}";
      var first = true;
      while (this.tstack.length > p + 1) {
        var v = this.tstack.pop();
        var k = this.tstack.pop();
        if (first) {
          first = false;
        } else {
          map = "," + map;
        }
        if (!isNaN(k)) {
          k = '"' + k + '"';
        }
        map = k + ":" + v + map;
      }
      map = "{" + map;
      this.tstack[p].push(map);
      this.tstack[p] = "[" + this.tstack[p].join(",") + "]";
      this.writeToTransportIfStackIsFlushable();
    };
    TJSONProtocol.prototype.writeListBegin = function(elemType, size) {
      this.tpos.push(this.tstack.length);
      this.tstack.push([TJSONProtocol.Type[elemType], size]);
    };
    TJSONProtocol.prototype.writeListEnd = function() {
      var p = this.tpos.pop();
      while (this.tstack.length > p + 1) {
        var tmpVal = this.tstack[p + 1];
        this.tstack.splice(p + 1, 1);
        this.tstack[p].push(tmpVal);
      }
      this.tstack[p] = "[" + this.tstack[p].join(",") + "]";
      this.writeToTransportIfStackIsFlushable();
    };
    TJSONProtocol.prototype.writeSetBegin = function(elemType, size) {
      this.tpos.push(this.tstack.length);
      this.tstack.push([TJSONProtocol.Type[elemType], size]);
    };
    TJSONProtocol.prototype.writeSetEnd = function() {
      var p = this.tpos.pop();
      while (this.tstack.length > p + 1) {
        var tmpVal = this.tstack[p + 1];
        this.tstack.splice(p + 1, 1);
        this.tstack[p].push(tmpVal);
      }
      this.tstack[p] = "[" + this.tstack[p].join(",") + "]";
      this.writeToTransportIfStackIsFlushable();
    };
    TJSONProtocol.prototype.writeBool = function(bool) {
      this.tstack.push(bool ? 1 : 0);
    };
    TJSONProtocol.prototype.writeByte = function(byte) {
      this.tstack.push(byte);
    };
    TJSONProtocol.prototype.writeI16 = function(i16) {
      this.tstack.push(i16);
    };
    TJSONProtocol.prototype.writeI32 = function(i32) {
      this.tstack.push(i32);
    };
    TJSONProtocol.prototype.writeI64 = function(i64) {
      if (i64 instanceof Int64) {
        this.tstack.push(Int64Util.toDecimalString(i64));
      } else {
        this.tstack.push(i64);
      }
    };
    TJSONProtocol.prototype.writeDouble = function(dub) {
      this.tstack.push(dub);
    };
    TJSONProtocol.prototype.writeString = function(arg) {
      if (arg === null) {
        this.tstack.push(null);
      } else {
        if (typeof arg === "string") {
          var str = arg;
        } else if (arg instanceof Buffer) {
          var str = arg.toString("utf8");
        } else {
          throw new Error("writeString called without a string/Buffer argument: " + arg);
        }
        var escapedString = "";
        for (var i = 0; i < str.length; i++) {
          var ch = str.charAt(i);
          if (ch === '"') {
            escapedString += '\\"';
          } else if (ch === "\\") {
            escapedString += "\\\\";
          } else if (ch === "\b") {
            escapedString += "\\b";
          } else if (ch === "\f") {
            escapedString += "\\f";
          } else if (ch === "\n") {
            escapedString += "\\n";
          } else if (ch === "\r") {
            escapedString += "\\r";
          } else if (ch === "	") {
            escapedString += "\\t";
          } else {
            escapedString += ch;
          }
        }
        this.tstack.push('"' + escapedString + '"');
      }
    };
    TJSONProtocol.prototype.writeBinary = function(arg) {
      if (typeof arg === "string") {
        var buf = new Buffer(arg, "binary");
      } else if (arg instanceof Buffer || Object.prototype.toString.call(arg) == "[object Uint8Array]") {
        var buf = arg;
      } else {
        throw new Error("writeBinary called without a string/Buffer argument: " + arg);
      }
      this.tstack.push('"' + buf.toString("base64") + '"');
    };
    TJSONProtocol.prototype.readMessageBegin = function() {
      this.rstack = [];
      this.rpos = [];
      var transBuf = this.trans.borrow();
      if (transBuf.readIndex >= transBuf.writeIndex) {
        throw new InputBufferUnderrunError();
      }
      var cursor = transBuf.readIndex;
      if (transBuf.buf[cursor] !== 91) {
        throw new Error("Malformed JSON input, no opening bracket");
      }
      cursor++;
      var openBracketCount = 1;
      var inString = false;
      for (; cursor < transBuf.writeIndex; cursor++) {
        var chr = transBuf.buf[cursor];
        if (inString) {
          if (chr === 34) {
            inString = false;
          } else if (chr === 92) {
            cursor += 1;
          }
        } else {
          if (chr === 91) {
            openBracketCount += 1;
          } else if (chr === 93) {
            openBracketCount -= 1;
            if (openBracketCount === 0) {
              break;
            }
          } else if (chr === 34) {
            inString = true;
          }
        }
      }
      if (openBracketCount !== 0) {
        throw new InputBufferUnderrunError();
      }
      this.robj = json_parse(transBuf.buf.slice(transBuf.readIndex, cursor + 1).toString());
      this.trans.consume(cursor + 1 - transBuf.readIndex);
      var version = this.robj.shift();
      if (version != TJSONProtocol.Version) {
        throw new Error("Wrong thrift protocol version: " + version);
      }
      var r = {};
      r.fname = this.robj.shift();
      r.mtype = this.robj.shift();
      r.rseqid = this.robj.shift();
      this.rstack.push(this.robj.shift());
      return r;
    };
    TJSONProtocol.prototype.readMessageEnd = function() {
    };
    TJSONProtocol.prototype.readStructBegin = function() {
      var r = {};
      r.fname = "";
      if (this.rstack[this.rstack.length - 1] instanceof Array) {
        this.rstack.push(this.rstack[this.rstack.length - 1].shift());
      }
      return r;
    };
    TJSONProtocol.prototype.readStructEnd = function() {
      this.rstack.pop();
    };
    TJSONProtocol.prototype.readFieldBegin = function() {
      var r = {};
      var fid = -1;
      var ftype = Type.STOP;
      for (var f in this.rstack[this.rstack.length - 1]) {
        if (f === null) {
          continue;
        }
        fid = parseInt(f, 10);
        this.rpos.push(this.rstack.length);
        var field = this.rstack[this.rstack.length - 1][fid];
        delete this.rstack[this.rstack.length - 1][fid];
        this.rstack.push(field);
        break;
      }
      if (fid != -1) {
        for (var i in this.rstack[this.rstack.length - 1]) {
          if (TJSONProtocol.RType[i] === null) {
            continue;
          }
          ftype = TJSONProtocol.RType[i];
          this.rstack[this.rstack.length - 1] = this.rstack[this.rstack.length - 1][i];
        }
      }
      r.fname = "";
      r.ftype = ftype;
      r.fid = fid;
      return r;
    };
    TJSONProtocol.prototype.readFieldEnd = function() {
      var pos = this.rpos.pop();
      while (this.rstack.length > pos) {
        this.rstack.pop();
      }
    };
    TJSONProtocol.prototype.readMapBegin = function() {
      var map = this.rstack.pop();
      var first = map.shift();
      if (first instanceof Array) {
        this.rstack.push(map);
        map = first;
        first = map.shift();
      }
      var r = {};
      r.ktype = TJSONProtocol.RType[first];
      r.vtype = TJSONProtocol.RType[map.shift()];
      r.size = map.shift();
      this.rpos.push(this.rstack.length);
      this.rstack.push(map.shift());
      return r;
    };
    TJSONProtocol.prototype.readMapEnd = function() {
      this.readFieldEnd();
    };
    TJSONProtocol.prototype.readListBegin = function() {
      var list = this.rstack[this.rstack.length - 1];
      var r = {};
      r.etype = TJSONProtocol.RType[list.shift()];
      r.size = list.shift();
      this.rpos.push(this.rstack.length);
      this.rstack.push(list.shift());
      return r;
    };
    TJSONProtocol.prototype.readListEnd = function() {
      var pos = this.rpos.pop() - 2;
      var st = this.rstack;
      st.pop();
      if (st instanceof Array && st.length > pos && st[pos].length > 0) {
        st.push(st[pos].shift());
      }
    };
    TJSONProtocol.prototype.readSetBegin = function() {
      return this.readListBegin();
    };
    TJSONProtocol.prototype.readSetEnd = function() {
      return this.readListEnd();
    };
    TJSONProtocol.prototype.readBool = function() {
      return this.readValue() == "1";
    };
    TJSONProtocol.prototype.readByte = function() {
      return this.readI32();
    };
    TJSONProtocol.prototype.readI16 = function() {
      return this.readI32();
    };
    TJSONProtocol.prototype.readI32 = function(f) {
      return +this.readValue();
    };
    TJSONProtocol.prototype.readValue = function(f) {
      if (f === void 0) {
        f = this.rstack[this.rstack.length - 1];
      }
      var r = {};
      if (f instanceof Array) {
        if (f.length === 0) {
          r.value = void 0;
        } else {
          r.value = f.shift();
        }
      } else if (!(f instanceof Int64) && f instanceof Object) {
        for (var i in f) {
          if (i === null) {
            continue;
          }
          this.rstack.push(f[i]);
          delete f[i];
          r.value = i;
          break;
        }
      } else {
        r.value = f;
        this.rstack.pop();
      }
      return r.value;
    };
    TJSONProtocol.prototype.readI64 = function() {
      var n = this.readValue();
      if (typeof n === "string") {
        return Int64Util.fromDecimalString(n);
      } else {
        return new Int64(n);
      }
    };
    TJSONProtocol.prototype.readDouble = function() {
      return this.readI32();
    };
    TJSONProtocol.prototype.readBinary = function() {
      return new Buffer(this.readValue(), "base64");
    };
    TJSONProtocol.prototype.readString = function() {
      return this.readValue();
    };
    TJSONProtocol.prototype.getTransport = function() {
      return this.trans;
    };
    TJSONProtocol.prototype.skip = function(type) {
      switch (type) {
        case Type.BOOL:
          this.readBool();
          break;
        case Type.BYTE:
          this.readByte();
          break;
        case Type.I16:
          this.readI16();
          break;
        case Type.I32:
          this.readI32();
          break;
        case Type.I64:
          this.readI64();
          break;
        case Type.DOUBLE:
          this.readDouble();
          break;
        case Type.STRING:
          this.readString();
          break;
        case Type.STRUCT:
          this.readStructBegin();
          while (true) {
            var r = this.readFieldBegin();
            if (r.ftype === Type.STOP) {
              break;
            }
            this.skip(r.ftype);
            this.readFieldEnd();
          }
          this.readStructEnd();
          break;
        case Type.MAP:
          var mapBegin = this.readMapBegin();
          for (var i = 0; i < mapBegin.size; ++i) {
            this.skip(mapBegin.ktype);
            this.skip(mapBegin.vtype);
          }
          this.readMapEnd();
          break;
        case Type.SET:
          var setBegin = this.readSetBegin();
          for (var i2 = 0; i2 < setBegin.size; ++i2) {
            this.skip(setBegin.etype);
          }
          this.readSetEnd();
          break;
        case Type.LIST:
          var listBegin = this.readListBegin();
          for (var i3 = 0; i3 < listBegin.size; ++i3) {
            this.skip(listBegin.etype);
          }
          this.readListEnd();
          break;
        default:
          throw new Error("Invalid type: " + type);
      }
    };
  }
});

// node_modules/browser-or-node/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/browser-or-node/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
      return typeof obj;
    } : function(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
    var isWebWorker = (typeof self === "undefined" ? "undefined" : _typeof(self)) === "object" && self.constructor && self.constructor.name === "DedicatedWorkerGlobalScope";
    var isNode = typeof process !== "undefined" && process.versions != null && process.versions.node != null;
    var isJsDom = function isJsDom2() {
      return typeof window !== "undefined" && window.name === "nodejs" || navigator.userAgent.includes("Node.js") || navigator.userAgent.includes("jsdom");
    };
    exports.isBrowser = isBrowser;
    exports.isWebWorker = isWebWorker;
    exports.isNode = isNode;
    exports.isJsDom = isJsDom;
  }
});

// node_modules/thrift/lib/nodejs/lib/thrift/ws_connection.js
var require_ws_connection = __commonJS({
  "node_modules/thrift/lib/nodejs/lib/thrift/ws_connection.js"(exports) {
    var util = require("util");
    var WebSocket = require_node2();
    var EventEmitter = require("events").EventEmitter;
    var thrift = require_thrift();
    var TBufferedTransport = require_buffered_transport();
    var TJSONProtocol = require_json_protocol();
    var InputBufferUnderrunError = require_input_buffer_underrun_error();
    var createClient = require_create_client();
    var jsEnv = require_lib2();
    exports.WSConnection = WSConnection;
    function WSConnection(host, port, options) {
      EventEmitter.call(this);
      this.options = options || {};
      this.host = host;
      this.port = port;
      this.secure = this.options.secure || false;
      this.transport = this.options.transport || TBufferedTransport;
      this.protocol = this.options.protocol || TJSONProtocol;
      this.path = this.options.path;
      this.send_pending = [];
      this.seqId2Service = {};
      this.wsOptions = {
        host: this.host,
        port: this.port || 80,
        path: this.options.path || "/",
        headers: this.options.headers || {}
      };
      for (var attrname in this.options.wsOptions) {
        this.wsOptions[attrname] = this.options.wsOptions[attrname];
      }
    }
    util.inherits(WSConnection, EventEmitter);
    WSConnection.prototype.__reset = function() {
      this.socket = null;
      this.send_pending = [];
    };
    WSConnection.prototype.__onOpen = function() {
      this.emit("open");
      if (this.send_pending.length > 0) {
        this.send_pending.forEach(function(data) {
          this.socket.send(data);
        }, this);
        this.send_pending = [];
      }
    };
    WSConnection.prototype.__onClose = function(evt) {
      this.emit("close");
      this.__reset();
    };
    WSConnection.prototype.__decodeCallback = function(transport_with_data) {
      var proto = new this.protocol(transport_with_data);
      try {
        while (true) {
          var header = proto.readMessageBegin();
          var dummy_seqid = header.rseqid * -1;
          var client = this.client;
          var service_name = this.seqId2Service[header.rseqid];
          if (service_name) {
            client = this.client[service_name];
            delete this.seqId2Service[header.rseqid];
          }
          client._reqs[dummy_seqid] = function(err, success) {
            transport_with_data.commitPosition();
            var clientCallback = client._reqs[header.rseqid];
            delete client._reqs[header.rseqid];
            if (clientCallback) {
              clientCallback(err, success);
            }
          };
          if (client["recv_" + header.fname]) {
            client["recv_" + header.fname](proto, header.mtype, dummy_seqid);
          } else {
            delete client._reqs[dummy_seqid];
            this.emit(
              "error",
              new thrift.TApplicationException(
                thrift.TApplicationExceptionType.WRONG_METHOD_NAME,
                "Received a response to an unknown RPC function"
              )
            );
          }
        }
      } catch (e) {
        if (e instanceof InputBufferUnderrunError) {
          transport_with_data.rollbackPosition();
        } else {
          throw e;
        }
      }
    };
    WSConnection.prototype.__onData = function(data) {
      if (Object.prototype.toString.call(data) === "[object ArrayBuffer]") {
        data = new Uint8Array(data);
      }
      var buf = new Buffer(data);
      this.transport.receiver(this.__decodeCallback.bind(this))(buf);
    };
    WSConnection.prototype.__onMessage = function(evt) {
      this.__onData(evt.data);
    };
    WSConnection.prototype.__onError = function(evt) {
      this.emit("error", evt);
      this.socket.close();
    };
    WSConnection.prototype.isOpen = function() {
      return this.socket && this.socket.readyState === this.socket.OPEN;
    };
    WSConnection.prototype.open = function() {
      if (this.socket && this.socket.readyState !== this.socket.CLOSED) {
        return;
      }
      if (jsEnv.isBrowser) {
        this.socket = new WebSocket(this.uri());
      } else {
        this.socket = new WebSocket(this.uri(), "", this.wsOptions);
      }
      this.socket.binaryType = "arraybuffer";
      this.socket.onopen = this.__onOpen.bind(this);
      this.socket.onmessage = this.__onMessage.bind(this);
      this.socket.onerror = this.__onError.bind(this);
      this.socket.onclose = this.__onClose.bind(this);
    };
    WSConnection.prototype.close = function() {
      this.socket.close();
    };
    WSConnection.prototype.uri = function() {
      var schema = this.secure ? "wss" : "ws";
      var port = "";
      var path = this.path || "/";
      var host = this.host;
      if (this.port && ("wss" === schema && this.port !== 443 || "ws" === schema && this.port !== 80)) {
        port = ":" + this.port;
      }
      return schema + "://" + host + port + path;
    };
    WSConnection.prototype.write = function(data) {
      if (this.isOpen()) {
        this.socket.send(data);
      } else {
        this.send_pending.push(data);
      }
    };
    exports.createWSConnection = function(host, port, options) {
      return new WSConnection(host, port, options);
    };
    exports.createWSClient = createClient;
  }
});

// node_modules/thrift/lib/nodejs/lib/thrift/xhr_connection.js
var require_xhr_connection = __commonJS({
  "node_modules/thrift/lib/nodejs/lib/thrift/xhr_connection.js"(exports) {
    var util = require("util");
    var EventEmitter = require("events").EventEmitter;
    var thrift = require_thrift();
    var TBufferedTransport = require_buffered_transport();
    var TJSONProtocol = require_json_protocol();
    var InputBufferUnderrunError = require_input_buffer_underrun_error();
    var createClient = require_create_client();
    exports.XHRConnection = XHRConnection;
    function XHRConnection(host, port, options) {
      this.options = options || {};
      this.wpos = 0;
      this.rpos = 0;
      this.useCORS = options && options.useCORS;
      this.send_buf = "";
      this.recv_buf = "";
      this.transport = options.transport || TBufferedTransport;
      this.protocol = options.protocol || TJSONProtocol;
      this.headers = options.headers || {};
      host = host || window.location.host;
      port = port || window.location.port;
      var prefix = options.https ? "https://" : "http://";
      var path = options.path || "/";
      if (port === "") {
        port = void 0;
      }
      if (!port || port === 80 || port === "80") {
        this.url = prefix + host + path;
      } else {
        this.url = prefix + host + ":" + port + path;
      }
      this.seqId2Service = {};
    }
    util.inherits(XHRConnection, EventEmitter);
    XHRConnection.prototype.getXmlHttpRequestObject = function() {
      try {
        return new XMLHttpRequest();
      } catch (e1) {
      }
      try {
        return new ActiveXObject("Msxml2.XMLHTTP");
      } catch (e2) {
      }
      try {
        return new ActiveXObject("Microsoft.XMLHTTP");
      } catch (e3) {
      }
      throw "Your browser doesn't support XHR.";
    };
    XHRConnection.prototype.flush = function() {
      var self2 = this;
      if (this.url === void 0 || this.url === "") {
        return this.send_buf;
      }
      var xreq = this.getXmlHttpRequestObject();
      if (xreq.overrideMimeType) {
        xreq.overrideMimeType("application/json");
      }
      xreq.onreadystatechange = function() {
        if (this.readyState == 4 && this.status == 200) {
          self2.setRecvBuffer(this.responseText);
        }
      };
      xreq.open("POST", this.url, true);
      Object.keys(this.headers).forEach(function(headerKey) {
        xreq.setRequestHeader(headerKey, self2.headers[headerKey]);
      });
      xreq.send(this.send_buf);
    };
    XHRConnection.prototype.setRecvBuffer = function(buf) {
      this.recv_buf = buf;
      this.recv_buf_sz = this.recv_buf.length;
      this.wpos = this.recv_buf.length;
      this.rpos = 0;
      if (Object.prototype.toString.call(buf) == "[object ArrayBuffer]") {
        var data = new Uint8Array(buf);
      }
      var thing = new Buffer(data || buf);
      this.transport.receiver(this.__decodeCallback.bind(this))(thing);
    };
    XHRConnection.prototype.__decodeCallback = function(transport_with_data) {
      var proto = new this.protocol(transport_with_data);
      try {
        while (true) {
          var header = proto.readMessageBegin();
          var dummy_seqid = header.rseqid * -1;
          var client = this.client;
          var service_name = this.seqId2Service[header.rseqid];
          if (service_name) {
            client = this.client[service_name];
            delete this.seqId2Service[header.rseqid];
          }
          client._reqs[dummy_seqid] = function(err, success) {
            transport_with_data.commitPosition();
            var clientCallback = client._reqs[header.rseqid];
            delete client._reqs[header.rseqid];
            if (clientCallback) {
              clientCallback(err, success);
            }
          };
          if (client["recv_" + header.fname]) {
            client["recv_" + header.fname](proto, header.mtype, dummy_seqid);
          } else {
            delete client._reqs[dummy_seqid];
            this.emit(
              "error",
              new thrift.TApplicationException(
                thrift.TApplicationExceptionType.WRONG_METHOD_NAME,
                "Received a response to an unknown RPC function"
              )
            );
          }
        }
      } catch (e) {
        if (e instanceof InputBufferUnderrunError) {
          transport_with_data.rollbackPosition();
        } else {
          throw e;
        }
      }
    };
    XHRConnection.prototype.isOpen = function() {
      return true;
    };
    XHRConnection.prototype.open = function() {
    };
    XHRConnection.prototype.close = function() {
    };
    XHRConnection.prototype.read = function(len) {
      var avail = this.wpos - this.rpos;
      if (avail === 0) {
        return "";
      }
      var give = len;
      if (avail < len) {
        give = avail;
      }
      var ret = this.read_buf.substr(this.rpos, give);
      this.rpos += give;
      return ret;
    };
    XHRConnection.prototype.readAll = function() {
      return this.recv_buf;
    };
    XHRConnection.prototype.write = function(buf) {
      this.send_buf = buf;
      this.flush();
    };
    XHRConnection.prototype.getSendBuffer = function() {
      return this.send_buf;
    };
    exports.createXHRConnection = function(host, port, options) {
      return new XHRConnection(host, port, options);
    };
    exports.createXHRClient = createClient;
  }
});

// node_modules/thrift/lib/nodejs/lib/thrift/header_protocol.js
var require_header_protocol = __commonJS({
  "node_modules/thrift/lib/nodejs/lib/thrift/header_protocol.js"(exports, module2) {
    var util = require("util");
    var TBinaryProtocol = require_binary_protocol();
    var TCompactProtocol = require_compact_protocol();
    var THeaderTransport = require_header_transport();
    var ProtocolMap = {};
    ProtocolMap[THeaderTransport.SubprotocolId.BINARY] = TBinaryProtocol;
    ProtocolMap[THeaderTransport.SubprotocolId.COMPACT] = TCompactProtocol;
    module2.exports = THeaderProtocol;
    function THeaderProtocolError(message) {
      Error.call(this);
      if (Error.captureStackTrace !== void 0) {
        Error.captureStackTrace(this, this.constructor);
      }
      this.name = this.constructor.name;
      this.message = message;
    }
    util.inherits(THeaderProtocolError, Error);
    function THeaderProtocol(trans) {
      if (!(trans instanceof THeaderTransport)) {
        throw new THeaderProtocolError(
          "Only transports that inherit THeaderTransport can be used with THeaderProtocol"
        );
      }
      this.trans = trans;
      this.setProtocol();
    }
    THeaderProtocol.prototype.flush = function() {
      this.trans.writeHeaders();
      return this.trans.flush();
    };
    THeaderProtocol.prototype.writeMessageBegin = function(name, type, seqid) {
      return this.protocol.writeMessageBegin(name, type, seqid);
    };
    THeaderProtocol.prototype.writeMessageEnd = function() {
      return this.protocol.writeMessageEnd();
    };
    THeaderProtocol.prototype.writeStructBegin = function(name) {
      return this.protocol.writeStructBegin(name);
    };
    THeaderProtocol.prototype.writeStructEnd = function() {
      return this.protocol.writeStructEnd();
    };
    THeaderProtocol.prototype.writeFieldBegin = function(name, type, id) {
      return this.protocol.writeFieldBegin(name, type, id);
    };
    THeaderProtocol.prototype.writeFieldEnd = function() {
      return this.protocol.writeFieldEnd();
    };
    THeaderProtocol.prototype.writeFieldStop = function() {
      return this.protocol.writeFieldStop();
    };
    THeaderProtocol.prototype.writeMapBegin = function(ktype, vtype, size) {
      return this.protocol.writeMapBegin(ktype, vtype, size);
    };
    THeaderProtocol.prototype.writeMapEnd = function() {
      return this.protocol.writeMapEnd();
    };
    THeaderProtocol.prototype.writeListBegin = function(etype, size) {
      return this.protocol.writeListBegin(etype, size);
    };
    THeaderProtocol.prototype.writeListEnd = function() {
      return this.protocol.writeListEnd();
    };
    THeaderProtocol.prototype.writeSetBegin = function(etype, size) {
      return this.protocol.writeSetBegin(etype, size);
    };
    THeaderProtocol.prototype.writeSetEnd = function() {
      return this.protocol.writeSetEnd();
    };
    THeaderProtocol.prototype.writeBool = function(b) {
      return this.protocol.writeBool(b);
    };
    THeaderProtocol.prototype.writeByte = function(b) {
      return this.protocol.writeByte(b);
    };
    THeaderProtocol.prototype.writeI16 = function(i16) {
      return this.protocol.writeI16(i16);
    };
    THeaderProtocol.prototype.writeI32 = function(i32) {
      return this.protocol.writeI32(i32);
    };
    THeaderProtocol.prototype.writeI64 = function(i64) {
      return this.protocol.writeI64(i64);
    };
    THeaderProtocol.prototype.writeDouble = function(dub) {
      return this.protocol.writeDouble(dub);
    };
    THeaderProtocol.prototype.writeStringOrBinary = function(name, encoding, arg) {
      return this.protocol.writeStringOrBinary(name, encoding, arg);
    };
    THeaderProtocol.prototype.writeString = function(arg) {
      return this.protocol.writeString(arg);
    };
    THeaderProtocol.prototype.writeBinary = function(arg) {
      return this.protocol.writeBinary(arg);
    };
    THeaderProtocol.prototype.readMessageBegin = function() {
      this.trans.readHeaders();
      this.setProtocol();
      return this.protocol.readMessageBegin();
    };
    THeaderProtocol.prototype.readMessageEnd = function() {
      return this.protocol.readMessageEnd();
    };
    THeaderProtocol.prototype.readStructBegin = function() {
      return this.protocol.readStructBegin();
    };
    THeaderProtocol.prototype.readStructEnd = function() {
      return this.protocol.readStructEnd();
    };
    THeaderProtocol.prototype.readFieldBegin = function() {
      return this.protocol.readFieldBegin();
    };
    THeaderProtocol.prototype.readFieldEnd = function() {
      return this.protocol.readFieldEnd();
    };
    THeaderProtocol.prototype.readMapBegin = function() {
      return this.protocol.readMapBegin();
    };
    THeaderProtocol.prototype.readMapEnd = function() {
      return this.protocol.readMapEnd();
    };
    THeaderProtocol.prototype.readListBegin = function() {
      return this.protocol.readListBegin();
    };
    THeaderProtocol.prototype.readListEnd = function() {
      return this.protocol.readListEnd();
    };
    THeaderProtocol.prototype.readSetBegin = function() {
      return this.protocol.readSetBegin();
    };
    THeaderProtocol.prototype.readSetEnd = function() {
      return this.protocol.readSetEnd();
    };
    THeaderProtocol.prototype.readBool = function() {
      return this.protocol.readBool();
    };
    THeaderProtocol.prototype.readByte = function() {
      return this.protocol.readByte();
    };
    THeaderProtocol.prototype.readI16 = function() {
      return this.protocol.readI16();
    };
    THeaderProtocol.prototype.readI32 = function() {
      return this.protocol.readI32();
    };
    THeaderProtocol.prototype.readI64 = function() {
      return this.protocol.readI64();
    };
    THeaderProtocol.prototype.readDouble = function() {
      return this.protocol.readDouble();
    };
    THeaderProtocol.prototype.readBinary = function() {
      return this.protocol.readBinary();
    };
    THeaderProtocol.prototype.readString = function() {
      return this.protocol.readString();
    };
    THeaderProtocol.prototype.getTransport = function() {
      return this.trans;
    };
    THeaderProtocol.prototype.skip = function(type) {
      return this.protocol.skip(type);
    };
    THeaderProtocol.prototype.setProtocol = function(subProtocolId) {
      var subProtocolId = this.trans.getProtocolId();
      if (!ProtocolMap[subProtocolId]) {
        throw new THeaderProtocolError("Headers not supported for protocol " + subProtocolId);
      }
      this.protocol = new ProtocolMap[subProtocolId](this.trans);
    };
  }
});

// node_modules/thrift/lib/nodejs/lib/thrift/server.js
var require_server = __commonJS({
  "node_modules/thrift/lib/nodejs/lib/thrift/server.js"(exports) {
    var constants = require("constants");
    var net = require("net");
    var tls = require("tls");
    var TBufferedTransport = require_buffered_transport();
    var TBinaryProtocol = require_binary_protocol();
    var THeaderProtocol = require_header_protocol();
    var InputBufferUnderrunError = require_input_buffer_underrun_error();
    exports.createMultiplexServer = function(processor, options) {
      var transport = options && options.transport ? options.transport : TBufferedTransport;
      var protocol = options && options.protocol ? options.protocol : TBinaryProtocol;
      function serverImpl(stream) {
        var self2 = this;
        stream.on("error", function(err) {
          self2.emit("error", err);
        });
        stream.on("data", transport.receiver(function(transportWithData) {
          var input = new protocol(transportWithData);
          var outputCb = function(buf) {
            try {
              stream.write(buf);
            } catch (err) {
              self2.emit("error", err);
              stream.end();
            }
          };
          var output = new protocol(new transport(void 0, outputCb));
          if (protocol === THeaderProtocol) {
            output = input;
            output.trans.onFlush = outputCb;
          }
          try {
            do {
              processor.process(input, output);
              transportWithData.commitPosition();
            } while (true);
          } catch (err) {
            if (err instanceof InputBufferUnderrunError) {
              transportWithData.rollbackPosition();
            } else if (err.message === "Invalid type: undefined") {
              transportWithData.rollbackPosition();
            } else {
              self2.emit("error", err);
              stream.end();
            }
          }
        }));
        stream.on("end", function() {
          stream.end();
        });
      }
      if (options && options.tls) {
        if (!("secureProtocol" in options.tls) && !("secureOptions" in options.tls)) {
          options.tls.secureProtocol = "SSLv23_method";
          options.tls.secureOptions = constants.SSL_OP_NO_SSLv2 | constants.SSL_OP_NO_SSLv3;
        }
        return tls.createServer(options.tls, serverImpl);
      } else {
        return net.createServer(serverImpl);
      }
    };
    exports.createServer = function(processor, handler, options) {
      if (processor.Processor) {
        processor = processor.Processor;
      }
      return exports.createMultiplexServer(new processor(handler), options);
    };
  }
});

// node_modules/thrift/lib/nodejs/lib/thrift/multiplexed_processor.js
var require_multiplexed_processor = __commonJS({
  "node_modules/thrift/lib/nodejs/lib/thrift/multiplexed_processor.js"(exports) {
    var Thrift = require_thrift();
    exports.MultiplexedProcessor = MultiplexedProcessor;
    function MultiplexedProcessor(stream, options) {
      this.services = {};
    }
    MultiplexedProcessor.prototype.registerProcessor = function(name, handler) {
      this.services[name] = handler;
    };
    MultiplexedProcessor.prototype.process = function(inp, out) {
      var begin = inp.readMessageBegin();
      if (begin.mtype != Thrift.MessageType.CALL && begin.mtype != Thrift.MessageType.ONEWAY) {
        throw new Thrift.TException("TMultiplexedProcessor: Unexpected message type");
      }
      var p = begin.fname.split(":");
      var sname = p[0];
      var fname = p[1];
      if (!(sname in this.services)) {
        throw new Thrift.TException("TMultiplexedProcessor: Unknown service: " + sname);
      }
      var inpProxy = {};
      for (var attr in inp) {
        inpProxy[attr] = inp[attr];
      }
      inpProxy.readMessageBegin = function() {
        return {
          fname,
          mtype: begin.mtype,
          rseqid: begin.rseqid
        };
      };
      this.services[sname].process(inpProxy, out);
    };
  }
});

// node_modules/thrift/lib/nodejs/lib/thrift/web_server.js
var require_web_server = __commonJS({
  "node_modules/thrift/lib/nodejs/lib/thrift/web_server.js"(exports) {
    var http = require("http");
    var https = require("https");
    var url = require("url");
    var path = require("path");
    var fs = require("fs");
    var crypto = require("crypto");
    var log = require_log();
    var MultiplexedProcessor = require_multiplexed_processor().MultiplexedProcessor;
    var TBufferedTransport = require_buffered_transport();
    var TBinaryProtocol = require_binary_protocol();
    var InputBufferUnderrunError = require_input_buffer_underrun_error();
    var wsFrame = {
      encode: function(data, mask, binEncoding) {
        var frame = new Buffer(wsFrame.frameSizeFromData(data, mask));
        frame[0] = wsFrame.fin.FIN + (binEncoding ? wsFrame.frameOpCodes.BIN : wsFrame.frameOpCodes.TEXT);
        var payloadOffset = 2;
        if (data.length < 126) {
          frame[1] = data.length + (mask ? wsFrame.mask.TO_SERVER : wsFrame.mask.TO_CLIENT);
        } else if (data.length < 65535) {
          frame[1] = 126 + (mask ? wsFrame.mask.TO_SERVER : wsFrame.mask.TO_CLIENT);
          frame.writeUInt16BE(data.length, 2, true);
          payloadOffset = 4;
        } else {
          frame[1] = 127 + (mask ? wsFrame.mask.TO_SERVER : wsFrame.mask.TO_CLIENT);
          frame.writeUInt32BE(0, 2, true);
          frame.writeUInt32BE(data.length, 6, true);
          payloadOffset = 10;
        }
        if (mask) {
          mask.copy(frame, payloadOffset, 0, 4);
          payloadOffset += 4;
        }
        data.copy(frame, payloadOffset);
        if (mask) {
          wsFrame.applyMask(frame.slice(payloadOffset), frame.slice(payloadOffset - 4, payloadOffset));
        }
        return frame;
      },
      decode: function(frame) {
        var result = {
          data: null,
          mask: null,
          binEncoding: false,
          nextFrame: null,
          FIN: true
        };
        if (wsFrame.fin.FIN != (frame[0] & wsFrame.fin.FIN)) {
          result.FIN = false;
        }
        result.binEncoding = wsFrame.frameOpCodes.BIN == (frame[0] & wsFrame.frameOpCodes.BIN);
        var lenByte = frame[1] & 127;
        var len = lenByte;
        var dataOffset = 2;
        if (lenByte == 126) {
          len = frame.readUInt16BE(2);
          dataOffset = 4;
        } else if (lenByte == 127) {
          len = frame.readUInt32BE(6);
          dataOffset = 10;
        }
        if (wsFrame.mask.TO_SERVER == (frame[1] & wsFrame.mask.TO_SERVER)) {
          result.mask = new Buffer(4);
          frame.copy(result.mask, 0, dataOffset, dataOffset + 4);
          dataOffset += 4;
        }
        result.data = new Buffer(len);
        frame.copy(result.data, 0, dataOffset, dataOffset + len);
        if (result.mask) {
          wsFrame.applyMask(result.data, result.mask);
        }
        if (frame.length > dataOffset + len) {
          result.nextFrame = new Buffer(frame.length - (dataOffset + len));
          frame.copy(result.nextFrame, 0, dataOffset + len, frame.length);
        }
        if (frame[0] & wsFrame.frameOpCodes.FINCTRL) {
          result.data = null;
        }
        return result;
      },
      applyMask: function(data, mask) {
        var dataLen = data.length;
        var maskLen = mask.length;
        for (var i = 0; i < dataLen; i++) {
          data[i] = data[i] ^ mask[i % maskLen];
        }
      },
      frameSizeFromData: function(data, mask) {
        var headerSize = 10;
        if (data.length < 126) {
          headerSize = 2;
        } else if (data.length < 65535) {
          headerSize = 4;
        }
        return headerSize + data.length + (mask ? 4 : 0);
      },
      frameOpCodes: {
        CONT: 0,
        TEXT: 1,
        BIN: 2,
        CTRL: 128
      },
      mask: {
        TO_SERVER: 128,
        TO_CLIENT: 0
      },
      fin: {
        CONT: 0,
        FIN: 128
      }
    };
    exports.createWebServer = function(options) {
      var baseDir = options.files;
      var contentTypesByExtension = {
        ".txt": "text/plain",
        ".html": "text/html",
        ".css": "text/css",
        ".xml": "application/xml",
        ".json": "application/json",
        ".js": "application/javascript",
        ".jpg": "image/jpeg",
        ".jpeg": "image/jpeg",
        ".gif": "image/gif",
        ".png": "image/png",
        ".svg": "image/svg+xml"
      };
      var services = options.services;
      for (var uri in services) {
        var svcObj = services[uri];
        if (svcObj.processor instanceof MultiplexedProcessor) {
          svcObj.processor = svcObj.processor;
        } else {
          var processor = svcObj.processor ? svcObj.processor.Processor || svcObj.processor : svcObj.cls.Processor || svcObj.cls;
          if (svcObj.handler) {
            svcObj.processor = new processor(svcObj.handler);
          } else {
            svcObj.processor = processor;
          }
        }
        svcObj.transport = svcObj.transport ? svcObj.transport : TBufferedTransport;
        svcObj.protocol = svcObj.protocol ? svcObj.protocol : TBinaryProtocol;
      }
      function VerifyCORSAndSetHeaders(request, response) {
        if (request.headers.origin && options.cors) {
          if (options.cors["*"] || options.cors[request.headers.origin]) {
            response.setHeader("access-control-allow-origin", request.headers.origin);
            response.setHeader("access-control-allow-methods", "GET, POST, OPTIONS");
            response.setHeader("access-control-allow-headers", "content-type, accept");
            response.setHeader("access-control-max-age", "60");
            return true;
          } else {
            return false;
          }
        }
        return true;
      }
      function processOptions(request, response) {
        if (VerifyCORSAndSetHeaders(request, response)) {
          response.writeHead("204", "No Content", { "content-length": 0 });
        } else {
          response.writeHead("403", "Origin " + request.headers.origin + " not allowed", {});
        }
        response.end();
      }
      function processPost(request, response) {
        var uri2 = url.parse(request.url).pathname;
        var svc = services[uri2];
        if (!svc) {
          response.writeHead("403", "No Apache Thrift Service at " + uri2, {});
          response.end();
          return;
        }
        if (!VerifyCORSAndSetHeaders(request, response)) {
          response.writeHead("403", "Origin " + request.headers.origin + " not allowed", {});
          response.end();
          return;
        }
        request.on("data", svc.transport.receiver(function(transportWithData) {
          var input = new svc.protocol(transportWithData);
          var output = new svc.protocol(new svc.transport(void 0, function(buf) {
            try {
              response.writeHead(200);
              response.end(buf);
            } catch (err) {
              response.writeHead(500);
              response.end();
            }
          }));
          try {
            svc.processor.process(input, output);
            transportWithData.commitPosition();
          } catch (err) {
            if (err instanceof InputBufferUnderrunError) {
              transportWithData.rollbackPosition();
            } else {
              response.writeHead(500);
              response.end();
            }
          }
        }));
      }
      function processGet(request, response) {
        if (!baseDir || "" === baseDir) {
          response.writeHead(404);
          response.end();
          return;
        }
        if (!VerifyCORSAndSetHeaders(request, response)) {
          response.writeHead("403", "Origin " + request.headers.origin + " not allowed", {});
          response.end();
          return;
        }
        var uri2 = url.parse(request.url).pathname;
        var filename = path.resolve(path.join(baseDir, uri2));
        if (filename.indexOf(baseDir) != 0) {
          response.writeHead(400, "Invalid request path", {});
          response.end();
          return;
        }
        fs.exists(filename, function(exists) {
          if (!exists) {
            response.writeHead(404);
            response.end();
            return;
          }
          if (fs.statSync(filename).isDirectory()) {
            filename += "/index.html";
          }
          fs.readFile(filename, "binary", function(err, file) {
            if (err) {
              response.writeHead(500);
              response.end(err + "\n");
              return;
            }
            var headers = {};
            var contentType = contentTypesByExtension[path.extname(filename)];
            if (contentType) {
              headers["Content-Type"] = contentType;
            }
            for (var k in options.headers) {
              headers[k] = options.headers[k];
            }
            response.writeHead(200, headers);
            response.write(file, "binary");
            response.end();
          });
        });
      }
      function processWS(data, socket, svc, binEncoding) {
        svc.transport.receiver(function(transportWithData) {
          var input = new svc.protocol(transportWithData);
          var output = new svc.protocol(new svc.transport(void 0, function(buf) {
            try {
              var frame = wsFrame.encode(buf, null, binEncoding);
              socket.write(frame);
            } catch (err) {
            }
          }));
          try {
            svc.processor.process(input, output);
            transportWithData.commitPosition();
          } catch (err) {
            if (err instanceof InputBufferUnderrunError) {
              transportWithData.rollbackPosition();
            } else {
            }
          }
        })(data);
      }
      var server = null;
      if (options.tls) {
        server = https.createServer(options.tls);
      } else {
        server = http.createServer();
      }
      server.on("request", function(request, response) {
        if (request.method === "POST") {
          processPost(request, response);
        } else if (request.method === "GET") {
          processGet(request, response);
        } else if (request.method === "OPTIONS") {
          processOptions(request, response);
        } else {
          response.writeHead(500);
          response.end();
        }
      }).on("upgrade", function(request, socket, head) {
        var svc;
        try {
          svc = services[Object.keys(services)[0]];
        } catch (e) {
          socket.write("HTTP/1.1 403 No Apache Thrift Service available\r\n\r\n");
          return;
        }
        var hash = crypto.createHash("sha1");
        hash.update(request.headers["sec-websocket-key"] + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11");
        socket.write("HTTP/1.1 101 Switching Protocols\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nSec-WebSocket-Accept: " + hash.digest("base64") + "\r\nSec-WebSocket-Origin: " + request.headers.origin + "\r\nSec-WebSocket-Location: ws://" + request.headers.host + request.url + "\r\n\r\n");
        var data = null;
        socket.on("data", function(frame) {
          try {
            while (frame) {
              var result = wsFrame.decode(frame);
              if (data) {
                if (result.data) {
                  var newData = new Buffer(data.length + result.data.length);
                  data.copy(newData);
                  result.data.copy(newData, data.length);
                  result.data = newData;
                } else {
                  result.data = data;
                }
                data = null;
              }
              if (result.FIN) {
                processWS(result.data, socket, svc, result.binEncoding);
              } else {
                data = result.data;
              }
              frame = result.nextFrame;
            }
          } catch (e) {
            log.error("TWebSocketTransport Exception: " + e);
            socket.destroy();
          }
        });
      });
      return server;
    };
  }
});

// node_modules/q/q.js
var require_q = __commonJS({
  "node_modules/q/q.js"(exports, module2) {
    (function(definition) {
      "use strict";
      if (typeof bootstrap === "function") {
        bootstrap("promise", definition);
      } else if (typeof exports === "object" && typeof module2 === "object") {
        module2.exports = definition();
      } else if (typeof define === "function" && define.amd) {
        define(definition);
      } else if (typeof ses !== "undefined") {
        if (!ses.ok()) {
          return;
        } else {
          ses.makeQ = definition;
        }
      } else if (typeof window !== "undefined" || typeof self !== "undefined") {
        var global = typeof window !== "undefined" ? window : self;
        var previousQ = global.Q;
        global.Q = definition();
        global.Q.noConflict = function() {
          global.Q = previousQ;
          return this;
        };
      } else {
        throw new Error("This environment was not anticipated by Q. Please file a bug.");
      }
    })(function() {
      "use strict";
      var hasStacks = false;
      try {
        throw new Error();
      } catch (e) {
        hasStacks = !!e.stack;
      }
      var qStartingLine = captureLine();
      var qFileName;
      var noop = function() {
      };
      var nextTick = function() {
        var head = { task: void 0, next: null };
        var tail = head;
        var flushing = false;
        var requestTick = void 0;
        var isNodeJS = false;
        var laterQueue = [];
        function flush() {
          var task, domain;
          while (head.next) {
            head = head.next;
            task = head.task;
            head.task = void 0;
            domain = head.domain;
            if (domain) {
              head.domain = void 0;
              domain.enter();
            }
            runSingle(task, domain);
          }
          while (laterQueue.length) {
            task = laterQueue.pop();
            runSingle(task);
          }
          flushing = false;
        }
        function runSingle(task, domain) {
          try {
            task();
          } catch (e) {
            if (isNodeJS) {
              if (domain) {
                domain.exit();
              }
              setTimeout(flush, 0);
              if (domain) {
                domain.enter();
              }
              throw e;
            } else {
              setTimeout(function() {
                throw e;
              }, 0);
            }
          }
          if (domain) {
            domain.exit();
          }
        }
        nextTick = function(task) {
          tail = tail.next = {
            task,
            domain: isNodeJS && process.domain,
            next: null
          };
          if (!flushing) {
            flushing = true;
            requestTick();
          }
        };
        if (typeof process === "object" && process.toString() === "[object process]" && process.nextTick) {
          isNodeJS = true;
          requestTick = function() {
            process.nextTick(flush);
          };
        } else if (typeof setImmediate === "function") {
          if (typeof window !== "undefined") {
            requestTick = setImmediate.bind(window, flush);
          } else {
            requestTick = function() {
              setImmediate(flush);
            };
          }
        } else if (typeof MessageChannel !== "undefined") {
          var channel = new MessageChannel();
          channel.port1.onmessage = function() {
            requestTick = requestPortTick;
            channel.port1.onmessage = flush;
            flush();
          };
          var requestPortTick = function() {
            channel.port2.postMessage(0);
          };
          requestTick = function() {
            setTimeout(flush, 0);
            requestPortTick();
          };
        } else {
          requestTick = function() {
            setTimeout(flush, 0);
          };
        }
        nextTick.runAfter = function(task) {
          laterQueue.push(task);
          if (!flushing) {
            flushing = true;
            requestTick();
          }
        };
        return nextTick;
      }();
      var call = Function.call;
      function uncurryThis(f) {
        return function() {
          return call.apply(f, arguments);
        };
      }
      var array_slice = uncurryThis(Array.prototype.slice);
      var array_reduce = uncurryThis(
        Array.prototype.reduce || function(callback, basis) {
          var index = 0, length = this.length;
          if (arguments.length === 1) {
            do {
              if (index in this) {
                basis = this[index++];
                break;
              }
              if (++index >= length) {
                throw new TypeError();
              }
            } while (1);
          }
          for (; index < length; index++) {
            if (index in this) {
              basis = callback(basis, this[index], index);
            }
          }
          return basis;
        }
      );
      var array_indexOf = uncurryThis(
        Array.prototype.indexOf || function(value) {
          for (var i = 0; i < this.length; i++) {
            if (this[i] === value) {
              return i;
            }
          }
          return -1;
        }
      );
      var array_map = uncurryThis(
        Array.prototype.map || function(callback, thisp) {
          var self2 = this;
          var collect = [];
          array_reduce(self2, function(undefined2, value, index) {
            collect.push(callback.call(thisp, value, index, self2));
          }, void 0);
          return collect;
        }
      );
      var object_create = Object.create || function(prototype) {
        function Type() {
        }
        Type.prototype = prototype;
        return new Type();
      };
      var object_defineProperty = Object.defineProperty || function(obj, prop, descriptor) {
        obj[prop] = descriptor.value;
        return obj;
      };
      var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
      var object_keys = Object.keys || function(object) {
        var keys = [];
        for (var key in object) {
          if (object_hasOwnProperty(object, key)) {
            keys.push(key);
          }
        }
        return keys;
      };
      var object_toString = uncurryThis(Object.prototype.toString);
      function isObject(value) {
        return value === Object(value);
      }
      function isStopIteration(exception) {
        return object_toString(exception) === "[object StopIteration]" || exception instanceof QReturnValue;
      }
      var QReturnValue;
      if (typeof ReturnValue !== "undefined") {
        QReturnValue = ReturnValue;
      } else {
        QReturnValue = function(value) {
          this.value = value;
        };
      }
      var STACK_JUMP_SEPARATOR = "From previous event:";
      function makeStackTraceLong(error, promise2) {
        if (hasStacks && promise2.stack && typeof error === "object" && error !== null && error.stack) {
          var stacks = [];
          for (var p = promise2; !!p; p = p.source) {
            if (p.stack && (!error.__minimumStackCounter__ || error.__minimumStackCounter__ > p.stackCounter)) {
              object_defineProperty(error, "__minimumStackCounter__", { value: p.stackCounter, configurable: true });
              stacks.unshift(p.stack);
            }
          }
          stacks.unshift(error.stack);
          var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
          var stack = filterStackString(concatedStacks);
          object_defineProperty(error, "stack", { value: stack, configurable: true });
        }
      }
      function filterStackString(stackString) {
        var lines = stackString.split("\n");
        var desiredLines = [];
        for (var i = 0; i < lines.length; ++i) {
          var line = lines[i];
          if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
            desiredLines.push(line);
          }
        }
        return desiredLines.join("\n");
      }
      function isNodeFrame(stackLine) {
        return stackLine.indexOf("(module.js:") !== -1 || stackLine.indexOf("(node.js:") !== -1;
      }
      function getFileNameAndLineNumber(stackLine) {
        var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
        if (attempt1) {
          return [attempt1[1], Number(attempt1[2])];
        }
        var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
        if (attempt2) {
          return [attempt2[1], Number(attempt2[2])];
        }
        var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
        if (attempt3) {
          return [attempt3[1], Number(attempt3[2])];
        }
      }
      function isInternalFrame(stackLine) {
        var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);
        if (!fileNameAndLineNumber) {
          return false;
        }
        var fileName = fileNameAndLineNumber[0];
        var lineNumber = fileNameAndLineNumber[1];
        return fileName === qFileName && lineNumber >= qStartingLine && lineNumber <= qEndingLine;
      }
      function captureLine() {
        if (!hasStacks) {
          return;
        }
        try {
          throw new Error();
        } catch (e) {
          var lines = e.stack.split("\n");
          var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
          var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
          if (!fileNameAndLineNumber) {
            return;
          }
          qFileName = fileNameAndLineNumber[0];
          return fileNameAndLineNumber[1];
        }
      }
      function deprecate(callback, name, alternative) {
        return function() {
          if (typeof console !== "undefined" && typeof console.warn === "function") {
            console.warn(name + " is deprecated, use " + alternative + " instead.", new Error("").stack);
          }
          return callback.apply(callback, arguments);
        };
      }
      function Q(value) {
        if (value instanceof Promise2) {
          return value;
        }
        if (isPromiseAlike(value)) {
          return coerce(value);
        } else {
          return fulfill(value);
        }
      }
      Q.resolve = Q;
      Q.nextTick = nextTick;
      Q.longStackSupport = false;
      var longStackCounter = 1;
      if (typeof process === "object" && process && process.env && process.env.Q_DEBUG) {
        Q.longStackSupport = true;
      }
      Q.defer = defer;
      function defer() {
        var messages = [], progressListeners = [], resolvedPromise;
        var deferred = object_create(defer.prototype);
        var promise2 = object_create(Promise2.prototype);
        promise2.promiseDispatch = function(resolve, op, operands) {
          var args = array_slice(arguments);
          if (messages) {
            messages.push(args);
            if (op === "when" && operands[1]) {
              progressListeners.push(operands[1]);
            }
          } else {
            Q.nextTick(function() {
              resolvedPromise.promiseDispatch.apply(resolvedPromise, args);
            });
          }
        };
        promise2.valueOf = function() {
          if (messages) {
            return promise2;
          }
          var nearerValue = nearer(resolvedPromise);
          if (isPromise(nearerValue)) {
            resolvedPromise = nearerValue;
          }
          return nearerValue;
        };
        promise2.inspect = function() {
          if (!resolvedPromise) {
            return { state: "pending" };
          }
          return resolvedPromise.inspect();
        };
        if (Q.longStackSupport && hasStacks) {
          try {
            throw new Error();
          } catch (e) {
            promise2.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
            promise2.stackCounter = longStackCounter++;
          }
        }
        function become(newPromise) {
          resolvedPromise = newPromise;
          if (Q.longStackSupport && hasStacks) {
            promise2.source = newPromise;
          }
          array_reduce(messages, function(undefined2, message) {
            Q.nextTick(function() {
              newPromise.promiseDispatch.apply(newPromise, message);
            });
          }, void 0);
          messages = void 0;
          progressListeners = void 0;
        }
        deferred.promise = promise2;
        deferred.resolve = function(value) {
          if (resolvedPromise) {
            return;
          }
          become(Q(value));
        };
        deferred.fulfill = function(value) {
          if (resolvedPromise) {
            return;
          }
          become(fulfill(value));
        };
        deferred.reject = function(reason) {
          if (resolvedPromise) {
            return;
          }
          become(reject(reason));
        };
        deferred.notify = function(progress2) {
          if (resolvedPromise) {
            return;
          }
          array_reduce(progressListeners, function(undefined2, progressListener) {
            Q.nextTick(function() {
              progressListener(progress2);
            });
          }, void 0);
        };
        return deferred;
      }
      defer.prototype.makeNodeResolver = function() {
        var self2 = this;
        return function(error, value) {
          if (error) {
            self2.reject(error);
          } else if (arguments.length > 2) {
            self2.resolve(array_slice(arguments, 1));
          } else {
            self2.resolve(value);
          }
        };
      };
      Q.Promise = promise;
      Q.promise = promise;
      function promise(resolver) {
        if (typeof resolver !== "function") {
          throw new TypeError("resolver must be a function.");
        }
        var deferred = defer();
        try {
          resolver(deferred.resolve, deferred.reject, deferred.notify);
        } catch (reason) {
          deferred.reject(reason);
        }
        return deferred.promise;
      }
      promise.race = race;
      promise.all = all;
      promise.reject = reject;
      promise.resolve = Q;
      Q.passByCopy = function(object) {
        return object;
      };
      Promise2.prototype.passByCopy = function() {
        return this;
      };
      Q.join = function(x, y) {
        return Q(x).join(y);
      };
      Promise2.prototype.join = function(that) {
        return Q([this, that]).spread(function(x, y) {
          if (x === y) {
            return x;
          } else {
            throw new Error("Q can't join: not the same: " + x + " " + y);
          }
        });
      };
      Q.race = race;
      function race(answerPs) {
        return promise(function(resolve, reject2) {
          for (var i = 0, len = answerPs.length; i < len; i++) {
            Q(answerPs[i]).then(resolve, reject2);
          }
        });
      }
      Promise2.prototype.race = function() {
        return this.then(Q.race);
      };
      Q.makePromise = Promise2;
      function Promise2(descriptor, fallback, inspect) {
        if (fallback === void 0) {
          fallback = function(op) {
            return reject(new Error(
              "Promise does not support operation: " + op
            ));
          };
        }
        if (inspect === void 0) {
          inspect = function() {
            return { state: "unknown" };
          };
        }
        var promise2 = object_create(Promise2.prototype);
        promise2.promiseDispatch = function(resolve, op, args) {
          var result;
          try {
            if (descriptor[op]) {
              result = descriptor[op].apply(promise2, args);
            } else {
              result = fallback.call(promise2, op, args);
            }
          } catch (exception) {
            result = reject(exception);
          }
          if (resolve) {
            resolve(result);
          }
        };
        promise2.inspect = inspect;
        if (inspect) {
          var inspected = inspect();
          if (inspected.state === "rejected") {
            promise2.exception = inspected.reason;
          }
          promise2.valueOf = function() {
            var inspected2 = inspect();
            if (inspected2.state === "pending" || inspected2.state === "rejected") {
              return promise2;
            }
            return inspected2.value;
          };
        }
        return promise2;
      }
      Promise2.prototype.toString = function() {
        return "[object Promise]";
      };
      Promise2.prototype.then = function(fulfilled, rejected, progressed) {
        var self2 = this;
        var deferred = defer();
        var done = false;
        function _fulfilled(value) {
          try {
            return typeof fulfilled === "function" ? fulfilled(value) : value;
          } catch (exception) {
            return reject(exception);
          }
        }
        function _rejected(exception) {
          if (typeof rejected === "function") {
            makeStackTraceLong(exception, self2);
            try {
              return rejected(exception);
            } catch (newException) {
              return reject(newException);
            }
          }
          return reject(exception);
        }
        function _progressed(value) {
          return typeof progressed === "function" ? progressed(value) : value;
        }
        Q.nextTick(function() {
          self2.promiseDispatch(function(value) {
            if (done) {
              return;
            }
            done = true;
            deferred.resolve(_fulfilled(value));
          }, "when", [function(exception) {
            if (done) {
              return;
            }
            done = true;
            deferred.resolve(_rejected(exception));
          }]);
        });
        self2.promiseDispatch(void 0, "when", [void 0, function(value) {
          var newValue;
          var threw = false;
          try {
            newValue = _progressed(value);
          } catch (e) {
            threw = true;
            if (Q.onerror) {
              Q.onerror(e);
            } else {
              throw e;
            }
          }
          if (!threw) {
            deferred.notify(newValue);
          }
        }]);
        return deferred.promise;
      };
      Q.tap = function(promise2, callback) {
        return Q(promise2).tap(callback);
      };
      Promise2.prototype.tap = function(callback) {
        callback = Q(callback);
        return this.then(function(value) {
          return callback.fcall(value).thenResolve(value);
        });
      };
      Q.when = when;
      function when(value, fulfilled, rejected, progressed) {
        return Q(value).then(fulfilled, rejected, progressed);
      }
      Promise2.prototype.thenResolve = function(value) {
        return this.then(function() {
          return value;
        });
      };
      Q.thenResolve = function(promise2, value) {
        return Q(promise2).thenResolve(value);
      };
      Promise2.prototype.thenReject = function(reason) {
        return this.then(function() {
          throw reason;
        });
      };
      Q.thenReject = function(promise2, reason) {
        return Q(promise2).thenReject(reason);
      };
      Q.nearer = nearer;
      function nearer(value) {
        if (isPromise(value)) {
          var inspected = value.inspect();
          if (inspected.state === "fulfilled") {
            return inspected.value;
          }
        }
        return value;
      }
      Q.isPromise = isPromise;
      function isPromise(object) {
        return object instanceof Promise2;
      }
      Q.isPromiseAlike = isPromiseAlike;
      function isPromiseAlike(object) {
        return isObject(object) && typeof object.then === "function";
      }
      Q.isPending = isPending;
      function isPending(object) {
        return isPromise(object) && object.inspect().state === "pending";
      }
      Promise2.prototype.isPending = function() {
        return this.inspect().state === "pending";
      };
      Q.isFulfilled = isFulfilled;
      function isFulfilled(object) {
        return !isPromise(object) || object.inspect().state === "fulfilled";
      }
      Promise2.prototype.isFulfilled = function() {
        return this.inspect().state === "fulfilled";
      };
      Q.isRejected = isRejected;
      function isRejected(object) {
        return isPromise(object) && object.inspect().state === "rejected";
      }
      Promise2.prototype.isRejected = function() {
        return this.inspect().state === "rejected";
      };
      var unhandledReasons = [];
      var unhandledRejections = [];
      var reportedUnhandledRejections = [];
      var trackUnhandledRejections = true;
      function resetUnhandledRejections() {
        unhandledReasons.length = 0;
        unhandledRejections.length = 0;
        if (!trackUnhandledRejections) {
          trackUnhandledRejections = true;
        }
      }
      function trackRejection(promise2, reason) {
        if (!trackUnhandledRejections) {
          return;
        }
        if (typeof process === "object" && typeof process.emit === "function") {
          Q.nextTick.runAfter(function() {
            if (array_indexOf(unhandledRejections, promise2) !== -1) {
              process.emit("unhandledRejection", reason, promise2);
              reportedUnhandledRejections.push(promise2);
            }
          });
        }
        unhandledRejections.push(promise2);
        if (reason && typeof reason.stack !== "undefined") {
          unhandledReasons.push(reason.stack);
        } else {
          unhandledReasons.push("(no stack) " + reason);
        }
      }
      function untrackRejection(promise2) {
        if (!trackUnhandledRejections) {
          return;
        }
        var at = array_indexOf(unhandledRejections, promise2);
        if (at !== -1) {
          if (typeof process === "object" && typeof process.emit === "function") {
            Q.nextTick.runAfter(function() {
              var atReport = array_indexOf(reportedUnhandledRejections, promise2);
              if (atReport !== -1) {
                process.emit("rejectionHandled", unhandledReasons[at], promise2);
                reportedUnhandledRejections.splice(atReport, 1);
              }
            });
          }
          unhandledRejections.splice(at, 1);
          unhandledReasons.splice(at, 1);
        }
      }
      Q.resetUnhandledRejections = resetUnhandledRejections;
      Q.getUnhandledReasons = function() {
        return unhandledReasons.slice();
      };
      Q.stopUnhandledRejectionTracking = function() {
        resetUnhandledRejections();
        trackUnhandledRejections = false;
      };
      resetUnhandledRejections();
      Q.reject = reject;
      function reject(reason) {
        var rejection = Promise2({
          "when": function(rejected) {
            if (rejected) {
              untrackRejection(this);
            }
            return rejected ? rejected(reason) : this;
          }
        }, function fallback() {
          return this;
        }, function inspect() {
          return { state: "rejected", reason };
        });
        trackRejection(rejection, reason);
        return rejection;
      }
      Q.fulfill = fulfill;
      function fulfill(value) {
        return Promise2({
          "when": function() {
            return value;
          },
          "get": function(name) {
            return value[name];
          },
          "set": function(name, rhs) {
            value[name] = rhs;
          },
          "delete": function(name) {
            delete value[name];
          },
          "post": function(name, args) {
            if (name === null || name === void 0) {
              return value.apply(void 0, args);
            } else {
              return value[name].apply(value, args);
            }
          },
          "apply": function(thisp, args) {
            return value.apply(thisp, args);
          },
          "keys": function() {
            return object_keys(value);
          }
        }, void 0, function inspect() {
          return { state: "fulfilled", value };
        });
      }
      function coerce(promise2) {
        var deferred = defer();
        Q.nextTick(function() {
          try {
            promise2.then(deferred.resolve, deferred.reject, deferred.notify);
          } catch (exception) {
            deferred.reject(exception);
          }
        });
        return deferred.promise;
      }
      Q.master = master;
      function master(object) {
        return Promise2({
          "isDef": function() {
          }
        }, function fallback(op, args) {
          return dispatch(object, op, args);
        }, function() {
          return Q(object).inspect();
        });
      }
      Q.spread = spread;
      function spread(value, fulfilled, rejected) {
        return Q(value).spread(fulfilled, rejected);
      }
      Promise2.prototype.spread = function(fulfilled, rejected) {
        return this.all().then(function(array) {
          return fulfilled.apply(void 0, array);
        }, rejected);
      };
      Q.async = async;
      function async(makeGenerator) {
        return function() {
          function continuer(verb, arg) {
            var result;
            if (typeof StopIteration === "undefined") {
              try {
                result = generator[verb](arg);
              } catch (exception) {
                return reject(exception);
              }
              if (result.done) {
                return Q(result.value);
              } else {
                return when(result.value, callback, errback);
              }
            } else {
              try {
                result = generator[verb](arg);
              } catch (exception) {
                if (isStopIteration(exception)) {
                  return Q(exception.value);
                } else {
                  return reject(exception);
                }
              }
              return when(result, callback, errback);
            }
          }
          var generator = makeGenerator.apply(this, arguments);
          var callback = continuer.bind(continuer, "next");
          var errback = continuer.bind(continuer, "throw");
          return callback();
        };
      }
      Q.spawn = spawn;
      function spawn(makeGenerator) {
        Q.done(Q.async(makeGenerator)());
      }
      Q["return"] = _return;
      function _return(value) {
        throw new QReturnValue(value);
      }
      Q.promised = promised;
      function promised(callback) {
        return function() {
          return spread([this, all(arguments)], function(self2, args) {
            return callback.apply(self2, args);
          });
        };
      }
      Q.dispatch = dispatch;
      function dispatch(object, op, args) {
        return Q(object).dispatch(op, args);
      }
      Promise2.prototype.dispatch = function(op, args) {
        var self2 = this;
        var deferred = defer();
        Q.nextTick(function() {
          self2.promiseDispatch(deferred.resolve, op, args);
        });
        return deferred.promise;
      };
      Q.get = function(object, key) {
        return Q(object).dispatch("get", [key]);
      };
      Promise2.prototype.get = function(key) {
        return this.dispatch("get", [key]);
      };
      Q.set = function(object, key, value) {
        return Q(object).dispatch("set", [key, value]);
      };
      Promise2.prototype.set = function(key, value) {
        return this.dispatch("set", [key, value]);
      };
      Q.del = Q["delete"] = function(object, key) {
        return Q(object).dispatch("delete", [key]);
      };
      Promise2.prototype.del = Promise2.prototype["delete"] = function(key) {
        return this.dispatch("delete", [key]);
      };
      Q.mapply = Q.post = function(object, name, args) {
        return Q(object).dispatch("post", [name, args]);
      };
      Promise2.prototype.mapply = Promise2.prototype.post = function(name, args) {
        return this.dispatch("post", [name, args]);
      };
      Q.send = Q.mcall = Q.invoke = function(object, name) {
        return Q(object).dispatch("post", [name, array_slice(arguments, 2)]);
      };
      Promise2.prototype.send = Promise2.prototype.mcall = Promise2.prototype.invoke = function(name) {
        return this.dispatch("post", [name, array_slice(arguments, 1)]);
      };
      Q.fapply = function(object, args) {
        return Q(object).dispatch("apply", [void 0, args]);
      };
      Promise2.prototype.fapply = function(args) {
        return this.dispatch("apply", [void 0, args]);
      };
      Q["try"] = Q.fcall = function(object) {
        return Q(object).dispatch("apply", [void 0, array_slice(arguments, 1)]);
      };
      Promise2.prototype.fcall = function() {
        return this.dispatch("apply", [void 0, array_slice(arguments)]);
      };
      Q.fbind = function(object) {
        var promise2 = Q(object);
        var args = array_slice(arguments, 1);
        return function fbound() {
          return promise2.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
          ]);
        };
      };
      Promise2.prototype.fbind = function() {
        var promise2 = this;
        var args = array_slice(arguments);
        return function fbound() {
          return promise2.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
          ]);
        };
      };
      Q.keys = function(object) {
        return Q(object).dispatch("keys", []);
      };
      Promise2.prototype.keys = function() {
        return this.dispatch("keys", []);
      };
      Q.all = all;
      function all(promises) {
        return when(promises, function(promises2) {
          var pendingCount = 0;
          var deferred = defer();
          array_reduce(promises2, function(undefined2, promise2, index) {
            var snapshot;
            if (isPromise(promise2) && (snapshot = promise2.inspect()).state === "fulfilled") {
              promises2[index] = snapshot.value;
            } else {
              ++pendingCount;
              when(
                promise2,
                function(value) {
                  promises2[index] = value;
                  if (--pendingCount === 0) {
                    deferred.resolve(promises2);
                  }
                },
                deferred.reject,
                function(progress2) {
                  deferred.notify({ index, value: progress2 });
                }
              );
            }
          }, void 0);
          if (pendingCount === 0) {
            deferred.resolve(promises2);
          }
          return deferred.promise;
        });
      }
      Promise2.prototype.all = function() {
        return all(this);
      };
      Q.any = any;
      function any(promises) {
        if (promises.length === 0) {
          return Q.resolve();
        }
        var deferred = Q.defer();
        var pendingCount = 0;
        array_reduce(promises, function(prev, current, index) {
          var promise2 = promises[index];
          pendingCount++;
          when(promise2, onFulfilled, onRejected, onProgress);
          function onFulfilled(result) {
            deferred.resolve(result);
          }
          function onRejected(err) {
            pendingCount--;
            if (pendingCount === 0) {
              var rejection = err || new Error("" + err);
              rejection.message = "Q can't get fulfillment value from any promise, all promises were rejected. Last error message: " + rejection.message;
              deferred.reject(rejection);
            }
          }
          function onProgress(progress2) {
            deferred.notify({
              index,
              value: progress2
            });
          }
        }, void 0);
        return deferred.promise;
      }
      Promise2.prototype.any = function() {
        return any(this);
      };
      Q.allResolved = deprecate(allResolved, "allResolved", "allSettled");
      function allResolved(promises) {
        return when(promises, function(promises2) {
          promises2 = array_map(promises2, Q);
          return when(all(array_map(promises2, function(promise2) {
            return when(promise2, noop, noop);
          })), function() {
            return promises2;
          });
        });
      }
      Promise2.prototype.allResolved = function() {
        return allResolved(this);
      };
      Q.allSettled = allSettled;
      function allSettled(promises) {
        return Q(promises).allSettled();
      }
      Promise2.prototype.allSettled = function() {
        return this.then(function(promises) {
          return all(array_map(promises, function(promise2) {
            promise2 = Q(promise2);
            function regardless() {
              return promise2.inspect();
            }
            return promise2.then(regardless, regardless);
          }));
        });
      };
      Q.fail = Q["catch"] = function(object, rejected) {
        return Q(object).then(void 0, rejected);
      };
      Promise2.prototype.fail = Promise2.prototype["catch"] = function(rejected) {
        return this.then(void 0, rejected);
      };
      Q.progress = progress;
      function progress(object, progressed) {
        return Q(object).then(void 0, void 0, progressed);
      }
      Promise2.prototype.progress = function(progressed) {
        return this.then(void 0, void 0, progressed);
      };
      Q.fin = Q["finally"] = function(object, callback) {
        return Q(object)["finally"](callback);
      };
      Promise2.prototype.fin = Promise2.prototype["finally"] = function(callback) {
        if (!callback || typeof callback.apply !== "function") {
          throw new Error("Q can't apply finally callback");
        }
        callback = Q(callback);
        return this.then(function(value) {
          return callback.fcall().then(function() {
            return value;
          });
        }, function(reason) {
          return callback.fcall().then(function() {
            throw reason;
          });
        });
      };
      Q.done = function(object, fulfilled, rejected, progress2) {
        return Q(object).done(fulfilled, rejected, progress2);
      };
      Promise2.prototype.done = function(fulfilled, rejected, progress2) {
        var onUnhandledError = function(error) {
          Q.nextTick(function() {
            makeStackTraceLong(error, promise2);
            if (Q.onerror) {
              Q.onerror(error);
            } else {
              throw error;
            }
          });
        };
        var promise2 = fulfilled || rejected || progress2 ? this.then(fulfilled, rejected, progress2) : this;
        if (typeof process === "object" && process && process.domain) {
          onUnhandledError = process.domain.bind(onUnhandledError);
        }
        promise2.then(void 0, onUnhandledError);
      };
      Q.timeout = function(object, ms, error) {
        return Q(object).timeout(ms, error);
      };
      Promise2.prototype.timeout = function(ms, error) {
        var deferred = defer();
        var timeoutId = setTimeout(function() {
          if (!error || "string" === typeof error) {
            error = new Error(error || "Timed out after " + ms + " ms");
            error.code = "ETIMEDOUT";
          }
          deferred.reject(error);
        }, ms);
        this.then(function(value) {
          clearTimeout(timeoutId);
          deferred.resolve(value);
        }, function(exception) {
          clearTimeout(timeoutId);
          deferred.reject(exception);
        }, deferred.notify);
        return deferred.promise;
      };
      Q.delay = function(object, timeout) {
        if (timeout === void 0) {
          timeout = object;
          object = void 0;
        }
        return Q(object).delay(timeout);
      };
      Promise2.prototype.delay = function(timeout) {
        return this.then(function(value) {
          var deferred = defer();
          setTimeout(function() {
            deferred.resolve(value);
          }, timeout);
          return deferred.promise;
        });
      };
      Q.nfapply = function(callback, args) {
        return Q(callback).nfapply(args);
      };
      Promise2.prototype.nfapply = function(args) {
        var deferred = defer();
        var nodeArgs = array_slice(args);
        nodeArgs.push(deferred.makeNodeResolver());
        this.fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
      };
      Q.nfcall = function(callback) {
        var args = array_slice(arguments, 1);
        return Q(callback).nfapply(args);
      };
      Promise2.prototype.nfcall = function() {
        var nodeArgs = array_slice(arguments);
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        this.fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
      };
      Q.nfbind = Q.denodeify = function(callback) {
        if (callback === void 0) {
          throw new Error("Q can't wrap an undefined function");
        }
        var baseArgs = array_slice(arguments, 1);
        return function() {
          var nodeArgs = baseArgs.concat(array_slice(arguments));
          var deferred = defer();
          nodeArgs.push(deferred.makeNodeResolver());
          Q(callback).fapply(nodeArgs).fail(deferred.reject);
          return deferred.promise;
        };
      };
      Promise2.prototype.nfbind = Promise2.prototype.denodeify = function() {
        var args = array_slice(arguments);
        args.unshift(this);
        return Q.denodeify.apply(void 0, args);
      };
      Q.nbind = function(callback, thisp) {
        var baseArgs = array_slice(arguments, 2);
        return function() {
          var nodeArgs = baseArgs.concat(array_slice(arguments));
          var deferred = defer();
          nodeArgs.push(deferred.makeNodeResolver());
          function bound() {
            return callback.apply(thisp, arguments);
          }
          Q(bound).fapply(nodeArgs).fail(deferred.reject);
          return deferred.promise;
        };
      };
      Promise2.prototype.nbind = function() {
        var args = array_slice(arguments, 0);
        args.unshift(this);
        return Q.nbind.apply(void 0, args);
      };
      Q.nmapply = Q.npost = function(object, name, args) {
        return Q(object).npost(name, args);
      };
      Promise2.prototype.nmapply = Promise2.prototype.npost = function(name, args) {
        var nodeArgs = array_slice(args || []);
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
        return deferred.promise;
      };
      Q.nsend = Q.nmcall = Q.ninvoke = function(object, name) {
        var nodeArgs = array_slice(arguments, 2);
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        Q(object).dispatch("post", [name, nodeArgs]).fail(deferred.reject);
        return deferred.promise;
      };
      Promise2.prototype.nsend = Promise2.prototype.nmcall = Promise2.prototype.ninvoke = function(name) {
        var nodeArgs = array_slice(arguments, 1);
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
        return deferred.promise;
      };
      Q.nodeify = nodeify;
      function nodeify(object, nodeback) {
        return Q(object).nodeify(nodeback);
      }
      Promise2.prototype.nodeify = function(nodeback) {
        if (nodeback) {
          this.then(function(value) {
            Q.nextTick(function() {
              nodeback(null, value);
            });
          }, function(error) {
            Q.nextTick(function() {
              nodeback(error);
            });
          });
        } else {
          return this;
        }
      };
      Q.noConflict = function() {
        throw new Error("Q.noConflict only works when Q is used as a global");
      };
      var qEndingLine = captureLine();
      return Q;
    });
  }
});

// node_modules/thrift/lib/nodejs/lib/thrift/multiplexed_protocol.js
var require_multiplexed_protocol = __commonJS({
  "node_modules/thrift/lib/nodejs/lib/thrift/multiplexed_protocol.js"(exports) {
    var util = require("util");
    var Thrift = require_thrift();
    exports.Multiplexer = Multiplexer;
    function Wrapper(serviceName, protocol, connection) {
      function MultiplexProtocol(trans, strictRead, strictWrite) {
        protocol.call(this, trans, strictRead, strictWrite);
      }
      ;
      util.inherits(MultiplexProtocol, protocol);
      MultiplexProtocol.prototype.writeMessageBegin = function(name, type, seqid) {
        if (type == Thrift.MessageType.CALL || type == Thrift.MessageType.ONEWAY) {
          connection.seqId2Service[seqid] = serviceName;
          MultiplexProtocol.super_.prototype.writeMessageBegin.call(
            this,
            serviceName + ":" + name,
            type,
            seqid
          );
        } else {
          MultiplexProtocol.super_.prototype.writeMessageBegin.call(this, name, type, seqid);
        }
      };
      return MultiplexProtocol;
    }
    function Multiplexer() {
      this.seqid = 0;
    }
    Multiplexer.prototype.createClient = function(serviceName, ServiceClient, connection) {
      if (ServiceClient.Client) {
        ServiceClient = ServiceClient.Client;
      }
      var writeCb = function(buf, seqid) {
        connection.write(buf, seqid);
      };
      var transport = new connection.transport(void 0, writeCb);
      var protocolWrapper = new Wrapper(serviceName, connection.protocol, connection);
      var client = new ServiceClient(transport, protocolWrapper);
      var self2 = this;
      client.new_seqid = function() {
        self2.seqid += 1;
        return self2.seqid;
      };
      if (typeof connection.client !== "object") {
        connection.client = {};
      }
      connection.client[serviceName] = client;
      return client;
    };
  }
});

// node_modules/thrift/lib/nodejs/lib/thrift/framed_transport.js
var require_framed_transport = __commonJS({
  "node_modules/thrift/lib/nodejs/lib/thrift/framed_transport.js"(exports, module2) {
    var binary = require_binary();
    var InputBufferUnderrunError = require_input_buffer_underrun_error();
    var THeaderTransport = require_header_transport();
    module2.exports = TFramedTransport;
    function TFramedTransport(buffer, callback) {
      this.inBuf = buffer || new Buffer(0);
      this.outBuffers = [];
      this.outCount = 0;
      this.readPos = 0;
      this.onFlush = callback;
    }
    TFramedTransport.prototype = new THeaderTransport();
    TFramedTransport.receiver = function(callback, seqid) {
      var residual = null;
      return function(data) {
        if (residual) {
          data = Buffer.concat([residual, data]);
          residual = null;
        }
        while (data.length) {
          if (data.length < 4) {
            residual = data;
            return;
          }
          var frameSize = binary.readI32(data, 0);
          if (data.length < 4 + frameSize) {
            residual = data;
            return;
          }
          var frame = data.slice(4, 4 + frameSize);
          residual = data.slice(4 + frameSize);
          callback(new TFramedTransport(frame), seqid);
          data = residual;
          residual = null;
        }
      };
    };
    TFramedTransport.prototype.commitPosition = function() {
    }, TFramedTransport.prototype.rollbackPosition = function() {
    }, TFramedTransport.prototype.isOpen = function() {
      return true;
    };
    TFramedTransport.prototype.open = function() {
    };
    TFramedTransport.prototype.close = function() {
    };
    TFramedTransport.prototype.setCurrSeqId = function(seqid) {
      this._seqid = seqid;
    };
    TFramedTransport.prototype.ensureAvailable = function(len) {
      if (this.readPos + len > this.inBuf.length) {
        throw new InputBufferUnderrunError();
      }
    };
    TFramedTransport.prototype.read = function(len) {
      this.ensureAvailable(len);
      var end = this.readPos + len;
      if (this.inBuf.length < end) {
        throw new Error("read(" + len + ") failed - not enough data");
      }
      var buf = this.inBuf.slice(this.readPos, end);
      this.readPos = end;
      return buf;
    };
    TFramedTransport.prototype.readByte = function() {
      this.ensureAvailable(1);
      return binary.readByte(this.inBuf[this.readPos++]);
    };
    TFramedTransport.prototype.readI16 = function() {
      this.ensureAvailable(2);
      var i16 = binary.readI16(this.inBuf, this.readPos);
      this.readPos += 2;
      return i16;
    };
    TFramedTransport.prototype.readI32 = function() {
      this.ensureAvailable(4);
      var i32 = binary.readI32(this.inBuf, this.readPos);
      this.readPos += 4;
      return i32;
    };
    TFramedTransport.prototype.readDouble = function() {
      this.ensureAvailable(8);
      var d = binary.readDouble(this.inBuf, this.readPos);
      this.readPos += 8;
      return d;
    };
    TFramedTransport.prototype.readString = function(len) {
      this.ensureAvailable(len);
      var str = this.inBuf.toString("utf8", this.readPos, this.readPos + len);
      this.readPos += len;
      return str;
    };
    TFramedTransport.prototype.borrow = function() {
      return {
        buf: this.inBuf,
        readIndex: this.readPos,
        writeIndex: this.inBuf.length
      };
    };
    TFramedTransport.prototype.consume = function(bytesConsumed) {
      this.readPos += bytesConsumed;
    };
    TFramedTransport.prototype.write = function(buf, encoding) {
      if (typeof buf === "string") {
        buf = new Buffer(buf, encoding || "utf8");
      }
      this.outBuffers.push(buf);
      this.outCount += buf.length;
    };
    TFramedTransport.prototype.flush = function() {
      var seqid = this._seqid;
      this._seqid = null;
      var out = new Buffer(this.outCount), pos = 0;
      this.outBuffers.forEach(function(buf) {
        buf.copy(out, pos, 0);
        pos += buf.length;
      });
      if (this.onFlush) {
        var msg = new Buffer(out.length + 4);
        binary.writeI32(msg, out.length);
        out.copy(msg, 4, 0, out.length);
        if (this.onFlush) {
          this.onFlush(msg, seqid);
        }
      }
      this.outBuffers = [];
      this.outCount = 0;
    };
  }
});

// node_modules/thrift/lib/nodejs/lib/thrift/index.js
var require_thrift2 = __commonJS({
  "node_modules/thrift/lib/nodejs/lib/thrift/index.js"(exports) {
    exports.Thrift = require_thrift();
    var log = require_log();
    exports.setLogFunc = log.setLogFunc;
    exports.setLogLevel = log.setLogLevel;
    exports.getLogLevel = log.getLogLevel;
    var connection = require_connection3();
    exports.Connection = connection.Connection;
    exports.createClient = connection.createClient;
    exports.createConnection = connection.createConnection;
    exports.createUDSConnection = connection.createUDSConnection;
    exports.createSSLConnection = connection.createSSLConnection;
    exports.createStdIOClient = connection.createStdIOClient;
    exports.createStdIOConnection = connection.createStdIOConnection;
    var httpConnection = require_http_connection();
    exports.HttpConnection = httpConnection.HttpConnection;
    exports.createHttpConnection = httpConnection.createHttpConnection;
    exports.createHttpUDSConnection = httpConnection.createHttpUDSConnection;
    exports.createHttpClient = httpConnection.createHttpClient;
    var wsConnection = require_ws_connection();
    exports.WSConnection = wsConnection.WSConnection;
    exports.createWSConnection = wsConnection.createWSConnection;
    exports.createWSClient = wsConnection.createWSClient;
    var xhrConnection = require_xhr_connection();
    exports.XHRConnection = xhrConnection.XHRConnection;
    exports.createXHRConnection = xhrConnection.createXHRConnection;
    exports.createXHRClient = xhrConnection.createXHRClient;
    var server = require_server();
    exports.createServer = server.createServer;
    exports.createMultiplexServer = server.createMultiplexServer;
    var web_server = require_web_server();
    exports.createWebServer = web_server.createWebServer;
    exports.Int64 = require_Int64();
    exports.Q = require_q();
    var mpxProcessor = require_multiplexed_processor();
    var mpxProtocol = require_multiplexed_protocol();
    exports.MultiplexedProcessor = mpxProcessor.MultiplexedProcessor;
    exports.Multiplexer = mpxProtocol.Multiplexer;
    exports.TBufferedTransport = require_buffered_transport();
    exports.TFramedTransport = require_framed_transport();
    exports.TJSONProtocol = require_json_protocol();
    exports.TBinaryProtocol = require_binary_protocol();
    exports.TCompactProtocol = require_compact_protocol();
    exports.THeaderProtocol = require_header_protocol();
  }
});

// node_modules/hive-driver/thrift/gen-nodejs/TCLIService_types.js
var require_TCLIService_types = __commonJS({
  "node_modules/hive-driver/thrift/gen-nodejs/TCLIService_types.js"(exports, module2) {
    "use strict";
    var thrift = require_thrift2();
    var Thrift = thrift.Thrift;
    var Q = thrift.Q;
    var Int64 = require_Int64();
    var ttypes = module2.exports = {};
    ttypes.TProtocolVersion = {
      "HIVE_CLI_SERVICE_PROTOCOL_V1": 0,
      "HIVE_CLI_SERVICE_PROTOCOL_V2": 1,
      "HIVE_CLI_SERVICE_PROTOCOL_V3": 2,
      "HIVE_CLI_SERVICE_PROTOCOL_V4": 3,
      "HIVE_CLI_SERVICE_PROTOCOL_V5": 4,
      "HIVE_CLI_SERVICE_PROTOCOL_V6": 5,
      "HIVE_CLI_SERVICE_PROTOCOL_V7": 6,
      "HIVE_CLI_SERVICE_PROTOCOL_V8": 7,
      "HIVE_CLI_SERVICE_PROTOCOL_V9": 8,
      "HIVE_CLI_SERVICE_PROTOCOL_V10": 9,
      "HIVE_CLI_SERVICE_PROTOCOL_V11": 10
    };
    ttypes.TTypeId = {
      "BOOLEAN_TYPE": 0,
      "TINYINT_TYPE": 1,
      "SMALLINT_TYPE": 2,
      "INT_TYPE": 3,
      "BIGINT_TYPE": 4,
      "FLOAT_TYPE": 5,
      "DOUBLE_TYPE": 6,
      "STRING_TYPE": 7,
      "TIMESTAMP_TYPE": 8,
      "BINARY_TYPE": 9,
      "ARRAY_TYPE": 10,
      "MAP_TYPE": 11,
      "STRUCT_TYPE": 12,
      "UNION_TYPE": 13,
      "USER_DEFINED_TYPE": 14,
      "DECIMAL_TYPE": 15,
      "NULL_TYPE": 16,
      "DATE_TYPE": 17,
      "VARCHAR_TYPE": 18,
      "CHAR_TYPE": 19,
      "INTERVAL_YEAR_MONTH_TYPE": 20,
      "INTERVAL_DAY_TIME_TYPE": 21,
      "TIMESTAMPLOCALTZ_TYPE": 22
    };
    ttypes.TStatusCode = {
      "SUCCESS_STATUS": 0,
      "SUCCESS_WITH_INFO_STATUS": 1,
      "STILL_EXECUTING_STATUS": 2,
      "ERROR_STATUS": 3,
      "INVALID_HANDLE_STATUS": 4
    };
    ttypes.TOperationState = {
      "INITIALIZED_STATE": 0,
      "RUNNING_STATE": 1,
      "FINISHED_STATE": 2,
      "CANCELED_STATE": 3,
      "CLOSED_STATE": 4,
      "ERROR_STATE": 5,
      "UKNOWN_STATE": 6,
      "PENDING_STATE": 7,
      "TIMEDOUT_STATE": 8
    };
    ttypes.TOperationType = {
      "EXECUTE_STATEMENT": 0,
      "GET_TYPE_INFO": 1,
      "GET_CATALOGS": 2,
      "GET_SCHEMAS": 3,
      "GET_TABLES": 4,
      "GET_TABLE_TYPES": 5,
      "GET_COLUMNS": 6,
      "GET_FUNCTIONS": 7,
      "UNKNOWN": 8
    };
    ttypes.TGetInfoType = {
      "CLI_MAX_DRIVER_CONNECTIONS": 0,
      "CLI_MAX_CONCURRENT_ACTIVITIES": 1,
      "CLI_DATA_SOURCE_NAME": 2,
      "CLI_FETCH_DIRECTION": 8,
      "CLI_SERVER_NAME": 13,
      "CLI_SEARCH_PATTERN_ESCAPE": 14,
      "CLI_DBMS_NAME": 17,
      "CLI_DBMS_VER": 18,
      "CLI_ACCESSIBLE_TABLES": 19,
      "CLI_ACCESSIBLE_PROCEDURES": 20,
      "CLI_CURSOR_COMMIT_BEHAVIOR": 23,
      "CLI_DATA_SOURCE_READ_ONLY": 25,
      "CLI_DEFAULT_TXN_ISOLATION": 26,
      "CLI_IDENTIFIER_CASE": 28,
      "CLI_IDENTIFIER_QUOTE_CHAR": 29,
      "CLI_MAX_COLUMN_NAME_LEN": 30,
      "CLI_MAX_CURSOR_NAME_LEN": 31,
      "CLI_MAX_SCHEMA_NAME_LEN": 32,
      "CLI_MAX_CATALOG_NAME_LEN": 34,
      "CLI_MAX_TABLE_NAME_LEN": 35,
      "CLI_SCROLL_CONCURRENCY": 43,
      "CLI_TXN_CAPABLE": 46,
      "CLI_USER_NAME": 47,
      "CLI_TXN_ISOLATION_OPTION": 72,
      "CLI_INTEGRITY": 73,
      "CLI_GETDATA_EXTENSIONS": 81,
      "CLI_NULL_COLLATION": 85,
      "CLI_ALTER_TABLE": 86,
      "CLI_ORDER_BY_COLUMNS_IN_SELECT": 90,
      "CLI_SPECIAL_CHARACTERS": 94,
      "CLI_MAX_COLUMNS_IN_GROUP_BY": 97,
      "CLI_MAX_COLUMNS_IN_INDEX": 98,
      "CLI_MAX_COLUMNS_IN_ORDER_BY": 99,
      "CLI_MAX_COLUMNS_IN_SELECT": 100,
      "CLI_MAX_COLUMNS_IN_TABLE": 101,
      "CLI_MAX_INDEX_SIZE": 102,
      "CLI_MAX_ROW_SIZE": 104,
      "CLI_MAX_STATEMENT_LEN": 105,
      "CLI_MAX_TABLES_IN_SELECT": 106,
      "CLI_MAX_USER_NAME_LEN": 107,
      "CLI_OJ_CAPABILITIES": 115,
      "CLI_XOPEN_CLI_YEAR": 1e4,
      "CLI_CURSOR_SENSITIVITY": 10001,
      "CLI_DESCRIBE_PARAMETER": 10002,
      "CLI_CATALOG_NAME": 10003,
      "CLI_COLLATION_SEQ": 10004,
      "CLI_MAX_IDENTIFIER_LEN": 10005,
      "CLI_ODBC_KEYWORDS": 10006
    };
    ttypes.TFetchOrientation = {
      "FETCH_NEXT": 0,
      "FETCH_PRIOR": 1,
      "FETCH_RELATIVE": 2,
      "FETCH_ABSOLUTE": 3,
      "FETCH_FIRST": 4,
      "FETCH_LAST": 5
    };
    ttypes.TJobExecutionStatus = {
      "IN_PROGRESS": 0,
      "COMPLETE": 1,
      "NOT_AVAILABLE": 2
    };
    var TTypeQualifierValue = module2.exports.TTypeQualifierValue = function(args) {
      this.i32Value = null;
      this.stringValue = null;
      if (args) {
        if (args.i32Value !== void 0 && args.i32Value !== null) {
          this.i32Value = args.i32Value;
        }
        if (args.stringValue !== void 0 && args.stringValue !== null) {
          this.stringValue = args.stringValue;
        }
      }
    };
    TTypeQualifierValue.prototype = {};
    TTypeQualifierValue.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.I32) {
              this.i32Value = input.readI32();
            } else {
              input.skip(ftype);
            }
            break;
          case 2:
            if (ftype == Thrift.Type.STRING) {
              this.stringValue = input.readString();
            } else {
              input.skip(ftype);
            }
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TTypeQualifierValue.prototype.write = function(output) {
      output.writeStructBegin("TTypeQualifierValue");
      if (this.i32Value !== null && this.i32Value !== void 0) {
        output.writeFieldBegin("i32Value", Thrift.Type.I32, 1);
        output.writeI32(this.i32Value);
        output.writeFieldEnd();
      }
      if (this.stringValue !== null && this.stringValue !== void 0) {
        output.writeFieldBegin("stringValue", Thrift.Type.STRING, 2);
        output.writeString(this.stringValue);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TTypeQualifiers = module2.exports.TTypeQualifiers = function(args) {
      this.qualifiers = null;
      if (args) {
        if (args.qualifiers !== void 0 && args.qualifiers !== null) {
          this.qualifiers = Thrift.copyMap(args.qualifiers, [ttypes.TTypeQualifierValue]);
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field qualifiers is unset!");
        }
      }
    };
    TTypeQualifiers.prototype = {};
    TTypeQualifiers.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.MAP) {
              this.qualifiers = {};
              var _rtmp31 = input.readMapBegin();
              var _size0 = _rtmp31.size || 0;
              for (var _i2 = 0; _i2 < _size0; ++_i2) {
                var key3 = null;
                var val4 = null;
                key3 = input.readString();
                val4 = new ttypes.TTypeQualifierValue();
                val4.read(input);
                this.qualifiers[key3] = val4;
              }
              input.readMapEnd();
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TTypeQualifiers.prototype.write = function(output) {
      output.writeStructBegin("TTypeQualifiers");
      if (this.qualifiers !== null && this.qualifiers !== void 0) {
        output.writeFieldBegin("qualifiers", Thrift.Type.MAP, 1);
        output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRUCT, Thrift.objectLength(this.qualifiers));
        for (var kiter5 in this.qualifiers) {
          if (this.qualifiers.hasOwnProperty(kiter5)) {
            var viter6 = this.qualifiers[kiter5];
            output.writeString(kiter5);
            viter6.write(output);
          }
        }
        output.writeMapEnd();
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TPrimitiveTypeEntry = module2.exports.TPrimitiveTypeEntry = function(args) {
      this.type = null;
      this.typeQualifiers = null;
      if (args) {
        if (args.type !== void 0 && args.type !== null) {
          this.type = args.type;
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field type is unset!");
        }
        if (args.typeQualifiers !== void 0 && args.typeQualifiers !== null) {
          this.typeQualifiers = new ttypes.TTypeQualifiers(args.typeQualifiers);
        }
      }
    };
    TPrimitiveTypeEntry.prototype = {};
    TPrimitiveTypeEntry.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.I32) {
              this.type = input.readI32();
            } else {
              input.skip(ftype);
            }
            break;
          case 2:
            if (ftype == Thrift.Type.STRUCT) {
              this.typeQualifiers = new ttypes.TTypeQualifiers();
              this.typeQualifiers.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TPrimitiveTypeEntry.prototype.write = function(output) {
      output.writeStructBegin("TPrimitiveTypeEntry");
      if (this.type !== null && this.type !== void 0) {
        output.writeFieldBegin("type", Thrift.Type.I32, 1);
        output.writeI32(this.type);
        output.writeFieldEnd();
      }
      if (this.typeQualifiers !== null && this.typeQualifiers !== void 0) {
        output.writeFieldBegin("typeQualifiers", Thrift.Type.STRUCT, 2);
        this.typeQualifiers.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TArrayTypeEntry = module2.exports.TArrayTypeEntry = function(args) {
      this.objectTypePtr = null;
      if (args) {
        if (args.objectTypePtr !== void 0 && args.objectTypePtr !== null) {
          this.objectTypePtr = args.objectTypePtr;
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field objectTypePtr is unset!");
        }
      }
    };
    TArrayTypeEntry.prototype = {};
    TArrayTypeEntry.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.I32) {
              this.objectTypePtr = input.readI32();
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TArrayTypeEntry.prototype.write = function(output) {
      output.writeStructBegin("TArrayTypeEntry");
      if (this.objectTypePtr !== null && this.objectTypePtr !== void 0) {
        output.writeFieldBegin("objectTypePtr", Thrift.Type.I32, 1);
        output.writeI32(this.objectTypePtr);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TMapTypeEntry = module2.exports.TMapTypeEntry = function(args) {
      this.keyTypePtr = null;
      this.valueTypePtr = null;
      if (args) {
        if (args.keyTypePtr !== void 0 && args.keyTypePtr !== null) {
          this.keyTypePtr = args.keyTypePtr;
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field keyTypePtr is unset!");
        }
        if (args.valueTypePtr !== void 0 && args.valueTypePtr !== null) {
          this.valueTypePtr = args.valueTypePtr;
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field valueTypePtr is unset!");
        }
      }
    };
    TMapTypeEntry.prototype = {};
    TMapTypeEntry.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.I32) {
              this.keyTypePtr = input.readI32();
            } else {
              input.skip(ftype);
            }
            break;
          case 2:
            if (ftype == Thrift.Type.I32) {
              this.valueTypePtr = input.readI32();
            } else {
              input.skip(ftype);
            }
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TMapTypeEntry.prototype.write = function(output) {
      output.writeStructBegin("TMapTypeEntry");
      if (this.keyTypePtr !== null && this.keyTypePtr !== void 0) {
        output.writeFieldBegin("keyTypePtr", Thrift.Type.I32, 1);
        output.writeI32(this.keyTypePtr);
        output.writeFieldEnd();
      }
      if (this.valueTypePtr !== null && this.valueTypePtr !== void 0) {
        output.writeFieldBegin("valueTypePtr", Thrift.Type.I32, 2);
        output.writeI32(this.valueTypePtr);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TStructTypeEntry = module2.exports.TStructTypeEntry = function(args) {
      this.nameToTypePtr = null;
      if (args) {
        if (args.nameToTypePtr !== void 0 && args.nameToTypePtr !== null) {
          this.nameToTypePtr = Thrift.copyMap(args.nameToTypePtr, [null]);
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field nameToTypePtr is unset!");
        }
      }
    };
    TStructTypeEntry.prototype = {};
    TStructTypeEntry.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.MAP) {
              this.nameToTypePtr = {};
              var _rtmp38 = input.readMapBegin();
              var _size7 = _rtmp38.size || 0;
              for (var _i9 = 0; _i9 < _size7; ++_i9) {
                var key10 = null;
                var val11 = null;
                key10 = input.readString();
                val11 = input.readI32();
                this.nameToTypePtr[key10] = val11;
              }
              input.readMapEnd();
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TStructTypeEntry.prototype.write = function(output) {
      output.writeStructBegin("TStructTypeEntry");
      if (this.nameToTypePtr !== null && this.nameToTypePtr !== void 0) {
        output.writeFieldBegin("nameToTypePtr", Thrift.Type.MAP, 1);
        output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.I32, Thrift.objectLength(this.nameToTypePtr));
        for (var kiter12 in this.nameToTypePtr) {
          if (this.nameToTypePtr.hasOwnProperty(kiter12)) {
            var viter13 = this.nameToTypePtr[kiter12];
            output.writeString(kiter12);
            output.writeI32(viter13);
          }
        }
        output.writeMapEnd();
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TUnionTypeEntry = module2.exports.TUnionTypeEntry = function(args) {
      this.nameToTypePtr = null;
      if (args) {
        if (args.nameToTypePtr !== void 0 && args.nameToTypePtr !== null) {
          this.nameToTypePtr = Thrift.copyMap(args.nameToTypePtr, [null]);
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field nameToTypePtr is unset!");
        }
      }
    };
    TUnionTypeEntry.prototype = {};
    TUnionTypeEntry.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.MAP) {
              this.nameToTypePtr = {};
              var _rtmp315 = input.readMapBegin();
              var _size14 = _rtmp315.size || 0;
              for (var _i16 = 0; _i16 < _size14; ++_i16) {
                var key17 = null;
                var val18 = null;
                key17 = input.readString();
                val18 = input.readI32();
                this.nameToTypePtr[key17] = val18;
              }
              input.readMapEnd();
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TUnionTypeEntry.prototype.write = function(output) {
      output.writeStructBegin("TUnionTypeEntry");
      if (this.nameToTypePtr !== null && this.nameToTypePtr !== void 0) {
        output.writeFieldBegin("nameToTypePtr", Thrift.Type.MAP, 1);
        output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.I32, Thrift.objectLength(this.nameToTypePtr));
        for (var kiter19 in this.nameToTypePtr) {
          if (this.nameToTypePtr.hasOwnProperty(kiter19)) {
            var viter20 = this.nameToTypePtr[kiter19];
            output.writeString(kiter19);
            output.writeI32(viter20);
          }
        }
        output.writeMapEnd();
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TUserDefinedTypeEntry = module2.exports.TUserDefinedTypeEntry = function(args) {
      this.typeClassName = null;
      if (args) {
        if (args.typeClassName !== void 0 && args.typeClassName !== null) {
          this.typeClassName = args.typeClassName;
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field typeClassName is unset!");
        }
      }
    };
    TUserDefinedTypeEntry.prototype = {};
    TUserDefinedTypeEntry.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRING) {
              this.typeClassName = input.readString();
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TUserDefinedTypeEntry.prototype.write = function(output) {
      output.writeStructBegin("TUserDefinedTypeEntry");
      if (this.typeClassName !== null && this.typeClassName !== void 0) {
        output.writeFieldBegin("typeClassName", Thrift.Type.STRING, 1);
        output.writeString(this.typeClassName);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TTypeEntry = module2.exports.TTypeEntry = function(args) {
      this.primitiveEntry = null;
      this.arrayEntry = null;
      this.mapEntry = null;
      this.structEntry = null;
      this.unionEntry = null;
      this.userDefinedTypeEntry = null;
      if (args) {
        if (args.primitiveEntry !== void 0 && args.primitiveEntry !== null) {
          this.primitiveEntry = new ttypes.TPrimitiveTypeEntry(args.primitiveEntry);
        }
        if (args.arrayEntry !== void 0 && args.arrayEntry !== null) {
          this.arrayEntry = new ttypes.TArrayTypeEntry(args.arrayEntry);
        }
        if (args.mapEntry !== void 0 && args.mapEntry !== null) {
          this.mapEntry = new ttypes.TMapTypeEntry(args.mapEntry);
        }
        if (args.structEntry !== void 0 && args.structEntry !== null) {
          this.structEntry = new ttypes.TStructTypeEntry(args.structEntry);
        }
        if (args.unionEntry !== void 0 && args.unionEntry !== null) {
          this.unionEntry = new ttypes.TUnionTypeEntry(args.unionEntry);
        }
        if (args.userDefinedTypeEntry !== void 0 && args.userDefinedTypeEntry !== null) {
          this.userDefinedTypeEntry = new ttypes.TUserDefinedTypeEntry(args.userDefinedTypeEntry);
        }
      }
    };
    TTypeEntry.prototype = {};
    TTypeEntry.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.primitiveEntry = new ttypes.TPrimitiveTypeEntry();
              this.primitiveEntry.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 2:
            if (ftype == Thrift.Type.STRUCT) {
              this.arrayEntry = new ttypes.TArrayTypeEntry();
              this.arrayEntry.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 3:
            if (ftype == Thrift.Type.STRUCT) {
              this.mapEntry = new ttypes.TMapTypeEntry();
              this.mapEntry.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 4:
            if (ftype == Thrift.Type.STRUCT) {
              this.structEntry = new ttypes.TStructTypeEntry();
              this.structEntry.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 5:
            if (ftype == Thrift.Type.STRUCT) {
              this.unionEntry = new ttypes.TUnionTypeEntry();
              this.unionEntry.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 6:
            if (ftype == Thrift.Type.STRUCT) {
              this.userDefinedTypeEntry = new ttypes.TUserDefinedTypeEntry();
              this.userDefinedTypeEntry.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TTypeEntry.prototype.write = function(output) {
      output.writeStructBegin("TTypeEntry");
      if (this.primitiveEntry !== null && this.primitiveEntry !== void 0) {
        output.writeFieldBegin("primitiveEntry", Thrift.Type.STRUCT, 1);
        this.primitiveEntry.write(output);
        output.writeFieldEnd();
      }
      if (this.arrayEntry !== null && this.arrayEntry !== void 0) {
        output.writeFieldBegin("arrayEntry", Thrift.Type.STRUCT, 2);
        this.arrayEntry.write(output);
        output.writeFieldEnd();
      }
      if (this.mapEntry !== null && this.mapEntry !== void 0) {
        output.writeFieldBegin("mapEntry", Thrift.Type.STRUCT, 3);
        this.mapEntry.write(output);
        output.writeFieldEnd();
      }
      if (this.structEntry !== null && this.structEntry !== void 0) {
        output.writeFieldBegin("structEntry", Thrift.Type.STRUCT, 4);
        this.structEntry.write(output);
        output.writeFieldEnd();
      }
      if (this.unionEntry !== null && this.unionEntry !== void 0) {
        output.writeFieldBegin("unionEntry", Thrift.Type.STRUCT, 5);
        this.unionEntry.write(output);
        output.writeFieldEnd();
      }
      if (this.userDefinedTypeEntry !== null && this.userDefinedTypeEntry !== void 0) {
        output.writeFieldBegin("userDefinedTypeEntry", Thrift.Type.STRUCT, 6);
        this.userDefinedTypeEntry.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TTypeDesc = module2.exports.TTypeDesc = function(args) {
      this.types = null;
      if (args) {
        if (args.types !== void 0 && args.types !== null) {
          this.types = Thrift.copyList(args.types, [ttypes.TTypeEntry]);
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field types is unset!");
        }
      }
    };
    TTypeDesc.prototype = {};
    TTypeDesc.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.LIST) {
              this.types = [];
              var _rtmp322 = input.readListBegin();
              var _size21 = _rtmp322.size || 0;
              for (var _i23 = 0; _i23 < _size21; ++_i23) {
                var elem24 = null;
                elem24 = new ttypes.TTypeEntry();
                elem24.read(input);
                this.types.push(elem24);
              }
              input.readListEnd();
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TTypeDesc.prototype.write = function(output) {
      output.writeStructBegin("TTypeDesc");
      if (this.types !== null && this.types !== void 0) {
        output.writeFieldBegin("types", Thrift.Type.LIST, 1);
        output.writeListBegin(Thrift.Type.STRUCT, this.types.length);
        for (var iter25 in this.types) {
          if (this.types.hasOwnProperty(iter25)) {
            iter25 = this.types[iter25];
            iter25.write(output);
          }
        }
        output.writeListEnd();
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TColumnDesc = module2.exports.TColumnDesc = function(args) {
      this.columnName = null;
      this.typeDesc = null;
      this.position = null;
      this.comment = null;
      if (args) {
        if (args.columnName !== void 0 && args.columnName !== null) {
          this.columnName = args.columnName;
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field columnName is unset!");
        }
        if (args.typeDesc !== void 0 && args.typeDesc !== null) {
          this.typeDesc = new ttypes.TTypeDesc(args.typeDesc);
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field typeDesc is unset!");
        }
        if (args.position !== void 0 && args.position !== null) {
          this.position = args.position;
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field position is unset!");
        }
        if (args.comment !== void 0 && args.comment !== null) {
          this.comment = args.comment;
        }
      }
    };
    TColumnDesc.prototype = {};
    TColumnDesc.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRING) {
              this.columnName = input.readString();
            } else {
              input.skip(ftype);
            }
            break;
          case 2:
            if (ftype == Thrift.Type.STRUCT) {
              this.typeDesc = new ttypes.TTypeDesc();
              this.typeDesc.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 3:
            if (ftype == Thrift.Type.I32) {
              this.position = input.readI32();
            } else {
              input.skip(ftype);
            }
            break;
          case 4:
            if (ftype == Thrift.Type.STRING) {
              this.comment = input.readString();
            } else {
              input.skip(ftype);
            }
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TColumnDesc.prototype.write = function(output) {
      output.writeStructBegin("TColumnDesc");
      if (this.columnName !== null && this.columnName !== void 0) {
        output.writeFieldBegin("columnName", Thrift.Type.STRING, 1);
        output.writeString(this.columnName);
        output.writeFieldEnd();
      }
      if (this.typeDesc !== null && this.typeDesc !== void 0) {
        output.writeFieldBegin("typeDesc", Thrift.Type.STRUCT, 2);
        this.typeDesc.write(output);
        output.writeFieldEnd();
      }
      if (this.position !== null && this.position !== void 0) {
        output.writeFieldBegin("position", Thrift.Type.I32, 3);
        output.writeI32(this.position);
        output.writeFieldEnd();
      }
      if (this.comment !== null && this.comment !== void 0) {
        output.writeFieldBegin("comment", Thrift.Type.STRING, 4);
        output.writeString(this.comment);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TTableSchema = module2.exports.TTableSchema = function(args) {
      this.columns = null;
      if (args) {
        if (args.columns !== void 0 && args.columns !== null) {
          this.columns = Thrift.copyList(args.columns, [ttypes.TColumnDesc]);
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field columns is unset!");
        }
      }
    };
    TTableSchema.prototype = {};
    TTableSchema.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.LIST) {
              this.columns = [];
              var _rtmp327 = input.readListBegin();
              var _size26 = _rtmp327.size || 0;
              for (var _i28 = 0; _i28 < _size26; ++_i28) {
                var elem29 = null;
                elem29 = new ttypes.TColumnDesc();
                elem29.read(input);
                this.columns.push(elem29);
              }
              input.readListEnd();
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TTableSchema.prototype.write = function(output) {
      output.writeStructBegin("TTableSchema");
      if (this.columns !== null && this.columns !== void 0) {
        output.writeFieldBegin("columns", Thrift.Type.LIST, 1);
        output.writeListBegin(Thrift.Type.STRUCT, this.columns.length);
        for (var iter30 in this.columns) {
          if (this.columns.hasOwnProperty(iter30)) {
            iter30 = this.columns[iter30];
            iter30.write(output);
          }
        }
        output.writeListEnd();
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TBoolValue = module2.exports.TBoolValue = function(args) {
      this.value = null;
      if (args) {
        if (args.value !== void 0 && args.value !== null) {
          this.value = args.value;
        }
      }
    };
    TBoolValue.prototype = {};
    TBoolValue.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.BOOL) {
              this.value = input.readBool();
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TBoolValue.prototype.write = function(output) {
      output.writeStructBegin("TBoolValue");
      if (this.value !== null && this.value !== void 0) {
        output.writeFieldBegin("value", Thrift.Type.BOOL, 1);
        output.writeBool(this.value);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TByteValue = module2.exports.TByteValue = function(args) {
      this.value = null;
      if (args) {
        if (args.value !== void 0 && args.value !== null) {
          this.value = args.value;
        }
      }
    };
    TByteValue.prototype = {};
    TByteValue.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.BYTE) {
              this.value = input.readByte();
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TByteValue.prototype.write = function(output) {
      output.writeStructBegin("TByteValue");
      if (this.value !== null && this.value !== void 0) {
        output.writeFieldBegin("value", Thrift.Type.BYTE, 1);
        output.writeByte(this.value);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TI16Value = module2.exports.TI16Value = function(args) {
      this.value = null;
      if (args) {
        if (args.value !== void 0 && args.value !== null) {
          this.value = args.value;
        }
      }
    };
    TI16Value.prototype = {};
    TI16Value.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.I16) {
              this.value = input.readI16();
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TI16Value.prototype.write = function(output) {
      output.writeStructBegin("TI16Value");
      if (this.value !== null && this.value !== void 0) {
        output.writeFieldBegin("value", Thrift.Type.I16, 1);
        output.writeI16(this.value);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TI32Value = module2.exports.TI32Value = function(args) {
      this.value = null;
      if (args) {
        if (args.value !== void 0 && args.value !== null) {
          this.value = args.value;
        }
      }
    };
    TI32Value.prototype = {};
    TI32Value.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.I32) {
              this.value = input.readI32();
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TI32Value.prototype.write = function(output) {
      output.writeStructBegin("TI32Value");
      if (this.value !== null && this.value !== void 0) {
        output.writeFieldBegin("value", Thrift.Type.I32, 1);
        output.writeI32(this.value);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TI64Value = module2.exports.TI64Value = function(args) {
      this.value = null;
      if (args) {
        if (args.value !== void 0 && args.value !== null) {
          this.value = args.value;
        }
      }
    };
    TI64Value.prototype = {};
    TI64Value.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.I64) {
              this.value = input.readI64();
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TI64Value.prototype.write = function(output) {
      output.writeStructBegin("TI64Value");
      if (this.value !== null && this.value !== void 0) {
        output.writeFieldBegin("value", Thrift.Type.I64, 1);
        output.writeI64(this.value);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TDoubleValue = module2.exports.TDoubleValue = function(args) {
      this.value = null;
      if (args) {
        if (args.value !== void 0 && args.value !== null) {
          this.value = args.value;
        }
      }
    };
    TDoubleValue.prototype = {};
    TDoubleValue.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.DOUBLE) {
              this.value = input.readDouble();
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TDoubleValue.prototype.write = function(output) {
      output.writeStructBegin("TDoubleValue");
      if (this.value !== null && this.value !== void 0) {
        output.writeFieldBegin("value", Thrift.Type.DOUBLE, 1);
        output.writeDouble(this.value);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TStringValue = module2.exports.TStringValue = function(args) {
      this.value = null;
      if (args) {
        if (args.value !== void 0 && args.value !== null) {
          this.value = args.value;
        }
      }
    };
    TStringValue.prototype = {};
    TStringValue.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRING) {
              this.value = input.readString();
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TStringValue.prototype.write = function(output) {
      output.writeStructBegin("TStringValue");
      if (this.value !== null && this.value !== void 0) {
        output.writeFieldBegin("value", Thrift.Type.STRING, 1);
        output.writeString(this.value);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TColumnValue = module2.exports.TColumnValue = function(args) {
      this.boolVal = null;
      this.byteVal = null;
      this.i16Val = null;
      this.i32Val = null;
      this.i64Val = null;
      this.doubleVal = null;
      this.stringVal = null;
      if (args) {
        if (args.boolVal !== void 0 && args.boolVal !== null) {
          this.boolVal = new ttypes.TBoolValue(args.boolVal);
        }
        if (args.byteVal !== void 0 && args.byteVal !== null) {
          this.byteVal = new ttypes.TByteValue(args.byteVal);
        }
        if (args.i16Val !== void 0 && args.i16Val !== null) {
          this.i16Val = new ttypes.TI16Value(args.i16Val);
        }
        if (args.i32Val !== void 0 && args.i32Val !== null) {
          this.i32Val = new ttypes.TI32Value(args.i32Val);
        }
        if (args.i64Val !== void 0 && args.i64Val !== null) {
          this.i64Val = new ttypes.TI64Value(args.i64Val);
        }
        if (args.doubleVal !== void 0 && args.doubleVal !== null) {
          this.doubleVal = new ttypes.TDoubleValue(args.doubleVal);
        }
        if (args.stringVal !== void 0 && args.stringVal !== null) {
          this.stringVal = new ttypes.TStringValue(args.stringVal);
        }
      }
    };
    TColumnValue.prototype = {};
    TColumnValue.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.boolVal = new ttypes.TBoolValue();
              this.boolVal.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 2:
            if (ftype == Thrift.Type.STRUCT) {
              this.byteVal = new ttypes.TByteValue();
              this.byteVal.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 3:
            if (ftype == Thrift.Type.STRUCT) {
              this.i16Val = new ttypes.TI16Value();
              this.i16Val.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 4:
            if (ftype == Thrift.Type.STRUCT) {
              this.i32Val = new ttypes.TI32Value();
              this.i32Val.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 5:
            if (ftype == Thrift.Type.STRUCT) {
              this.i64Val = new ttypes.TI64Value();
              this.i64Val.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 6:
            if (ftype == Thrift.Type.STRUCT) {
              this.doubleVal = new ttypes.TDoubleValue();
              this.doubleVal.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 7:
            if (ftype == Thrift.Type.STRUCT) {
              this.stringVal = new ttypes.TStringValue();
              this.stringVal.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TColumnValue.prototype.write = function(output) {
      output.writeStructBegin("TColumnValue");
      if (this.boolVal !== null && this.boolVal !== void 0) {
        output.writeFieldBegin("boolVal", Thrift.Type.STRUCT, 1);
        this.boolVal.write(output);
        output.writeFieldEnd();
      }
      if (this.byteVal !== null && this.byteVal !== void 0) {
        output.writeFieldBegin("byteVal", Thrift.Type.STRUCT, 2);
        this.byteVal.write(output);
        output.writeFieldEnd();
      }
      if (this.i16Val !== null && this.i16Val !== void 0) {
        output.writeFieldBegin("i16Val", Thrift.Type.STRUCT, 3);
        this.i16Val.write(output);
        output.writeFieldEnd();
      }
      if (this.i32Val !== null && this.i32Val !== void 0) {
        output.writeFieldBegin("i32Val", Thrift.Type.STRUCT, 4);
        this.i32Val.write(output);
        output.writeFieldEnd();
      }
      if (this.i64Val !== null && this.i64Val !== void 0) {
        output.writeFieldBegin("i64Val", Thrift.Type.STRUCT, 5);
        this.i64Val.write(output);
        output.writeFieldEnd();
      }
      if (this.doubleVal !== null && this.doubleVal !== void 0) {
        output.writeFieldBegin("doubleVal", Thrift.Type.STRUCT, 6);
        this.doubleVal.write(output);
        output.writeFieldEnd();
      }
      if (this.stringVal !== null && this.stringVal !== void 0) {
        output.writeFieldBegin("stringVal", Thrift.Type.STRUCT, 7);
        this.stringVal.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TRow = module2.exports.TRow = function(args) {
      this.colVals = null;
      if (args) {
        if (args.colVals !== void 0 && args.colVals !== null) {
          this.colVals = Thrift.copyList(args.colVals, [ttypes.TColumnValue]);
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field colVals is unset!");
        }
      }
    };
    TRow.prototype = {};
    TRow.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.LIST) {
              this.colVals = [];
              var _rtmp332 = input.readListBegin();
              var _size31 = _rtmp332.size || 0;
              for (var _i33 = 0; _i33 < _size31; ++_i33) {
                var elem34 = null;
                elem34 = new ttypes.TColumnValue();
                elem34.read(input);
                this.colVals.push(elem34);
              }
              input.readListEnd();
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TRow.prototype.write = function(output) {
      output.writeStructBegin("TRow");
      if (this.colVals !== null && this.colVals !== void 0) {
        output.writeFieldBegin("colVals", Thrift.Type.LIST, 1);
        output.writeListBegin(Thrift.Type.STRUCT, this.colVals.length);
        for (var iter35 in this.colVals) {
          if (this.colVals.hasOwnProperty(iter35)) {
            iter35 = this.colVals[iter35];
            iter35.write(output);
          }
        }
        output.writeListEnd();
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TBoolColumn = module2.exports.TBoolColumn = function(args) {
      this.values = null;
      this.nulls = null;
      if (args) {
        if (args.values !== void 0 && args.values !== null) {
          this.values = Thrift.copyList(args.values, [null]);
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field values is unset!");
        }
        if (args.nulls !== void 0 && args.nulls !== null) {
          this.nulls = args.nulls;
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field nulls is unset!");
        }
      }
    };
    TBoolColumn.prototype = {};
    TBoolColumn.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.LIST) {
              this.values = [];
              var _rtmp337 = input.readListBegin();
              var _size36 = _rtmp337.size || 0;
              for (var _i38 = 0; _i38 < _size36; ++_i38) {
                var elem39 = null;
                elem39 = input.readBool();
                this.values.push(elem39);
              }
              input.readListEnd();
            } else {
              input.skip(ftype);
            }
            break;
          case 2:
            if (ftype == Thrift.Type.STRING) {
              this.nulls = input.readBinary();
            } else {
              input.skip(ftype);
            }
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TBoolColumn.prototype.write = function(output) {
      output.writeStructBegin("TBoolColumn");
      if (this.values !== null && this.values !== void 0) {
        output.writeFieldBegin("values", Thrift.Type.LIST, 1);
        output.writeListBegin(Thrift.Type.BOOL, this.values.length);
        for (var iter40 in this.values) {
          if (this.values.hasOwnProperty(iter40)) {
            iter40 = this.values[iter40];
            output.writeBool(iter40);
          }
        }
        output.writeListEnd();
        output.writeFieldEnd();
      }
      if (this.nulls !== null && this.nulls !== void 0) {
        output.writeFieldBegin("nulls", Thrift.Type.STRING, 2);
        output.writeBinary(this.nulls);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TByteColumn = module2.exports.TByteColumn = function(args) {
      this.values = null;
      this.nulls = null;
      if (args) {
        if (args.values !== void 0 && args.values !== null) {
          this.values = Thrift.copyList(args.values, [null]);
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field values is unset!");
        }
        if (args.nulls !== void 0 && args.nulls !== null) {
          this.nulls = args.nulls;
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field nulls is unset!");
        }
      }
    };
    TByteColumn.prototype = {};
    TByteColumn.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.LIST) {
              this.values = [];
              var _rtmp342 = input.readListBegin();
              var _size41 = _rtmp342.size || 0;
              for (var _i43 = 0; _i43 < _size41; ++_i43) {
                var elem44 = null;
                elem44 = input.readByte();
                this.values.push(elem44);
              }
              input.readListEnd();
            } else {
              input.skip(ftype);
            }
            break;
          case 2:
            if (ftype == Thrift.Type.STRING) {
              this.nulls = input.readBinary();
            } else {
              input.skip(ftype);
            }
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TByteColumn.prototype.write = function(output) {
      output.writeStructBegin("TByteColumn");
      if (this.values !== null && this.values !== void 0) {
        output.writeFieldBegin("values", Thrift.Type.LIST, 1);
        output.writeListBegin(Thrift.Type.BYTE, this.values.length);
        for (var iter45 in this.values) {
          if (this.values.hasOwnProperty(iter45)) {
            iter45 = this.values[iter45];
            output.writeByte(iter45);
          }
        }
        output.writeListEnd();
        output.writeFieldEnd();
      }
      if (this.nulls !== null && this.nulls !== void 0) {
        output.writeFieldBegin("nulls", Thrift.Type.STRING, 2);
        output.writeBinary(this.nulls);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TI16Column = module2.exports.TI16Column = function(args) {
      this.values = null;
      this.nulls = null;
      if (args) {
        if (args.values !== void 0 && args.values !== null) {
          this.values = Thrift.copyList(args.values, [null]);
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field values is unset!");
        }
        if (args.nulls !== void 0 && args.nulls !== null) {
          this.nulls = args.nulls;
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field nulls is unset!");
        }
      }
    };
    TI16Column.prototype = {};
    TI16Column.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.LIST) {
              this.values = [];
              var _rtmp347 = input.readListBegin();
              var _size46 = _rtmp347.size || 0;
              for (var _i48 = 0; _i48 < _size46; ++_i48) {
                var elem49 = null;
                elem49 = input.readI16();
                this.values.push(elem49);
              }
              input.readListEnd();
            } else {
              input.skip(ftype);
            }
            break;
          case 2:
            if (ftype == Thrift.Type.STRING) {
              this.nulls = input.readBinary();
            } else {
              input.skip(ftype);
            }
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TI16Column.prototype.write = function(output) {
      output.writeStructBegin("TI16Column");
      if (this.values !== null && this.values !== void 0) {
        output.writeFieldBegin("values", Thrift.Type.LIST, 1);
        output.writeListBegin(Thrift.Type.I16, this.values.length);
        for (var iter50 in this.values) {
          if (this.values.hasOwnProperty(iter50)) {
            iter50 = this.values[iter50];
            output.writeI16(iter50);
          }
        }
        output.writeListEnd();
        output.writeFieldEnd();
      }
      if (this.nulls !== null && this.nulls !== void 0) {
        output.writeFieldBegin("nulls", Thrift.Type.STRING, 2);
        output.writeBinary(this.nulls);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TI32Column = module2.exports.TI32Column = function(args) {
      this.values = null;
      this.nulls = null;
      if (args) {
        if (args.values !== void 0 && args.values !== null) {
          this.values = Thrift.copyList(args.values, [null]);
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field values is unset!");
        }
        if (args.nulls !== void 0 && args.nulls !== null) {
          this.nulls = args.nulls;
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field nulls is unset!");
        }
      }
    };
    TI32Column.prototype = {};
    TI32Column.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.LIST) {
              this.values = [];
              var _rtmp352 = input.readListBegin();
              var _size51 = _rtmp352.size || 0;
              for (var _i53 = 0; _i53 < _size51; ++_i53) {
                var elem54 = null;
                elem54 = input.readI32();
                this.values.push(elem54);
              }
              input.readListEnd();
            } else {
              input.skip(ftype);
            }
            break;
          case 2:
            if (ftype == Thrift.Type.STRING) {
              this.nulls = input.readBinary();
            } else {
              input.skip(ftype);
            }
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TI32Column.prototype.write = function(output) {
      output.writeStructBegin("TI32Column");
      if (this.values !== null && this.values !== void 0) {
        output.writeFieldBegin("values", Thrift.Type.LIST, 1);
        output.writeListBegin(Thrift.Type.I32, this.values.length);
        for (var iter55 in this.values) {
          if (this.values.hasOwnProperty(iter55)) {
            iter55 = this.values[iter55];
            output.writeI32(iter55);
          }
        }
        output.writeListEnd();
        output.writeFieldEnd();
      }
      if (this.nulls !== null && this.nulls !== void 0) {
        output.writeFieldBegin("nulls", Thrift.Type.STRING, 2);
        output.writeBinary(this.nulls);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TI64Column = module2.exports.TI64Column = function(args) {
      this.values = null;
      this.nulls = null;
      if (args) {
        if (args.values !== void 0 && args.values !== null) {
          this.values = Thrift.copyList(args.values, [null]);
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field values is unset!");
        }
        if (args.nulls !== void 0 && args.nulls !== null) {
          this.nulls = args.nulls;
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field nulls is unset!");
        }
      }
    };
    TI64Column.prototype = {};
    TI64Column.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.LIST) {
              this.values = [];
              var _rtmp357 = input.readListBegin();
              var _size56 = _rtmp357.size || 0;
              for (var _i58 = 0; _i58 < _size56; ++_i58) {
                var elem59 = null;
                elem59 = input.readI64();
                this.values.push(elem59);
              }
              input.readListEnd();
            } else {
              input.skip(ftype);
            }
            break;
          case 2:
            if (ftype == Thrift.Type.STRING) {
              this.nulls = input.readBinary();
            } else {
              input.skip(ftype);
            }
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TI64Column.prototype.write = function(output) {
      output.writeStructBegin("TI64Column");
      if (this.values !== null && this.values !== void 0) {
        output.writeFieldBegin("values", Thrift.Type.LIST, 1);
        output.writeListBegin(Thrift.Type.I64, this.values.length);
        for (var iter60 in this.values) {
          if (this.values.hasOwnProperty(iter60)) {
            iter60 = this.values[iter60];
            output.writeI64(iter60);
          }
        }
        output.writeListEnd();
        output.writeFieldEnd();
      }
      if (this.nulls !== null && this.nulls !== void 0) {
        output.writeFieldBegin("nulls", Thrift.Type.STRING, 2);
        output.writeBinary(this.nulls);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TDoubleColumn = module2.exports.TDoubleColumn = function(args) {
      this.values = null;
      this.nulls = null;
      if (args) {
        if (args.values !== void 0 && args.values !== null) {
          this.values = Thrift.copyList(args.values, [null]);
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field values is unset!");
        }
        if (args.nulls !== void 0 && args.nulls !== null) {
          this.nulls = args.nulls;
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field nulls is unset!");
        }
      }
    };
    TDoubleColumn.prototype = {};
    TDoubleColumn.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.LIST) {
              this.values = [];
              var _rtmp362 = input.readListBegin();
              var _size61 = _rtmp362.size || 0;
              for (var _i63 = 0; _i63 < _size61; ++_i63) {
                var elem64 = null;
                elem64 = input.readDouble();
                this.values.push(elem64);
              }
              input.readListEnd();
            } else {
              input.skip(ftype);
            }
            break;
          case 2:
            if (ftype == Thrift.Type.STRING) {
              this.nulls = input.readBinary();
            } else {
              input.skip(ftype);
            }
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TDoubleColumn.prototype.write = function(output) {
      output.writeStructBegin("TDoubleColumn");
      if (this.values !== null && this.values !== void 0) {
        output.writeFieldBegin("values", Thrift.Type.LIST, 1);
        output.writeListBegin(Thrift.Type.DOUBLE, this.values.length);
        for (var iter65 in this.values) {
          if (this.values.hasOwnProperty(iter65)) {
            iter65 = this.values[iter65];
            output.writeDouble(iter65);
          }
        }
        output.writeListEnd();
        output.writeFieldEnd();
      }
      if (this.nulls !== null && this.nulls !== void 0) {
        output.writeFieldBegin("nulls", Thrift.Type.STRING, 2);
        output.writeBinary(this.nulls);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TStringColumn = module2.exports.TStringColumn = function(args) {
      this.values = null;
      this.nulls = null;
      if (args) {
        if (args.values !== void 0 && args.values !== null) {
          this.values = Thrift.copyList(args.values, [null]);
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field values is unset!");
        }
        if (args.nulls !== void 0 && args.nulls !== null) {
          this.nulls = args.nulls;
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field nulls is unset!");
        }
      }
    };
    TStringColumn.prototype = {};
    TStringColumn.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.LIST) {
              this.values = [];
              var _rtmp367 = input.readListBegin();
              var _size66 = _rtmp367.size || 0;
              for (var _i68 = 0; _i68 < _size66; ++_i68) {
                var elem69 = null;
                elem69 = input.readString();
                this.values.push(elem69);
              }
              input.readListEnd();
            } else {
              input.skip(ftype);
            }
            break;
          case 2:
            if (ftype == Thrift.Type.STRING) {
              this.nulls = input.readBinary();
            } else {
              input.skip(ftype);
            }
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TStringColumn.prototype.write = function(output) {
      output.writeStructBegin("TStringColumn");
      if (this.values !== null && this.values !== void 0) {
        output.writeFieldBegin("values", Thrift.Type.LIST, 1);
        output.writeListBegin(Thrift.Type.STRING, this.values.length);
        for (var iter70 in this.values) {
          if (this.values.hasOwnProperty(iter70)) {
            iter70 = this.values[iter70];
            output.writeString(iter70);
          }
        }
        output.writeListEnd();
        output.writeFieldEnd();
      }
      if (this.nulls !== null && this.nulls !== void 0) {
        output.writeFieldBegin("nulls", Thrift.Type.STRING, 2);
        output.writeBinary(this.nulls);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TBinaryColumn = module2.exports.TBinaryColumn = function(args) {
      this.values = null;
      this.nulls = null;
      if (args) {
        if (args.values !== void 0 && args.values !== null) {
          this.values = Thrift.copyList(args.values, [null]);
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field values is unset!");
        }
        if (args.nulls !== void 0 && args.nulls !== null) {
          this.nulls = args.nulls;
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field nulls is unset!");
        }
      }
    };
    TBinaryColumn.prototype = {};
    TBinaryColumn.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.LIST) {
              this.values = [];
              var _rtmp372 = input.readListBegin();
              var _size71 = _rtmp372.size || 0;
              for (var _i73 = 0; _i73 < _size71; ++_i73) {
                var elem74 = null;
                elem74 = input.readBinary();
                this.values.push(elem74);
              }
              input.readListEnd();
            } else {
              input.skip(ftype);
            }
            break;
          case 2:
            if (ftype == Thrift.Type.STRING) {
              this.nulls = input.readBinary();
            } else {
              input.skip(ftype);
            }
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TBinaryColumn.prototype.write = function(output) {
      output.writeStructBegin("TBinaryColumn");
      if (this.values !== null && this.values !== void 0) {
        output.writeFieldBegin("values", Thrift.Type.LIST, 1);
        output.writeListBegin(Thrift.Type.STRING, this.values.length);
        for (var iter75 in this.values) {
          if (this.values.hasOwnProperty(iter75)) {
            iter75 = this.values[iter75];
            output.writeBinary(iter75);
          }
        }
        output.writeListEnd();
        output.writeFieldEnd();
      }
      if (this.nulls !== null && this.nulls !== void 0) {
        output.writeFieldBegin("nulls", Thrift.Type.STRING, 2);
        output.writeBinary(this.nulls);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TColumn = module2.exports.TColumn = function(args) {
      this.boolVal = null;
      this.byteVal = null;
      this.i16Val = null;
      this.i32Val = null;
      this.i64Val = null;
      this.doubleVal = null;
      this.stringVal = null;
      this.binaryVal = null;
      if (args) {
        if (args.boolVal !== void 0 && args.boolVal !== null) {
          this.boolVal = new ttypes.TBoolColumn(args.boolVal);
        }
        if (args.byteVal !== void 0 && args.byteVal !== null) {
          this.byteVal = new ttypes.TByteColumn(args.byteVal);
        }
        if (args.i16Val !== void 0 && args.i16Val !== null) {
          this.i16Val = new ttypes.TI16Column(args.i16Val);
        }
        if (args.i32Val !== void 0 && args.i32Val !== null) {
          this.i32Val = new ttypes.TI32Column(args.i32Val);
        }
        if (args.i64Val !== void 0 && args.i64Val !== null) {
          this.i64Val = new ttypes.TI64Column(args.i64Val);
        }
        if (args.doubleVal !== void 0 && args.doubleVal !== null) {
          this.doubleVal = new ttypes.TDoubleColumn(args.doubleVal);
        }
        if (args.stringVal !== void 0 && args.stringVal !== null) {
          this.stringVal = new ttypes.TStringColumn(args.stringVal);
        }
        if (args.binaryVal !== void 0 && args.binaryVal !== null) {
          this.binaryVal = new ttypes.TBinaryColumn(args.binaryVal);
        }
      }
    };
    TColumn.prototype = {};
    TColumn.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.boolVal = new ttypes.TBoolColumn();
              this.boolVal.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 2:
            if (ftype == Thrift.Type.STRUCT) {
              this.byteVal = new ttypes.TByteColumn();
              this.byteVal.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 3:
            if (ftype == Thrift.Type.STRUCT) {
              this.i16Val = new ttypes.TI16Column();
              this.i16Val.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 4:
            if (ftype == Thrift.Type.STRUCT) {
              this.i32Val = new ttypes.TI32Column();
              this.i32Val.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 5:
            if (ftype == Thrift.Type.STRUCT) {
              this.i64Val = new ttypes.TI64Column();
              this.i64Val.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 6:
            if (ftype == Thrift.Type.STRUCT) {
              this.doubleVal = new ttypes.TDoubleColumn();
              this.doubleVal.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 7:
            if (ftype == Thrift.Type.STRUCT) {
              this.stringVal = new ttypes.TStringColumn();
              this.stringVal.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 8:
            if (ftype == Thrift.Type.STRUCT) {
              this.binaryVal = new ttypes.TBinaryColumn();
              this.binaryVal.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TColumn.prototype.write = function(output) {
      output.writeStructBegin("TColumn");
      if (this.boolVal !== null && this.boolVal !== void 0) {
        output.writeFieldBegin("boolVal", Thrift.Type.STRUCT, 1);
        this.boolVal.write(output);
        output.writeFieldEnd();
      }
      if (this.byteVal !== null && this.byteVal !== void 0) {
        output.writeFieldBegin("byteVal", Thrift.Type.STRUCT, 2);
        this.byteVal.write(output);
        output.writeFieldEnd();
      }
      if (this.i16Val !== null && this.i16Val !== void 0) {
        output.writeFieldBegin("i16Val", Thrift.Type.STRUCT, 3);
        this.i16Val.write(output);
        output.writeFieldEnd();
      }
      if (this.i32Val !== null && this.i32Val !== void 0) {
        output.writeFieldBegin("i32Val", Thrift.Type.STRUCT, 4);
        this.i32Val.write(output);
        output.writeFieldEnd();
      }
      if (this.i64Val !== null && this.i64Val !== void 0) {
        output.writeFieldBegin("i64Val", Thrift.Type.STRUCT, 5);
        this.i64Val.write(output);
        output.writeFieldEnd();
      }
      if (this.doubleVal !== null && this.doubleVal !== void 0) {
        output.writeFieldBegin("doubleVal", Thrift.Type.STRUCT, 6);
        this.doubleVal.write(output);
        output.writeFieldEnd();
      }
      if (this.stringVal !== null && this.stringVal !== void 0) {
        output.writeFieldBegin("stringVal", Thrift.Type.STRUCT, 7);
        this.stringVal.write(output);
        output.writeFieldEnd();
      }
      if (this.binaryVal !== null && this.binaryVal !== void 0) {
        output.writeFieldBegin("binaryVal", Thrift.Type.STRUCT, 8);
        this.binaryVal.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TRowSet = module2.exports.TRowSet = function(args) {
      this.startRowOffset = null;
      this.rows = null;
      this.columns = null;
      this.binaryColumns = null;
      this.columnCount = null;
      if (args) {
        if (args.startRowOffset !== void 0 && args.startRowOffset !== null) {
          this.startRowOffset = args.startRowOffset;
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field startRowOffset is unset!");
        }
        if (args.rows !== void 0 && args.rows !== null) {
          this.rows = Thrift.copyList(args.rows, [ttypes.TRow]);
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field rows is unset!");
        }
        if (args.columns !== void 0 && args.columns !== null) {
          this.columns = Thrift.copyList(args.columns, [ttypes.TColumn]);
        }
        if (args.binaryColumns !== void 0 && args.binaryColumns !== null) {
          this.binaryColumns = args.binaryColumns;
        }
        if (args.columnCount !== void 0 && args.columnCount !== null) {
          this.columnCount = args.columnCount;
        }
      }
    };
    TRowSet.prototype = {};
    TRowSet.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.I64) {
              this.startRowOffset = input.readI64();
            } else {
              input.skip(ftype);
            }
            break;
          case 2:
            if (ftype == Thrift.Type.LIST) {
              this.rows = [];
              var _rtmp377 = input.readListBegin();
              var _size76 = _rtmp377.size || 0;
              for (var _i78 = 0; _i78 < _size76; ++_i78) {
                var elem79 = null;
                elem79 = new ttypes.TRow();
                elem79.read(input);
                this.rows.push(elem79);
              }
              input.readListEnd();
            } else {
              input.skip(ftype);
            }
            break;
          case 3:
            if (ftype == Thrift.Type.LIST) {
              this.columns = [];
              var _rtmp381 = input.readListBegin();
              var _size80 = _rtmp381.size || 0;
              for (var _i82 = 0; _i82 < _size80; ++_i82) {
                var elem83 = null;
                elem83 = new ttypes.TColumn();
                elem83.read(input);
                this.columns.push(elem83);
              }
              input.readListEnd();
            } else {
              input.skip(ftype);
            }
            break;
          case 4:
            if (ftype == Thrift.Type.STRING) {
              this.binaryColumns = input.readBinary();
            } else {
              input.skip(ftype);
            }
            break;
          case 5:
            if (ftype == Thrift.Type.I32) {
              this.columnCount = input.readI32();
            } else {
              input.skip(ftype);
            }
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TRowSet.prototype.write = function(output) {
      output.writeStructBegin("TRowSet");
      if (this.startRowOffset !== null && this.startRowOffset !== void 0) {
        output.writeFieldBegin("startRowOffset", Thrift.Type.I64, 1);
        output.writeI64(this.startRowOffset);
        output.writeFieldEnd();
      }
      if (this.rows !== null && this.rows !== void 0) {
        output.writeFieldBegin("rows", Thrift.Type.LIST, 2);
        output.writeListBegin(Thrift.Type.STRUCT, this.rows.length);
        for (var iter84 in this.rows) {
          if (this.rows.hasOwnProperty(iter84)) {
            iter84 = this.rows[iter84];
            iter84.write(output);
          }
        }
        output.writeListEnd();
        output.writeFieldEnd();
      }
      if (this.columns !== null && this.columns !== void 0) {
        output.writeFieldBegin("columns", Thrift.Type.LIST, 3);
        output.writeListBegin(Thrift.Type.STRUCT, this.columns.length);
        for (var iter85 in this.columns) {
          if (this.columns.hasOwnProperty(iter85)) {
            iter85 = this.columns[iter85];
            iter85.write(output);
          }
        }
        output.writeListEnd();
        output.writeFieldEnd();
      }
      if (this.binaryColumns !== null && this.binaryColumns !== void 0) {
        output.writeFieldBegin("binaryColumns", Thrift.Type.STRING, 4);
        output.writeBinary(this.binaryColumns);
        output.writeFieldEnd();
      }
      if (this.columnCount !== null && this.columnCount !== void 0) {
        output.writeFieldBegin("columnCount", Thrift.Type.I32, 5);
        output.writeI32(this.columnCount);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TStatus = module2.exports.TStatus = function(args) {
      this.statusCode = null;
      this.infoMessages = null;
      this.sqlState = null;
      this.errorCode = null;
      this.errorMessage = null;
      if (args) {
        if (args.statusCode !== void 0 && args.statusCode !== null) {
          this.statusCode = args.statusCode;
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field statusCode is unset!");
        }
        if (args.infoMessages !== void 0 && args.infoMessages !== null) {
          this.infoMessages = Thrift.copyList(args.infoMessages, [null]);
        }
        if (args.sqlState !== void 0 && args.sqlState !== null) {
          this.sqlState = args.sqlState;
        }
        if (args.errorCode !== void 0 && args.errorCode !== null) {
          this.errorCode = args.errorCode;
        }
        if (args.errorMessage !== void 0 && args.errorMessage !== null) {
          this.errorMessage = args.errorMessage;
        }
      }
    };
    TStatus.prototype = {};
    TStatus.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.I32) {
              this.statusCode = input.readI32();
            } else {
              input.skip(ftype);
            }
            break;
          case 2:
            if (ftype == Thrift.Type.LIST) {
              this.infoMessages = [];
              var _rtmp387 = input.readListBegin();
              var _size86 = _rtmp387.size || 0;
              for (var _i88 = 0; _i88 < _size86; ++_i88) {
                var elem89 = null;
                elem89 = input.readString();
                this.infoMessages.push(elem89);
              }
              input.readListEnd();
            } else {
              input.skip(ftype);
            }
            break;
          case 3:
            if (ftype == Thrift.Type.STRING) {
              this.sqlState = input.readString();
            } else {
              input.skip(ftype);
            }
            break;
          case 4:
            if (ftype == Thrift.Type.I32) {
              this.errorCode = input.readI32();
            } else {
              input.skip(ftype);
            }
            break;
          case 5:
            if (ftype == Thrift.Type.STRING) {
              this.errorMessage = input.readString();
            } else {
              input.skip(ftype);
            }
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TStatus.prototype.write = function(output) {
      output.writeStructBegin("TStatus");
      if (this.statusCode !== null && this.statusCode !== void 0) {
        output.writeFieldBegin("statusCode", Thrift.Type.I32, 1);
        output.writeI32(this.statusCode);
        output.writeFieldEnd();
      }
      if (this.infoMessages !== null && this.infoMessages !== void 0) {
        output.writeFieldBegin("infoMessages", Thrift.Type.LIST, 2);
        output.writeListBegin(Thrift.Type.STRING, this.infoMessages.length);
        for (var iter90 in this.infoMessages) {
          if (this.infoMessages.hasOwnProperty(iter90)) {
            iter90 = this.infoMessages[iter90];
            output.writeString(iter90);
          }
        }
        output.writeListEnd();
        output.writeFieldEnd();
      }
      if (this.sqlState !== null && this.sqlState !== void 0) {
        output.writeFieldBegin("sqlState", Thrift.Type.STRING, 3);
        output.writeString(this.sqlState);
        output.writeFieldEnd();
      }
      if (this.errorCode !== null && this.errorCode !== void 0) {
        output.writeFieldBegin("errorCode", Thrift.Type.I32, 4);
        output.writeI32(this.errorCode);
        output.writeFieldEnd();
      }
      if (this.errorMessage !== null && this.errorMessage !== void 0) {
        output.writeFieldBegin("errorMessage", Thrift.Type.STRING, 5);
        output.writeString(this.errorMessage);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var THandleIdentifier = module2.exports.THandleIdentifier = function(args) {
      this.guid = null;
      this.secret = null;
      if (args) {
        if (args.guid !== void 0 && args.guid !== null) {
          this.guid = args.guid;
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field guid is unset!");
        }
        if (args.secret !== void 0 && args.secret !== null) {
          this.secret = args.secret;
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field secret is unset!");
        }
      }
    };
    THandleIdentifier.prototype = {};
    THandleIdentifier.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRING) {
              this.guid = input.readBinary();
            } else {
              input.skip(ftype);
            }
            break;
          case 2:
            if (ftype == Thrift.Type.STRING) {
              this.secret = input.readBinary();
            } else {
              input.skip(ftype);
            }
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    THandleIdentifier.prototype.write = function(output) {
      output.writeStructBegin("THandleIdentifier");
      if (this.guid !== null && this.guid !== void 0) {
        output.writeFieldBegin("guid", Thrift.Type.STRING, 1);
        output.writeBinary(this.guid);
        output.writeFieldEnd();
      }
      if (this.secret !== null && this.secret !== void 0) {
        output.writeFieldBegin("secret", Thrift.Type.STRING, 2);
        output.writeBinary(this.secret);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TSessionHandle = module2.exports.TSessionHandle = function(args) {
      this.sessionId = null;
      if (args) {
        if (args.sessionId !== void 0 && args.sessionId !== null) {
          this.sessionId = new ttypes.THandleIdentifier(args.sessionId);
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field sessionId is unset!");
        }
      }
    };
    TSessionHandle.prototype = {};
    TSessionHandle.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.sessionId = new ttypes.THandleIdentifier();
              this.sessionId.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TSessionHandle.prototype.write = function(output) {
      output.writeStructBegin("TSessionHandle");
      if (this.sessionId !== null && this.sessionId !== void 0) {
        output.writeFieldBegin("sessionId", Thrift.Type.STRUCT, 1);
        this.sessionId.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TOperationHandle = module2.exports.TOperationHandle = function(args) {
      this.operationId = null;
      this.operationType = null;
      this.hasResultSet = null;
      this.modifiedRowCount = null;
      if (args) {
        if (args.operationId !== void 0 && args.operationId !== null) {
          this.operationId = new ttypes.THandleIdentifier(args.operationId);
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field operationId is unset!");
        }
        if (args.operationType !== void 0 && args.operationType !== null) {
          this.operationType = args.operationType;
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field operationType is unset!");
        }
        if (args.hasResultSet !== void 0 && args.hasResultSet !== null) {
          this.hasResultSet = args.hasResultSet;
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field hasResultSet is unset!");
        }
        if (args.modifiedRowCount !== void 0 && args.modifiedRowCount !== null) {
          this.modifiedRowCount = args.modifiedRowCount;
        }
      }
    };
    TOperationHandle.prototype = {};
    TOperationHandle.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.operationId = new ttypes.THandleIdentifier();
              this.operationId.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 2:
            if (ftype == Thrift.Type.I32) {
              this.operationType = input.readI32();
            } else {
              input.skip(ftype);
            }
            break;
          case 3:
            if (ftype == Thrift.Type.BOOL) {
              this.hasResultSet = input.readBool();
            } else {
              input.skip(ftype);
            }
            break;
          case 4:
            if (ftype == Thrift.Type.DOUBLE) {
              this.modifiedRowCount = input.readDouble();
            } else {
              input.skip(ftype);
            }
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TOperationHandle.prototype.write = function(output) {
      output.writeStructBegin("TOperationHandle");
      if (this.operationId !== null && this.operationId !== void 0) {
        output.writeFieldBegin("operationId", Thrift.Type.STRUCT, 1);
        this.operationId.write(output);
        output.writeFieldEnd();
      }
      if (this.operationType !== null && this.operationType !== void 0) {
        output.writeFieldBegin("operationType", Thrift.Type.I32, 2);
        output.writeI32(this.operationType);
        output.writeFieldEnd();
      }
      if (this.hasResultSet !== null && this.hasResultSet !== void 0) {
        output.writeFieldBegin("hasResultSet", Thrift.Type.BOOL, 3);
        output.writeBool(this.hasResultSet);
        output.writeFieldEnd();
      }
      if (this.modifiedRowCount !== null && this.modifiedRowCount !== void 0) {
        output.writeFieldBegin("modifiedRowCount", Thrift.Type.DOUBLE, 4);
        output.writeDouble(this.modifiedRowCount);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TOpenSessionReq = module2.exports.TOpenSessionReq = function(args) {
      this.client_protocol = 9;
      this.username = null;
      this.password = null;
      this.configuration = null;
      if (args) {
        if (args.client_protocol !== void 0 && args.client_protocol !== null) {
          this.client_protocol = args.client_protocol;
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field client_protocol is unset!");
        }
        if (args.username !== void 0 && args.username !== null) {
          this.username = args.username;
        }
        if (args.password !== void 0 && args.password !== null) {
          this.password = args.password;
        }
        if (args.configuration !== void 0 && args.configuration !== null) {
          this.configuration = Thrift.copyMap(args.configuration, [null]);
        }
      }
    };
    TOpenSessionReq.prototype = {};
    TOpenSessionReq.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.I32) {
              this.client_protocol = input.readI32();
            } else {
              input.skip(ftype);
            }
            break;
          case 2:
            if (ftype == Thrift.Type.STRING) {
              this.username = input.readString();
            } else {
              input.skip(ftype);
            }
            break;
          case 3:
            if (ftype == Thrift.Type.STRING) {
              this.password = input.readString();
            } else {
              input.skip(ftype);
            }
            break;
          case 4:
            if (ftype == Thrift.Type.MAP) {
              this.configuration = {};
              var _rtmp392 = input.readMapBegin();
              var _size91 = _rtmp392.size || 0;
              for (var _i93 = 0; _i93 < _size91; ++_i93) {
                var key94 = null;
                var val95 = null;
                key94 = input.readString();
                val95 = input.readString();
                this.configuration[key94] = val95;
              }
              input.readMapEnd();
            } else {
              input.skip(ftype);
            }
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TOpenSessionReq.prototype.write = function(output) {
      output.writeStructBegin("TOpenSessionReq");
      if (this.client_protocol !== null && this.client_protocol !== void 0) {
        output.writeFieldBegin("client_protocol", Thrift.Type.I32, 1);
        output.writeI32(this.client_protocol);
        output.writeFieldEnd();
      }
      if (this.username !== null && this.username !== void 0) {
        output.writeFieldBegin("username", Thrift.Type.STRING, 2);
        output.writeString(this.username);
        output.writeFieldEnd();
      }
      if (this.password !== null && this.password !== void 0) {
        output.writeFieldBegin("password", Thrift.Type.STRING, 3);
        output.writeString(this.password);
        output.writeFieldEnd();
      }
      if (this.configuration !== null && this.configuration !== void 0) {
        output.writeFieldBegin("configuration", Thrift.Type.MAP, 4);
        output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRING, Thrift.objectLength(this.configuration));
        for (var kiter96 in this.configuration) {
          if (this.configuration.hasOwnProperty(kiter96)) {
            var viter97 = this.configuration[kiter96];
            output.writeString(kiter96);
            output.writeString(viter97);
          }
        }
        output.writeMapEnd();
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TOpenSessionResp = module2.exports.TOpenSessionResp = function(args) {
      this.status = null;
      this.serverProtocolVersion = 9;
      this.sessionHandle = null;
      this.configuration = null;
      if (args) {
        if (args.status !== void 0 && args.status !== null) {
          this.status = new ttypes.TStatus(args.status);
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field status is unset!");
        }
        if (args.serverProtocolVersion !== void 0 && args.serverProtocolVersion !== null) {
          this.serverProtocolVersion = args.serverProtocolVersion;
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field serverProtocolVersion is unset!");
        }
        if (args.sessionHandle !== void 0 && args.sessionHandle !== null) {
          this.sessionHandle = new ttypes.TSessionHandle(args.sessionHandle);
        }
        if (args.configuration !== void 0 && args.configuration !== null) {
          this.configuration = Thrift.copyMap(args.configuration, [null]);
        }
      }
    };
    TOpenSessionResp.prototype = {};
    TOpenSessionResp.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.status = new ttypes.TStatus();
              this.status.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 2:
            if (ftype == Thrift.Type.I32) {
              this.serverProtocolVersion = input.readI32();
            } else {
              input.skip(ftype);
            }
            break;
          case 3:
            if (ftype == Thrift.Type.STRUCT) {
              this.sessionHandle = new ttypes.TSessionHandle();
              this.sessionHandle.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 4:
            if (ftype == Thrift.Type.MAP) {
              this.configuration = {};
              var _rtmp399 = input.readMapBegin();
              var _size98 = _rtmp399.size || 0;
              for (var _i100 = 0; _i100 < _size98; ++_i100) {
                var key101 = null;
                var val102 = null;
                key101 = input.readString();
                val102 = input.readString();
                this.configuration[key101] = val102;
              }
              input.readMapEnd();
            } else {
              input.skip(ftype);
            }
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TOpenSessionResp.prototype.write = function(output) {
      output.writeStructBegin("TOpenSessionResp");
      if (this.status !== null && this.status !== void 0) {
        output.writeFieldBegin("status", Thrift.Type.STRUCT, 1);
        this.status.write(output);
        output.writeFieldEnd();
      }
      if (this.serverProtocolVersion !== null && this.serverProtocolVersion !== void 0) {
        output.writeFieldBegin("serverProtocolVersion", Thrift.Type.I32, 2);
        output.writeI32(this.serverProtocolVersion);
        output.writeFieldEnd();
      }
      if (this.sessionHandle !== null && this.sessionHandle !== void 0) {
        output.writeFieldBegin("sessionHandle", Thrift.Type.STRUCT, 3);
        this.sessionHandle.write(output);
        output.writeFieldEnd();
      }
      if (this.configuration !== null && this.configuration !== void 0) {
        output.writeFieldBegin("configuration", Thrift.Type.MAP, 4);
        output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRING, Thrift.objectLength(this.configuration));
        for (var kiter103 in this.configuration) {
          if (this.configuration.hasOwnProperty(kiter103)) {
            var viter104 = this.configuration[kiter103];
            output.writeString(kiter103);
            output.writeString(viter104);
          }
        }
        output.writeMapEnd();
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TSetClientInfoReq = module2.exports.TSetClientInfoReq = function(args) {
      this.sessionHandle = null;
      this.configuration = null;
      if (args) {
        if (args.sessionHandle !== void 0 && args.sessionHandle !== null) {
          this.sessionHandle = new ttypes.TSessionHandle(args.sessionHandle);
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field sessionHandle is unset!");
        }
        if (args.configuration !== void 0 && args.configuration !== null) {
          this.configuration = Thrift.copyMap(args.configuration, [null]);
        }
      }
    };
    TSetClientInfoReq.prototype = {};
    TSetClientInfoReq.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.sessionHandle = new ttypes.TSessionHandle();
              this.sessionHandle.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 2:
            if (ftype == Thrift.Type.MAP) {
              this.configuration = {};
              var _rtmp3106 = input.readMapBegin();
              var _size105 = _rtmp3106.size || 0;
              for (var _i107 = 0; _i107 < _size105; ++_i107) {
                var key108 = null;
                var val109 = null;
                key108 = input.readString();
                val109 = input.readString();
                this.configuration[key108] = val109;
              }
              input.readMapEnd();
            } else {
              input.skip(ftype);
            }
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TSetClientInfoReq.prototype.write = function(output) {
      output.writeStructBegin("TSetClientInfoReq");
      if (this.sessionHandle !== null && this.sessionHandle !== void 0) {
        output.writeFieldBegin("sessionHandle", Thrift.Type.STRUCT, 1);
        this.sessionHandle.write(output);
        output.writeFieldEnd();
      }
      if (this.configuration !== null && this.configuration !== void 0) {
        output.writeFieldBegin("configuration", Thrift.Type.MAP, 2);
        output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRING, Thrift.objectLength(this.configuration));
        for (var kiter110 in this.configuration) {
          if (this.configuration.hasOwnProperty(kiter110)) {
            var viter111 = this.configuration[kiter110];
            output.writeString(kiter110);
            output.writeString(viter111);
          }
        }
        output.writeMapEnd();
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TSetClientInfoResp = module2.exports.TSetClientInfoResp = function(args) {
      this.status = null;
      if (args) {
        if (args.status !== void 0 && args.status !== null) {
          this.status = new ttypes.TStatus(args.status);
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field status is unset!");
        }
      }
    };
    TSetClientInfoResp.prototype = {};
    TSetClientInfoResp.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.status = new ttypes.TStatus();
              this.status.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TSetClientInfoResp.prototype.write = function(output) {
      output.writeStructBegin("TSetClientInfoResp");
      if (this.status !== null && this.status !== void 0) {
        output.writeFieldBegin("status", Thrift.Type.STRUCT, 1);
        this.status.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TCloseSessionReq = module2.exports.TCloseSessionReq = function(args) {
      this.sessionHandle = null;
      if (args) {
        if (args.sessionHandle !== void 0 && args.sessionHandle !== null) {
          this.sessionHandle = new ttypes.TSessionHandle(args.sessionHandle);
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field sessionHandle is unset!");
        }
      }
    };
    TCloseSessionReq.prototype = {};
    TCloseSessionReq.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.sessionHandle = new ttypes.TSessionHandle();
              this.sessionHandle.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TCloseSessionReq.prototype.write = function(output) {
      output.writeStructBegin("TCloseSessionReq");
      if (this.sessionHandle !== null && this.sessionHandle !== void 0) {
        output.writeFieldBegin("sessionHandle", Thrift.Type.STRUCT, 1);
        this.sessionHandle.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TCloseSessionResp = module2.exports.TCloseSessionResp = function(args) {
      this.status = null;
      if (args) {
        if (args.status !== void 0 && args.status !== null) {
          this.status = new ttypes.TStatus(args.status);
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field status is unset!");
        }
      }
    };
    TCloseSessionResp.prototype = {};
    TCloseSessionResp.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.status = new ttypes.TStatus();
              this.status.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TCloseSessionResp.prototype.write = function(output) {
      output.writeStructBegin("TCloseSessionResp");
      if (this.status !== null && this.status !== void 0) {
        output.writeFieldBegin("status", Thrift.Type.STRUCT, 1);
        this.status.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TGetInfoValue = module2.exports.TGetInfoValue = function(args) {
      this.stringValue = null;
      this.smallIntValue = null;
      this.integerBitmask = null;
      this.integerFlag = null;
      this.binaryValue = null;
      this.lenValue = null;
      if (args) {
        if (args.stringValue !== void 0 && args.stringValue !== null) {
          this.stringValue = args.stringValue;
        }
        if (args.smallIntValue !== void 0 && args.smallIntValue !== null) {
          this.smallIntValue = args.smallIntValue;
        }
        if (args.integerBitmask !== void 0 && args.integerBitmask !== null) {
          this.integerBitmask = args.integerBitmask;
        }
        if (args.integerFlag !== void 0 && args.integerFlag !== null) {
          this.integerFlag = args.integerFlag;
        }
        if (args.binaryValue !== void 0 && args.binaryValue !== null) {
          this.binaryValue = args.binaryValue;
        }
        if (args.lenValue !== void 0 && args.lenValue !== null) {
          this.lenValue = args.lenValue;
        }
      }
    };
    TGetInfoValue.prototype = {};
    TGetInfoValue.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRING) {
              this.stringValue = input.readString();
            } else {
              input.skip(ftype);
            }
            break;
          case 2:
            if (ftype == Thrift.Type.I16) {
              this.smallIntValue = input.readI16();
            } else {
              input.skip(ftype);
            }
            break;
          case 3:
            if (ftype == Thrift.Type.I32) {
              this.integerBitmask = input.readI32();
            } else {
              input.skip(ftype);
            }
            break;
          case 4:
            if (ftype == Thrift.Type.I32) {
              this.integerFlag = input.readI32();
            } else {
              input.skip(ftype);
            }
            break;
          case 5:
            if (ftype == Thrift.Type.I32) {
              this.binaryValue = input.readI32();
            } else {
              input.skip(ftype);
            }
            break;
          case 6:
            if (ftype == Thrift.Type.I64) {
              this.lenValue = input.readI64();
            } else {
              input.skip(ftype);
            }
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TGetInfoValue.prototype.write = function(output) {
      output.writeStructBegin("TGetInfoValue");
      if (this.stringValue !== null && this.stringValue !== void 0) {
        output.writeFieldBegin("stringValue", Thrift.Type.STRING, 1);
        output.writeString(this.stringValue);
        output.writeFieldEnd();
      }
      if (this.smallIntValue !== null && this.smallIntValue !== void 0) {
        output.writeFieldBegin("smallIntValue", Thrift.Type.I16, 2);
        output.writeI16(this.smallIntValue);
        output.writeFieldEnd();
      }
      if (this.integerBitmask !== null && this.integerBitmask !== void 0) {
        output.writeFieldBegin("integerBitmask", Thrift.Type.I32, 3);
        output.writeI32(this.integerBitmask);
        output.writeFieldEnd();
      }
      if (this.integerFlag !== null && this.integerFlag !== void 0) {
        output.writeFieldBegin("integerFlag", Thrift.Type.I32, 4);
        output.writeI32(this.integerFlag);
        output.writeFieldEnd();
      }
      if (this.binaryValue !== null && this.binaryValue !== void 0) {
        output.writeFieldBegin("binaryValue", Thrift.Type.I32, 5);
        output.writeI32(this.binaryValue);
        output.writeFieldEnd();
      }
      if (this.lenValue !== null && this.lenValue !== void 0) {
        output.writeFieldBegin("lenValue", Thrift.Type.I64, 6);
        output.writeI64(this.lenValue);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TGetInfoReq = module2.exports.TGetInfoReq = function(args) {
      this.sessionHandle = null;
      this.infoType = null;
      if (args) {
        if (args.sessionHandle !== void 0 && args.sessionHandle !== null) {
          this.sessionHandle = new ttypes.TSessionHandle(args.sessionHandle);
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field sessionHandle is unset!");
        }
        if (args.infoType !== void 0 && args.infoType !== null) {
          this.infoType = args.infoType;
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field infoType is unset!");
        }
      }
    };
    TGetInfoReq.prototype = {};
    TGetInfoReq.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.sessionHandle = new ttypes.TSessionHandle();
              this.sessionHandle.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 2:
            if (ftype == Thrift.Type.I32) {
              this.infoType = input.readI32();
            } else {
              input.skip(ftype);
            }
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TGetInfoReq.prototype.write = function(output) {
      output.writeStructBegin("TGetInfoReq");
      if (this.sessionHandle !== null && this.sessionHandle !== void 0) {
        output.writeFieldBegin("sessionHandle", Thrift.Type.STRUCT, 1);
        this.sessionHandle.write(output);
        output.writeFieldEnd();
      }
      if (this.infoType !== null && this.infoType !== void 0) {
        output.writeFieldBegin("infoType", Thrift.Type.I32, 2);
        output.writeI32(this.infoType);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TGetInfoResp = module2.exports.TGetInfoResp = function(args) {
      this.status = null;
      this.infoValue = null;
      if (args) {
        if (args.status !== void 0 && args.status !== null) {
          this.status = new ttypes.TStatus(args.status);
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field status is unset!");
        }
        if (args.infoValue !== void 0 && args.infoValue !== null) {
          this.infoValue = new ttypes.TGetInfoValue(args.infoValue);
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field infoValue is unset!");
        }
      }
    };
    TGetInfoResp.prototype = {};
    TGetInfoResp.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.status = new ttypes.TStatus();
              this.status.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 2:
            if (ftype == Thrift.Type.STRUCT) {
              this.infoValue = new ttypes.TGetInfoValue();
              this.infoValue.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TGetInfoResp.prototype.write = function(output) {
      output.writeStructBegin("TGetInfoResp");
      if (this.status !== null && this.status !== void 0) {
        output.writeFieldBegin("status", Thrift.Type.STRUCT, 1);
        this.status.write(output);
        output.writeFieldEnd();
      }
      if (this.infoValue !== null && this.infoValue !== void 0) {
        output.writeFieldBegin("infoValue", Thrift.Type.STRUCT, 2);
        this.infoValue.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TExecuteStatementReq = module2.exports.TExecuteStatementReq = function(args) {
      this.sessionHandle = null;
      this.statement = null;
      this.confOverlay = null;
      this.runAsync = false;
      this.queryTimeout = new Int64(0);
      if (args) {
        if (args.sessionHandle !== void 0 && args.sessionHandle !== null) {
          this.sessionHandle = new ttypes.TSessionHandle(args.sessionHandle);
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field sessionHandle is unset!");
        }
        if (args.statement !== void 0 && args.statement !== null) {
          this.statement = args.statement;
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field statement is unset!");
        }
        if (args.confOverlay !== void 0 && args.confOverlay !== null) {
          this.confOverlay = Thrift.copyMap(args.confOverlay, [null]);
        }
        if (args.runAsync !== void 0 && args.runAsync !== null) {
          this.runAsync = args.runAsync;
        }
        if (args.queryTimeout !== void 0 && args.queryTimeout !== null) {
          this.queryTimeout = args.queryTimeout;
        }
      }
    };
    TExecuteStatementReq.prototype = {};
    TExecuteStatementReq.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.sessionHandle = new ttypes.TSessionHandle();
              this.sessionHandle.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 2:
            if (ftype == Thrift.Type.STRING) {
              this.statement = input.readString();
            } else {
              input.skip(ftype);
            }
            break;
          case 3:
            if (ftype == Thrift.Type.MAP) {
              this.confOverlay = {};
              var _rtmp3113 = input.readMapBegin();
              var _size112 = _rtmp3113.size || 0;
              for (var _i114 = 0; _i114 < _size112; ++_i114) {
                var key115 = null;
                var val116 = null;
                key115 = input.readString();
                val116 = input.readString();
                this.confOverlay[key115] = val116;
              }
              input.readMapEnd();
            } else {
              input.skip(ftype);
            }
            break;
          case 4:
            if (ftype == Thrift.Type.BOOL) {
              this.runAsync = input.readBool();
            } else {
              input.skip(ftype);
            }
            break;
          case 5:
            if (ftype == Thrift.Type.I64) {
              this.queryTimeout = input.readI64();
            } else {
              input.skip(ftype);
            }
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TExecuteStatementReq.prototype.write = function(output) {
      output.writeStructBegin("TExecuteStatementReq");
      if (this.sessionHandle !== null && this.sessionHandle !== void 0) {
        output.writeFieldBegin("sessionHandle", Thrift.Type.STRUCT, 1);
        this.sessionHandle.write(output);
        output.writeFieldEnd();
      }
      if (this.statement !== null && this.statement !== void 0) {
        output.writeFieldBegin("statement", Thrift.Type.STRING, 2);
        output.writeString(this.statement);
        output.writeFieldEnd();
      }
      if (this.confOverlay !== null && this.confOverlay !== void 0) {
        output.writeFieldBegin("confOverlay", Thrift.Type.MAP, 3);
        output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRING, Thrift.objectLength(this.confOverlay));
        for (var kiter117 in this.confOverlay) {
          if (this.confOverlay.hasOwnProperty(kiter117)) {
            var viter118 = this.confOverlay[kiter117];
            output.writeString(kiter117);
            output.writeString(viter118);
          }
        }
        output.writeMapEnd();
        output.writeFieldEnd();
      }
      if (this.runAsync !== null && this.runAsync !== void 0) {
        output.writeFieldBegin("runAsync", Thrift.Type.BOOL, 4);
        output.writeBool(this.runAsync);
        output.writeFieldEnd();
      }
      if (this.queryTimeout !== null && this.queryTimeout !== void 0) {
        output.writeFieldBegin("queryTimeout", Thrift.Type.I64, 5);
        output.writeI64(this.queryTimeout);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TExecuteStatementResp = module2.exports.TExecuteStatementResp = function(args) {
      this.status = null;
      this.operationHandle = null;
      if (args) {
        if (args.status !== void 0 && args.status !== null) {
          this.status = new ttypes.TStatus(args.status);
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field status is unset!");
        }
        if (args.operationHandle !== void 0 && args.operationHandle !== null) {
          this.operationHandle = new ttypes.TOperationHandle(args.operationHandle);
        }
      }
    };
    TExecuteStatementResp.prototype = {};
    TExecuteStatementResp.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.status = new ttypes.TStatus();
              this.status.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 2:
            if (ftype == Thrift.Type.STRUCT) {
              this.operationHandle = new ttypes.TOperationHandle();
              this.operationHandle.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TExecuteStatementResp.prototype.write = function(output) {
      output.writeStructBegin("TExecuteStatementResp");
      if (this.status !== null && this.status !== void 0) {
        output.writeFieldBegin("status", Thrift.Type.STRUCT, 1);
        this.status.write(output);
        output.writeFieldEnd();
      }
      if (this.operationHandle !== null && this.operationHandle !== void 0) {
        output.writeFieldBegin("operationHandle", Thrift.Type.STRUCT, 2);
        this.operationHandle.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TGetTypeInfoReq = module2.exports.TGetTypeInfoReq = function(args) {
      this.sessionHandle = null;
      if (args) {
        if (args.sessionHandle !== void 0 && args.sessionHandle !== null) {
          this.sessionHandle = new ttypes.TSessionHandle(args.sessionHandle);
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field sessionHandle is unset!");
        }
      }
    };
    TGetTypeInfoReq.prototype = {};
    TGetTypeInfoReq.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.sessionHandle = new ttypes.TSessionHandle();
              this.sessionHandle.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TGetTypeInfoReq.prototype.write = function(output) {
      output.writeStructBegin("TGetTypeInfoReq");
      if (this.sessionHandle !== null && this.sessionHandle !== void 0) {
        output.writeFieldBegin("sessionHandle", Thrift.Type.STRUCT, 1);
        this.sessionHandle.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TGetTypeInfoResp = module2.exports.TGetTypeInfoResp = function(args) {
      this.status = null;
      this.operationHandle = null;
      if (args) {
        if (args.status !== void 0 && args.status !== null) {
          this.status = new ttypes.TStatus(args.status);
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field status is unset!");
        }
        if (args.operationHandle !== void 0 && args.operationHandle !== null) {
          this.operationHandle = new ttypes.TOperationHandle(args.operationHandle);
        }
      }
    };
    TGetTypeInfoResp.prototype = {};
    TGetTypeInfoResp.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.status = new ttypes.TStatus();
              this.status.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 2:
            if (ftype == Thrift.Type.STRUCT) {
              this.operationHandle = new ttypes.TOperationHandle();
              this.operationHandle.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TGetTypeInfoResp.prototype.write = function(output) {
      output.writeStructBegin("TGetTypeInfoResp");
      if (this.status !== null && this.status !== void 0) {
        output.writeFieldBegin("status", Thrift.Type.STRUCT, 1);
        this.status.write(output);
        output.writeFieldEnd();
      }
      if (this.operationHandle !== null && this.operationHandle !== void 0) {
        output.writeFieldBegin("operationHandle", Thrift.Type.STRUCT, 2);
        this.operationHandle.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TGetCatalogsReq = module2.exports.TGetCatalogsReq = function(args) {
      this.sessionHandle = null;
      if (args) {
        if (args.sessionHandle !== void 0 && args.sessionHandle !== null) {
          this.sessionHandle = new ttypes.TSessionHandle(args.sessionHandle);
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field sessionHandle is unset!");
        }
      }
    };
    TGetCatalogsReq.prototype = {};
    TGetCatalogsReq.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.sessionHandle = new ttypes.TSessionHandle();
              this.sessionHandle.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TGetCatalogsReq.prototype.write = function(output) {
      output.writeStructBegin("TGetCatalogsReq");
      if (this.sessionHandle !== null && this.sessionHandle !== void 0) {
        output.writeFieldBegin("sessionHandle", Thrift.Type.STRUCT, 1);
        this.sessionHandle.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TGetCatalogsResp = module2.exports.TGetCatalogsResp = function(args) {
      this.status = null;
      this.operationHandle = null;
      if (args) {
        if (args.status !== void 0 && args.status !== null) {
          this.status = new ttypes.TStatus(args.status);
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field status is unset!");
        }
        if (args.operationHandle !== void 0 && args.operationHandle !== null) {
          this.operationHandle = new ttypes.TOperationHandle(args.operationHandle);
        }
      }
    };
    TGetCatalogsResp.prototype = {};
    TGetCatalogsResp.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.status = new ttypes.TStatus();
              this.status.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 2:
            if (ftype == Thrift.Type.STRUCT) {
              this.operationHandle = new ttypes.TOperationHandle();
              this.operationHandle.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TGetCatalogsResp.prototype.write = function(output) {
      output.writeStructBegin("TGetCatalogsResp");
      if (this.status !== null && this.status !== void 0) {
        output.writeFieldBegin("status", Thrift.Type.STRUCT, 1);
        this.status.write(output);
        output.writeFieldEnd();
      }
      if (this.operationHandle !== null && this.operationHandle !== void 0) {
        output.writeFieldBegin("operationHandle", Thrift.Type.STRUCT, 2);
        this.operationHandle.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TGetSchemasReq = module2.exports.TGetSchemasReq = function(args) {
      this.sessionHandle = null;
      this.catalogName = null;
      this.schemaName = null;
      if (args) {
        if (args.sessionHandle !== void 0 && args.sessionHandle !== null) {
          this.sessionHandle = new ttypes.TSessionHandle(args.sessionHandle);
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field sessionHandle is unset!");
        }
        if (args.catalogName !== void 0 && args.catalogName !== null) {
          this.catalogName = args.catalogName;
        }
        if (args.schemaName !== void 0 && args.schemaName !== null) {
          this.schemaName = args.schemaName;
        }
      }
    };
    TGetSchemasReq.prototype = {};
    TGetSchemasReq.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.sessionHandle = new ttypes.TSessionHandle();
              this.sessionHandle.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 2:
            if (ftype == Thrift.Type.STRING) {
              this.catalogName = input.readString();
            } else {
              input.skip(ftype);
            }
            break;
          case 3:
            if (ftype == Thrift.Type.STRING) {
              this.schemaName = input.readString();
            } else {
              input.skip(ftype);
            }
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TGetSchemasReq.prototype.write = function(output) {
      output.writeStructBegin("TGetSchemasReq");
      if (this.sessionHandle !== null && this.sessionHandle !== void 0) {
        output.writeFieldBegin("sessionHandle", Thrift.Type.STRUCT, 1);
        this.sessionHandle.write(output);
        output.writeFieldEnd();
      }
      if (this.catalogName !== null && this.catalogName !== void 0) {
        output.writeFieldBegin("catalogName", Thrift.Type.STRING, 2);
        output.writeString(this.catalogName);
        output.writeFieldEnd();
      }
      if (this.schemaName !== null && this.schemaName !== void 0) {
        output.writeFieldBegin("schemaName", Thrift.Type.STRING, 3);
        output.writeString(this.schemaName);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TGetSchemasResp = module2.exports.TGetSchemasResp = function(args) {
      this.status = null;
      this.operationHandle = null;
      if (args) {
        if (args.status !== void 0 && args.status !== null) {
          this.status = new ttypes.TStatus(args.status);
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field status is unset!");
        }
        if (args.operationHandle !== void 0 && args.operationHandle !== null) {
          this.operationHandle = new ttypes.TOperationHandle(args.operationHandle);
        }
      }
    };
    TGetSchemasResp.prototype = {};
    TGetSchemasResp.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.status = new ttypes.TStatus();
              this.status.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 2:
            if (ftype == Thrift.Type.STRUCT) {
              this.operationHandle = new ttypes.TOperationHandle();
              this.operationHandle.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TGetSchemasResp.prototype.write = function(output) {
      output.writeStructBegin("TGetSchemasResp");
      if (this.status !== null && this.status !== void 0) {
        output.writeFieldBegin("status", Thrift.Type.STRUCT, 1);
        this.status.write(output);
        output.writeFieldEnd();
      }
      if (this.operationHandle !== null && this.operationHandle !== void 0) {
        output.writeFieldBegin("operationHandle", Thrift.Type.STRUCT, 2);
        this.operationHandle.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TGetTablesReq = module2.exports.TGetTablesReq = function(args) {
      this.sessionHandle = null;
      this.catalogName = null;
      this.schemaName = null;
      this.tableName = null;
      this.tableTypes = null;
      if (args) {
        if (args.sessionHandle !== void 0 && args.sessionHandle !== null) {
          this.sessionHandle = new ttypes.TSessionHandle(args.sessionHandle);
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field sessionHandle is unset!");
        }
        if (args.catalogName !== void 0 && args.catalogName !== null) {
          this.catalogName = args.catalogName;
        }
        if (args.schemaName !== void 0 && args.schemaName !== null) {
          this.schemaName = args.schemaName;
        }
        if (args.tableName !== void 0 && args.tableName !== null) {
          this.tableName = args.tableName;
        }
        if (args.tableTypes !== void 0 && args.tableTypes !== null) {
          this.tableTypes = Thrift.copyList(args.tableTypes, [null]);
        }
      }
    };
    TGetTablesReq.prototype = {};
    TGetTablesReq.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.sessionHandle = new ttypes.TSessionHandle();
              this.sessionHandle.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 2:
            if (ftype == Thrift.Type.STRING) {
              this.catalogName = input.readString();
            } else {
              input.skip(ftype);
            }
            break;
          case 3:
            if (ftype == Thrift.Type.STRING) {
              this.schemaName = input.readString();
            } else {
              input.skip(ftype);
            }
            break;
          case 4:
            if (ftype == Thrift.Type.STRING) {
              this.tableName = input.readString();
            } else {
              input.skip(ftype);
            }
            break;
          case 5:
            if (ftype == Thrift.Type.LIST) {
              this.tableTypes = [];
              var _rtmp3120 = input.readListBegin();
              var _size119 = _rtmp3120.size || 0;
              for (var _i121 = 0; _i121 < _size119; ++_i121) {
                var elem122 = null;
                elem122 = input.readString();
                this.tableTypes.push(elem122);
              }
              input.readListEnd();
            } else {
              input.skip(ftype);
            }
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TGetTablesReq.prototype.write = function(output) {
      output.writeStructBegin("TGetTablesReq");
      if (this.sessionHandle !== null && this.sessionHandle !== void 0) {
        output.writeFieldBegin("sessionHandle", Thrift.Type.STRUCT, 1);
        this.sessionHandle.write(output);
        output.writeFieldEnd();
      }
      if (this.catalogName !== null && this.catalogName !== void 0) {
        output.writeFieldBegin("catalogName", Thrift.Type.STRING, 2);
        output.writeString(this.catalogName);
        output.writeFieldEnd();
      }
      if (this.schemaName !== null && this.schemaName !== void 0) {
        output.writeFieldBegin("schemaName", Thrift.Type.STRING, 3);
        output.writeString(this.schemaName);
        output.writeFieldEnd();
      }
      if (this.tableName !== null && this.tableName !== void 0) {
        output.writeFieldBegin("tableName", Thrift.Type.STRING, 4);
        output.writeString(this.tableName);
        output.writeFieldEnd();
      }
      if (this.tableTypes !== null && this.tableTypes !== void 0) {
        output.writeFieldBegin("tableTypes", Thrift.Type.LIST, 5);
        output.writeListBegin(Thrift.Type.STRING, this.tableTypes.length);
        for (var iter123 in this.tableTypes) {
          if (this.tableTypes.hasOwnProperty(iter123)) {
            iter123 = this.tableTypes[iter123];
            output.writeString(iter123);
          }
        }
        output.writeListEnd();
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TGetTablesResp = module2.exports.TGetTablesResp = function(args) {
      this.status = null;
      this.operationHandle = null;
      if (args) {
        if (args.status !== void 0 && args.status !== null) {
          this.status = new ttypes.TStatus(args.status);
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field status is unset!");
        }
        if (args.operationHandle !== void 0 && args.operationHandle !== null) {
          this.operationHandle = new ttypes.TOperationHandle(args.operationHandle);
        }
      }
    };
    TGetTablesResp.prototype = {};
    TGetTablesResp.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.status = new ttypes.TStatus();
              this.status.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 2:
            if (ftype == Thrift.Type.STRUCT) {
              this.operationHandle = new ttypes.TOperationHandle();
              this.operationHandle.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TGetTablesResp.prototype.write = function(output) {
      output.writeStructBegin("TGetTablesResp");
      if (this.status !== null && this.status !== void 0) {
        output.writeFieldBegin("status", Thrift.Type.STRUCT, 1);
        this.status.write(output);
        output.writeFieldEnd();
      }
      if (this.operationHandle !== null && this.operationHandle !== void 0) {
        output.writeFieldBegin("operationHandle", Thrift.Type.STRUCT, 2);
        this.operationHandle.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TGetTableTypesReq = module2.exports.TGetTableTypesReq = function(args) {
      this.sessionHandle = null;
      if (args) {
        if (args.sessionHandle !== void 0 && args.sessionHandle !== null) {
          this.sessionHandle = new ttypes.TSessionHandle(args.sessionHandle);
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field sessionHandle is unset!");
        }
      }
    };
    TGetTableTypesReq.prototype = {};
    TGetTableTypesReq.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.sessionHandle = new ttypes.TSessionHandle();
              this.sessionHandle.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TGetTableTypesReq.prototype.write = function(output) {
      output.writeStructBegin("TGetTableTypesReq");
      if (this.sessionHandle !== null && this.sessionHandle !== void 0) {
        output.writeFieldBegin("sessionHandle", Thrift.Type.STRUCT, 1);
        this.sessionHandle.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TGetTableTypesResp = module2.exports.TGetTableTypesResp = function(args) {
      this.status = null;
      this.operationHandle = null;
      if (args) {
        if (args.status !== void 0 && args.status !== null) {
          this.status = new ttypes.TStatus(args.status);
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field status is unset!");
        }
        if (args.operationHandle !== void 0 && args.operationHandle !== null) {
          this.operationHandle = new ttypes.TOperationHandle(args.operationHandle);
        }
      }
    };
    TGetTableTypesResp.prototype = {};
    TGetTableTypesResp.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.status = new ttypes.TStatus();
              this.status.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 2:
            if (ftype == Thrift.Type.STRUCT) {
              this.operationHandle = new ttypes.TOperationHandle();
              this.operationHandle.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TGetTableTypesResp.prototype.write = function(output) {
      output.writeStructBegin("TGetTableTypesResp");
      if (this.status !== null && this.status !== void 0) {
        output.writeFieldBegin("status", Thrift.Type.STRUCT, 1);
        this.status.write(output);
        output.writeFieldEnd();
      }
      if (this.operationHandle !== null && this.operationHandle !== void 0) {
        output.writeFieldBegin("operationHandle", Thrift.Type.STRUCT, 2);
        this.operationHandle.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TGetColumnsReq = module2.exports.TGetColumnsReq = function(args) {
      this.sessionHandle = null;
      this.catalogName = null;
      this.schemaName = null;
      this.tableName = null;
      this.columnName = null;
      if (args) {
        if (args.sessionHandle !== void 0 && args.sessionHandle !== null) {
          this.sessionHandle = new ttypes.TSessionHandle(args.sessionHandle);
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field sessionHandle is unset!");
        }
        if (args.catalogName !== void 0 && args.catalogName !== null) {
          this.catalogName = args.catalogName;
        }
        if (args.schemaName !== void 0 && args.schemaName !== null) {
          this.schemaName = args.schemaName;
        }
        if (args.tableName !== void 0 && args.tableName !== null) {
          this.tableName = args.tableName;
        }
        if (args.columnName !== void 0 && args.columnName !== null) {
          this.columnName = args.columnName;
        }
      }
    };
    TGetColumnsReq.prototype = {};
    TGetColumnsReq.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.sessionHandle = new ttypes.TSessionHandle();
              this.sessionHandle.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 2:
            if (ftype == Thrift.Type.STRING) {
              this.catalogName = input.readString();
            } else {
              input.skip(ftype);
            }
            break;
          case 3:
            if (ftype == Thrift.Type.STRING) {
              this.schemaName = input.readString();
            } else {
              input.skip(ftype);
            }
            break;
          case 4:
            if (ftype == Thrift.Type.STRING) {
              this.tableName = input.readString();
            } else {
              input.skip(ftype);
            }
            break;
          case 5:
            if (ftype == Thrift.Type.STRING) {
              this.columnName = input.readString();
            } else {
              input.skip(ftype);
            }
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TGetColumnsReq.prototype.write = function(output) {
      output.writeStructBegin("TGetColumnsReq");
      if (this.sessionHandle !== null && this.sessionHandle !== void 0) {
        output.writeFieldBegin("sessionHandle", Thrift.Type.STRUCT, 1);
        this.sessionHandle.write(output);
        output.writeFieldEnd();
      }
      if (this.catalogName !== null && this.catalogName !== void 0) {
        output.writeFieldBegin("catalogName", Thrift.Type.STRING, 2);
        output.writeString(this.catalogName);
        output.writeFieldEnd();
      }
      if (this.schemaName !== null && this.schemaName !== void 0) {
        output.writeFieldBegin("schemaName", Thrift.Type.STRING, 3);
        output.writeString(this.schemaName);
        output.writeFieldEnd();
      }
      if (this.tableName !== null && this.tableName !== void 0) {
        output.writeFieldBegin("tableName", Thrift.Type.STRING, 4);
        output.writeString(this.tableName);
        output.writeFieldEnd();
      }
      if (this.columnName !== null && this.columnName !== void 0) {
        output.writeFieldBegin("columnName", Thrift.Type.STRING, 5);
        output.writeString(this.columnName);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TGetColumnsResp = module2.exports.TGetColumnsResp = function(args) {
      this.status = null;
      this.operationHandle = null;
      if (args) {
        if (args.status !== void 0 && args.status !== null) {
          this.status = new ttypes.TStatus(args.status);
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field status is unset!");
        }
        if (args.operationHandle !== void 0 && args.operationHandle !== null) {
          this.operationHandle = new ttypes.TOperationHandle(args.operationHandle);
        }
      }
    };
    TGetColumnsResp.prototype = {};
    TGetColumnsResp.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.status = new ttypes.TStatus();
              this.status.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 2:
            if (ftype == Thrift.Type.STRUCT) {
              this.operationHandle = new ttypes.TOperationHandle();
              this.operationHandle.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TGetColumnsResp.prototype.write = function(output) {
      output.writeStructBegin("TGetColumnsResp");
      if (this.status !== null && this.status !== void 0) {
        output.writeFieldBegin("status", Thrift.Type.STRUCT, 1);
        this.status.write(output);
        output.writeFieldEnd();
      }
      if (this.operationHandle !== null && this.operationHandle !== void 0) {
        output.writeFieldBegin("operationHandle", Thrift.Type.STRUCT, 2);
        this.operationHandle.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TGetFunctionsReq = module2.exports.TGetFunctionsReq = function(args) {
      this.sessionHandle = null;
      this.catalogName = null;
      this.schemaName = null;
      this.functionName = null;
      if (args) {
        if (args.sessionHandle !== void 0 && args.sessionHandle !== null) {
          this.sessionHandle = new ttypes.TSessionHandle(args.sessionHandle);
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field sessionHandle is unset!");
        }
        if (args.catalogName !== void 0 && args.catalogName !== null) {
          this.catalogName = args.catalogName;
        }
        if (args.schemaName !== void 0 && args.schemaName !== null) {
          this.schemaName = args.schemaName;
        }
        if (args.functionName !== void 0 && args.functionName !== null) {
          this.functionName = args.functionName;
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field functionName is unset!");
        }
      }
    };
    TGetFunctionsReq.prototype = {};
    TGetFunctionsReq.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.sessionHandle = new ttypes.TSessionHandle();
              this.sessionHandle.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 2:
            if (ftype == Thrift.Type.STRING) {
              this.catalogName = input.readString();
            } else {
              input.skip(ftype);
            }
            break;
          case 3:
            if (ftype == Thrift.Type.STRING) {
              this.schemaName = input.readString();
            } else {
              input.skip(ftype);
            }
            break;
          case 4:
            if (ftype == Thrift.Type.STRING) {
              this.functionName = input.readString();
            } else {
              input.skip(ftype);
            }
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TGetFunctionsReq.prototype.write = function(output) {
      output.writeStructBegin("TGetFunctionsReq");
      if (this.sessionHandle !== null && this.sessionHandle !== void 0) {
        output.writeFieldBegin("sessionHandle", Thrift.Type.STRUCT, 1);
        this.sessionHandle.write(output);
        output.writeFieldEnd();
      }
      if (this.catalogName !== null && this.catalogName !== void 0) {
        output.writeFieldBegin("catalogName", Thrift.Type.STRING, 2);
        output.writeString(this.catalogName);
        output.writeFieldEnd();
      }
      if (this.schemaName !== null && this.schemaName !== void 0) {
        output.writeFieldBegin("schemaName", Thrift.Type.STRING, 3);
        output.writeString(this.schemaName);
        output.writeFieldEnd();
      }
      if (this.functionName !== null && this.functionName !== void 0) {
        output.writeFieldBegin("functionName", Thrift.Type.STRING, 4);
        output.writeString(this.functionName);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TGetFunctionsResp = module2.exports.TGetFunctionsResp = function(args) {
      this.status = null;
      this.operationHandle = null;
      if (args) {
        if (args.status !== void 0 && args.status !== null) {
          this.status = new ttypes.TStatus(args.status);
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field status is unset!");
        }
        if (args.operationHandle !== void 0 && args.operationHandle !== null) {
          this.operationHandle = new ttypes.TOperationHandle(args.operationHandle);
        }
      }
    };
    TGetFunctionsResp.prototype = {};
    TGetFunctionsResp.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.status = new ttypes.TStatus();
              this.status.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 2:
            if (ftype == Thrift.Type.STRUCT) {
              this.operationHandle = new ttypes.TOperationHandle();
              this.operationHandle.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TGetFunctionsResp.prototype.write = function(output) {
      output.writeStructBegin("TGetFunctionsResp");
      if (this.status !== null && this.status !== void 0) {
        output.writeFieldBegin("status", Thrift.Type.STRUCT, 1);
        this.status.write(output);
        output.writeFieldEnd();
      }
      if (this.operationHandle !== null && this.operationHandle !== void 0) {
        output.writeFieldBegin("operationHandle", Thrift.Type.STRUCT, 2);
        this.operationHandle.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TGetPrimaryKeysReq = module2.exports.TGetPrimaryKeysReq = function(args) {
      this.sessionHandle = null;
      this.catalogName = null;
      this.schemaName = null;
      this.tableName = null;
      if (args) {
        if (args.sessionHandle !== void 0 && args.sessionHandle !== null) {
          this.sessionHandle = new ttypes.TSessionHandle(args.sessionHandle);
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field sessionHandle is unset!");
        }
        if (args.catalogName !== void 0 && args.catalogName !== null) {
          this.catalogName = args.catalogName;
        }
        if (args.schemaName !== void 0 && args.schemaName !== null) {
          this.schemaName = args.schemaName;
        }
        if (args.tableName !== void 0 && args.tableName !== null) {
          this.tableName = args.tableName;
        }
      }
    };
    TGetPrimaryKeysReq.prototype = {};
    TGetPrimaryKeysReq.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.sessionHandle = new ttypes.TSessionHandle();
              this.sessionHandle.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 2:
            if (ftype == Thrift.Type.STRING) {
              this.catalogName = input.readString();
            } else {
              input.skip(ftype);
            }
            break;
          case 3:
            if (ftype == Thrift.Type.STRING) {
              this.schemaName = input.readString();
            } else {
              input.skip(ftype);
            }
            break;
          case 4:
            if (ftype == Thrift.Type.STRING) {
              this.tableName = input.readString();
            } else {
              input.skip(ftype);
            }
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TGetPrimaryKeysReq.prototype.write = function(output) {
      output.writeStructBegin("TGetPrimaryKeysReq");
      if (this.sessionHandle !== null && this.sessionHandle !== void 0) {
        output.writeFieldBegin("sessionHandle", Thrift.Type.STRUCT, 1);
        this.sessionHandle.write(output);
        output.writeFieldEnd();
      }
      if (this.catalogName !== null && this.catalogName !== void 0) {
        output.writeFieldBegin("catalogName", Thrift.Type.STRING, 2);
        output.writeString(this.catalogName);
        output.writeFieldEnd();
      }
      if (this.schemaName !== null && this.schemaName !== void 0) {
        output.writeFieldBegin("schemaName", Thrift.Type.STRING, 3);
        output.writeString(this.schemaName);
        output.writeFieldEnd();
      }
      if (this.tableName !== null && this.tableName !== void 0) {
        output.writeFieldBegin("tableName", Thrift.Type.STRING, 4);
        output.writeString(this.tableName);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TGetPrimaryKeysResp = module2.exports.TGetPrimaryKeysResp = function(args) {
      this.status = null;
      this.operationHandle = null;
      if (args) {
        if (args.status !== void 0 && args.status !== null) {
          this.status = new ttypes.TStatus(args.status);
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field status is unset!");
        }
        if (args.operationHandle !== void 0 && args.operationHandle !== null) {
          this.operationHandle = new ttypes.TOperationHandle(args.operationHandle);
        }
      }
    };
    TGetPrimaryKeysResp.prototype = {};
    TGetPrimaryKeysResp.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.status = new ttypes.TStatus();
              this.status.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 2:
            if (ftype == Thrift.Type.STRUCT) {
              this.operationHandle = new ttypes.TOperationHandle();
              this.operationHandle.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TGetPrimaryKeysResp.prototype.write = function(output) {
      output.writeStructBegin("TGetPrimaryKeysResp");
      if (this.status !== null && this.status !== void 0) {
        output.writeFieldBegin("status", Thrift.Type.STRUCT, 1);
        this.status.write(output);
        output.writeFieldEnd();
      }
      if (this.operationHandle !== null && this.operationHandle !== void 0) {
        output.writeFieldBegin("operationHandle", Thrift.Type.STRUCT, 2);
        this.operationHandle.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TGetCrossReferenceReq = module2.exports.TGetCrossReferenceReq = function(args) {
      this.sessionHandle = null;
      this.parentCatalogName = null;
      this.parentSchemaName = null;
      this.parentTableName = null;
      this.foreignCatalogName = null;
      this.foreignSchemaName = null;
      this.foreignTableName = null;
      if (args) {
        if (args.sessionHandle !== void 0 && args.sessionHandle !== null) {
          this.sessionHandle = new ttypes.TSessionHandle(args.sessionHandle);
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field sessionHandle is unset!");
        }
        if (args.parentCatalogName !== void 0 && args.parentCatalogName !== null) {
          this.parentCatalogName = args.parentCatalogName;
        }
        if (args.parentSchemaName !== void 0 && args.parentSchemaName !== null) {
          this.parentSchemaName = args.parentSchemaName;
        }
        if (args.parentTableName !== void 0 && args.parentTableName !== null) {
          this.parentTableName = args.parentTableName;
        }
        if (args.foreignCatalogName !== void 0 && args.foreignCatalogName !== null) {
          this.foreignCatalogName = args.foreignCatalogName;
        }
        if (args.foreignSchemaName !== void 0 && args.foreignSchemaName !== null) {
          this.foreignSchemaName = args.foreignSchemaName;
        }
        if (args.foreignTableName !== void 0 && args.foreignTableName !== null) {
          this.foreignTableName = args.foreignTableName;
        }
      }
    };
    TGetCrossReferenceReq.prototype = {};
    TGetCrossReferenceReq.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.sessionHandle = new ttypes.TSessionHandle();
              this.sessionHandle.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 2:
            if (ftype == Thrift.Type.STRING) {
              this.parentCatalogName = input.readString();
            } else {
              input.skip(ftype);
            }
            break;
          case 3:
            if (ftype == Thrift.Type.STRING) {
              this.parentSchemaName = input.readString();
            } else {
              input.skip(ftype);
            }
            break;
          case 4:
            if (ftype == Thrift.Type.STRING) {
              this.parentTableName = input.readString();
            } else {
              input.skip(ftype);
            }
            break;
          case 5:
            if (ftype == Thrift.Type.STRING) {
              this.foreignCatalogName = input.readString();
            } else {
              input.skip(ftype);
            }
            break;
          case 6:
            if (ftype == Thrift.Type.STRING) {
              this.foreignSchemaName = input.readString();
            } else {
              input.skip(ftype);
            }
            break;
          case 7:
            if (ftype == Thrift.Type.STRING) {
              this.foreignTableName = input.readString();
            } else {
              input.skip(ftype);
            }
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TGetCrossReferenceReq.prototype.write = function(output) {
      output.writeStructBegin("TGetCrossReferenceReq");
      if (this.sessionHandle !== null && this.sessionHandle !== void 0) {
        output.writeFieldBegin("sessionHandle", Thrift.Type.STRUCT, 1);
        this.sessionHandle.write(output);
        output.writeFieldEnd();
      }
      if (this.parentCatalogName !== null && this.parentCatalogName !== void 0) {
        output.writeFieldBegin("parentCatalogName", Thrift.Type.STRING, 2);
        output.writeString(this.parentCatalogName);
        output.writeFieldEnd();
      }
      if (this.parentSchemaName !== null && this.parentSchemaName !== void 0) {
        output.writeFieldBegin("parentSchemaName", Thrift.Type.STRING, 3);
        output.writeString(this.parentSchemaName);
        output.writeFieldEnd();
      }
      if (this.parentTableName !== null && this.parentTableName !== void 0) {
        output.writeFieldBegin("parentTableName", Thrift.Type.STRING, 4);
        output.writeString(this.parentTableName);
        output.writeFieldEnd();
      }
      if (this.foreignCatalogName !== null && this.foreignCatalogName !== void 0) {
        output.writeFieldBegin("foreignCatalogName", Thrift.Type.STRING, 5);
        output.writeString(this.foreignCatalogName);
        output.writeFieldEnd();
      }
      if (this.foreignSchemaName !== null && this.foreignSchemaName !== void 0) {
        output.writeFieldBegin("foreignSchemaName", Thrift.Type.STRING, 6);
        output.writeString(this.foreignSchemaName);
        output.writeFieldEnd();
      }
      if (this.foreignTableName !== null && this.foreignTableName !== void 0) {
        output.writeFieldBegin("foreignTableName", Thrift.Type.STRING, 7);
        output.writeString(this.foreignTableName);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TGetCrossReferenceResp = module2.exports.TGetCrossReferenceResp = function(args) {
      this.status = null;
      this.operationHandle = null;
      if (args) {
        if (args.status !== void 0 && args.status !== null) {
          this.status = new ttypes.TStatus(args.status);
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field status is unset!");
        }
        if (args.operationHandle !== void 0 && args.operationHandle !== null) {
          this.operationHandle = new ttypes.TOperationHandle(args.operationHandle);
        }
      }
    };
    TGetCrossReferenceResp.prototype = {};
    TGetCrossReferenceResp.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.status = new ttypes.TStatus();
              this.status.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 2:
            if (ftype == Thrift.Type.STRUCT) {
              this.operationHandle = new ttypes.TOperationHandle();
              this.operationHandle.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TGetCrossReferenceResp.prototype.write = function(output) {
      output.writeStructBegin("TGetCrossReferenceResp");
      if (this.status !== null && this.status !== void 0) {
        output.writeFieldBegin("status", Thrift.Type.STRUCT, 1);
        this.status.write(output);
        output.writeFieldEnd();
      }
      if (this.operationHandle !== null && this.operationHandle !== void 0) {
        output.writeFieldBegin("operationHandle", Thrift.Type.STRUCT, 2);
        this.operationHandle.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TGetOperationStatusReq = module2.exports.TGetOperationStatusReq = function(args) {
      this.operationHandle = null;
      this.getProgressUpdate = null;
      if (args) {
        if (args.operationHandle !== void 0 && args.operationHandle !== null) {
          this.operationHandle = new ttypes.TOperationHandle(args.operationHandle);
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field operationHandle is unset!");
        }
        if (args.getProgressUpdate !== void 0 && args.getProgressUpdate !== null) {
          this.getProgressUpdate = args.getProgressUpdate;
        }
      }
    };
    TGetOperationStatusReq.prototype = {};
    TGetOperationStatusReq.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.operationHandle = new ttypes.TOperationHandle();
              this.operationHandle.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 2:
            if (ftype == Thrift.Type.BOOL) {
              this.getProgressUpdate = input.readBool();
            } else {
              input.skip(ftype);
            }
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TGetOperationStatusReq.prototype.write = function(output) {
      output.writeStructBegin("TGetOperationStatusReq");
      if (this.operationHandle !== null && this.operationHandle !== void 0) {
        output.writeFieldBegin("operationHandle", Thrift.Type.STRUCT, 1);
        this.operationHandle.write(output);
        output.writeFieldEnd();
      }
      if (this.getProgressUpdate !== null && this.getProgressUpdate !== void 0) {
        output.writeFieldBegin("getProgressUpdate", Thrift.Type.BOOL, 2);
        output.writeBool(this.getProgressUpdate);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TGetOperationStatusResp = module2.exports.TGetOperationStatusResp = function(args) {
      this.status = null;
      this.operationState = null;
      this.sqlState = null;
      this.errorCode = null;
      this.errorMessage = null;
      this.taskStatus = null;
      this.operationStarted = null;
      this.operationCompleted = null;
      this.hasResultSet = null;
      this.progressUpdateResponse = null;
      this.numModifiedRows = null;
      if (args) {
        if (args.status !== void 0 && args.status !== null) {
          this.status = new ttypes.TStatus(args.status);
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field status is unset!");
        }
        if (args.operationState !== void 0 && args.operationState !== null) {
          this.operationState = args.operationState;
        }
        if (args.sqlState !== void 0 && args.sqlState !== null) {
          this.sqlState = args.sqlState;
        }
        if (args.errorCode !== void 0 && args.errorCode !== null) {
          this.errorCode = args.errorCode;
        }
        if (args.errorMessage !== void 0 && args.errorMessage !== null) {
          this.errorMessage = args.errorMessage;
        }
        if (args.taskStatus !== void 0 && args.taskStatus !== null) {
          this.taskStatus = args.taskStatus;
        }
        if (args.operationStarted !== void 0 && args.operationStarted !== null) {
          this.operationStarted = args.operationStarted;
        }
        if (args.operationCompleted !== void 0 && args.operationCompleted !== null) {
          this.operationCompleted = args.operationCompleted;
        }
        if (args.hasResultSet !== void 0 && args.hasResultSet !== null) {
          this.hasResultSet = args.hasResultSet;
        }
        if (args.progressUpdateResponse !== void 0 && args.progressUpdateResponse !== null) {
          this.progressUpdateResponse = new ttypes.TProgressUpdateResp(args.progressUpdateResponse);
        }
        if (args.numModifiedRows !== void 0 && args.numModifiedRows !== null) {
          this.numModifiedRows = args.numModifiedRows;
        }
      }
    };
    TGetOperationStatusResp.prototype = {};
    TGetOperationStatusResp.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.status = new ttypes.TStatus();
              this.status.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 2:
            if (ftype == Thrift.Type.I32) {
              this.operationState = input.readI32();
            } else {
              input.skip(ftype);
            }
            break;
          case 3:
            if (ftype == Thrift.Type.STRING) {
              this.sqlState = input.readString();
            } else {
              input.skip(ftype);
            }
            break;
          case 4:
            if (ftype == Thrift.Type.I32) {
              this.errorCode = input.readI32();
            } else {
              input.skip(ftype);
            }
            break;
          case 5:
            if (ftype == Thrift.Type.STRING) {
              this.errorMessage = input.readString();
            } else {
              input.skip(ftype);
            }
            break;
          case 6:
            if (ftype == Thrift.Type.STRING) {
              this.taskStatus = input.readString();
            } else {
              input.skip(ftype);
            }
            break;
          case 7:
            if (ftype == Thrift.Type.I64) {
              this.operationStarted = input.readI64();
            } else {
              input.skip(ftype);
            }
            break;
          case 8:
            if (ftype == Thrift.Type.I64) {
              this.operationCompleted = input.readI64();
            } else {
              input.skip(ftype);
            }
            break;
          case 9:
            if (ftype == Thrift.Type.BOOL) {
              this.hasResultSet = input.readBool();
            } else {
              input.skip(ftype);
            }
            break;
          case 10:
            if (ftype == Thrift.Type.STRUCT) {
              this.progressUpdateResponse = new ttypes.TProgressUpdateResp();
              this.progressUpdateResponse.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 11:
            if (ftype == Thrift.Type.I64) {
              this.numModifiedRows = input.readI64();
            } else {
              input.skip(ftype);
            }
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TGetOperationStatusResp.prototype.write = function(output) {
      output.writeStructBegin("TGetOperationStatusResp");
      if (this.status !== null && this.status !== void 0) {
        output.writeFieldBegin("status", Thrift.Type.STRUCT, 1);
        this.status.write(output);
        output.writeFieldEnd();
      }
      if (this.operationState !== null && this.operationState !== void 0) {
        output.writeFieldBegin("operationState", Thrift.Type.I32, 2);
        output.writeI32(this.operationState);
        output.writeFieldEnd();
      }
      if (this.sqlState !== null && this.sqlState !== void 0) {
        output.writeFieldBegin("sqlState", Thrift.Type.STRING, 3);
        output.writeString(this.sqlState);
        output.writeFieldEnd();
      }
      if (this.errorCode !== null && this.errorCode !== void 0) {
        output.writeFieldBegin("errorCode", Thrift.Type.I32, 4);
        output.writeI32(this.errorCode);
        output.writeFieldEnd();
      }
      if (this.errorMessage !== null && this.errorMessage !== void 0) {
        output.writeFieldBegin("errorMessage", Thrift.Type.STRING, 5);
        output.writeString(this.errorMessage);
        output.writeFieldEnd();
      }
      if (this.taskStatus !== null && this.taskStatus !== void 0) {
        output.writeFieldBegin("taskStatus", Thrift.Type.STRING, 6);
        output.writeString(this.taskStatus);
        output.writeFieldEnd();
      }
      if (this.operationStarted !== null && this.operationStarted !== void 0) {
        output.writeFieldBegin("operationStarted", Thrift.Type.I64, 7);
        output.writeI64(this.operationStarted);
        output.writeFieldEnd();
      }
      if (this.operationCompleted !== null && this.operationCompleted !== void 0) {
        output.writeFieldBegin("operationCompleted", Thrift.Type.I64, 8);
        output.writeI64(this.operationCompleted);
        output.writeFieldEnd();
      }
      if (this.hasResultSet !== null && this.hasResultSet !== void 0) {
        output.writeFieldBegin("hasResultSet", Thrift.Type.BOOL, 9);
        output.writeBool(this.hasResultSet);
        output.writeFieldEnd();
      }
      if (this.progressUpdateResponse !== null && this.progressUpdateResponse !== void 0) {
        output.writeFieldBegin("progressUpdateResponse", Thrift.Type.STRUCT, 10);
        this.progressUpdateResponse.write(output);
        output.writeFieldEnd();
      }
      if (this.numModifiedRows !== null && this.numModifiedRows !== void 0) {
        output.writeFieldBegin("numModifiedRows", Thrift.Type.I64, 11);
        output.writeI64(this.numModifiedRows);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TCancelOperationReq = module2.exports.TCancelOperationReq = function(args) {
      this.operationHandle = null;
      if (args) {
        if (args.operationHandle !== void 0 && args.operationHandle !== null) {
          this.operationHandle = new ttypes.TOperationHandle(args.operationHandle);
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field operationHandle is unset!");
        }
      }
    };
    TCancelOperationReq.prototype = {};
    TCancelOperationReq.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.operationHandle = new ttypes.TOperationHandle();
              this.operationHandle.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TCancelOperationReq.prototype.write = function(output) {
      output.writeStructBegin("TCancelOperationReq");
      if (this.operationHandle !== null && this.operationHandle !== void 0) {
        output.writeFieldBegin("operationHandle", Thrift.Type.STRUCT, 1);
        this.operationHandle.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TCancelOperationResp = module2.exports.TCancelOperationResp = function(args) {
      this.status = null;
      if (args) {
        if (args.status !== void 0 && args.status !== null) {
          this.status = new ttypes.TStatus(args.status);
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field status is unset!");
        }
      }
    };
    TCancelOperationResp.prototype = {};
    TCancelOperationResp.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.status = new ttypes.TStatus();
              this.status.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TCancelOperationResp.prototype.write = function(output) {
      output.writeStructBegin("TCancelOperationResp");
      if (this.status !== null && this.status !== void 0) {
        output.writeFieldBegin("status", Thrift.Type.STRUCT, 1);
        this.status.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TCloseOperationReq = module2.exports.TCloseOperationReq = function(args) {
      this.operationHandle = null;
      if (args) {
        if (args.operationHandle !== void 0 && args.operationHandle !== null) {
          this.operationHandle = new ttypes.TOperationHandle(args.operationHandle);
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field operationHandle is unset!");
        }
      }
    };
    TCloseOperationReq.prototype = {};
    TCloseOperationReq.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.operationHandle = new ttypes.TOperationHandle();
              this.operationHandle.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TCloseOperationReq.prototype.write = function(output) {
      output.writeStructBegin("TCloseOperationReq");
      if (this.operationHandle !== null && this.operationHandle !== void 0) {
        output.writeFieldBegin("operationHandle", Thrift.Type.STRUCT, 1);
        this.operationHandle.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TCloseOperationResp = module2.exports.TCloseOperationResp = function(args) {
      this.status = null;
      if (args) {
        if (args.status !== void 0 && args.status !== null) {
          this.status = new ttypes.TStatus(args.status);
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field status is unset!");
        }
      }
    };
    TCloseOperationResp.prototype = {};
    TCloseOperationResp.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.status = new ttypes.TStatus();
              this.status.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TCloseOperationResp.prototype.write = function(output) {
      output.writeStructBegin("TCloseOperationResp");
      if (this.status !== null && this.status !== void 0) {
        output.writeFieldBegin("status", Thrift.Type.STRUCT, 1);
        this.status.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TGetResultSetMetadataReq = module2.exports.TGetResultSetMetadataReq = function(args) {
      this.operationHandle = null;
      if (args) {
        if (args.operationHandle !== void 0 && args.operationHandle !== null) {
          this.operationHandle = new ttypes.TOperationHandle(args.operationHandle);
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field operationHandle is unset!");
        }
      }
    };
    TGetResultSetMetadataReq.prototype = {};
    TGetResultSetMetadataReq.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.operationHandle = new ttypes.TOperationHandle();
              this.operationHandle.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TGetResultSetMetadataReq.prototype.write = function(output) {
      output.writeStructBegin("TGetResultSetMetadataReq");
      if (this.operationHandle !== null && this.operationHandle !== void 0) {
        output.writeFieldBegin("operationHandle", Thrift.Type.STRUCT, 1);
        this.operationHandle.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TGetResultSetMetadataResp = module2.exports.TGetResultSetMetadataResp = function(args) {
      this.status = null;
      this.schema = null;
      if (args) {
        if (args.status !== void 0 && args.status !== null) {
          this.status = new ttypes.TStatus(args.status);
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field status is unset!");
        }
        if (args.schema !== void 0 && args.schema !== null) {
          this.schema = new ttypes.TTableSchema(args.schema);
        }
      }
    };
    TGetResultSetMetadataResp.prototype = {};
    TGetResultSetMetadataResp.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.status = new ttypes.TStatus();
              this.status.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 2:
            if (ftype == Thrift.Type.STRUCT) {
              this.schema = new ttypes.TTableSchema();
              this.schema.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TGetResultSetMetadataResp.prototype.write = function(output) {
      output.writeStructBegin("TGetResultSetMetadataResp");
      if (this.status !== null && this.status !== void 0) {
        output.writeFieldBegin("status", Thrift.Type.STRUCT, 1);
        this.status.write(output);
        output.writeFieldEnd();
      }
      if (this.schema !== null && this.schema !== void 0) {
        output.writeFieldBegin("schema", Thrift.Type.STRUCT, 2);
        this.schema.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TFetchResultsReq = module2.exports.TFetchResultsReq = function(args) {
      this.operationHandle = null;
      this.orientation = 0;
      this.maxRows = null;
      this.fetchType = 0;
      if (args) {
        if (args.operationHandle !== void 0 && args.operationHandle !== null) {
          this.operationHandle = new ttypes.TOperationHandle(args.operationHandle);
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field operationHandle is unset!");
        }
        if (args.orientation !== void 0 && args.orientation !== null) {
          this.orientation = args.orientation;
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field orientation is unset!");
        }
        if (args.maxRows !== void 0 && args.maxRows !== null) {
          this.maxRows = args.maxRows;
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field maxRows is unset!");
        }
        if (args.fetchType !== void 0 && args.fetchType !== null) {
          this.fetchType = args.fetchType;
        }
      }
    };
    TFetchResultsReq.prototype = {};
    TFetchResultsReq.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.operationHandle = new ttypes.TOperationHandle();
              this.operationHandle.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 2:
            if (ftype == Thrift.Type.I32) {
              this.orientation = input.readI32();
            } else {
              input.skip(ftype);
            }
            break;
          case 3:
            if (ftype == Thrift.Type.I64) {
              this.maxRows = input.readI64();
            } else {
              input.skip(ftype);
            }
            break;
          case 4:
            if (ftype == Thrift.Type.I16) {
              this.fetchType = input.readI16();
            } else {
              input.skip(ftype);
            }
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TFetchResultsReq.prototype.write = function(output) {
      output.writeStructBegin("TFetchResultsReq");
      if (this.operationHandle !== null && this.operationHandle !== void 0) {
        output.writeFieldBegin("operationHandle", Thrift.Type.STRUCT, 1);
        this.operationHandle.write(output);
        output.writeFieldEnd();
      }
      if (this.orientation !== null && this.orientation !== void 0) {
        output.writeFieldBegin("orientation", Thrift.Type.I32, 2);
        output.writeI32(this.orientation);
        output.writeFieldEnd();
      }
      if (this.maxRows !== null && this.maxRows !== void 0) {
        output.writeFieldBegin("maxRows", Thrift.Type.I64, 3);
        output.writeI64(this.maxRows);
        output.writeFieldEnd();
      }
      if (this.fetchType !== null && this.fetchType !== void 0) {
        output.writeFieldBegin("fetchType", Thrift.Type.I16, 4);
        output.writeI16(this.fetchType);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TFetchResultsResp = module2.exports.TFetchResultsResp = function(args) {
      this.status = null;
      this.hasMoreRows = null;
      this.results = null;
      if (args) {
        if (args.status !== void 0 && args.status !== null) {
          this.status = new ttypes.TStatus(args.status);
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field status is unset!");
        }
        if (args.hasMoreRows !== void 0 && args.hasMoreRows !== null) {
          this.hasMoreRows = args.hasMoreRows;
        }
        if (args.results !== void 0 && args.results !== null) {
          this.results = new ttypes.TRowSet(args.results);
        }
      }
    };
    TFetchResultsResp.prototype = {};
    TFetchResultsResp.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.status = new ttypes.TStatus();
              this.status.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 2:
            if (ftype == Thrift.Type.BOOL) {
              this.hasMoreRows = input.readBool();
            } else {
              input.skip(ftype);
            }
            break;
          case 3:
            if (ftype == Thrift.Type.STRUCT) {
              this.results = new ttypes.TRowSet();
              this.results.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TFetchResultsResp.prototype.write = function(output) {
      output.writeStructBegin("TFetchResultsResp");
      if (this.status !== null && this.status !== void 0) {
        output.writeFieldBegin("status", Thrift.Type.STRUCT, 1);
        this.status.write(output);
        output.writeFieldEnd();
      }
      if (this.hasMoreRows !== null && this.hasMoreRows !== void 0) {
        output.writeFieldBegin("hasMoreRows", Thrift.Type.BOOL, 2);
        output.writeBool(this.hasMoreRows);
        output.writeFieldEnd();
      }
      if (this.results !== null && this.results !== void 0) {
        output.writeFieldBegin("results", Thrift.Type.STRUCT, 3);
        this.results.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TGetDelegationTokenReq = module2.exports.TGetDelegationTokenReq = function(args) {
      this.sessionHandle = null;
      this.owner = null;
      this.renewer = null;
      if (args) {
        if (args.sessionHandle !== void 0 && args.sessionHandle !== null) {
          this.sessionHandle = new ttypes.TSessionHandle(args.sessionHandle);
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field sessionHandle is unset!");
        }
        if (args.owner !== void 0 && args.owner !== null) {
          this.owner = args.owner;
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field owner is unset!");
        }
        if (args.renewer !== void 0 && args.renewer !== null) {
          this.renewer = args.renewer;
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field renewer is unset!");
        }
      }
    };
    TGetDelegationTokenReq.prototype = {};
    TGetDelegationTokenReq.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.sessionHandle = new ttypes.TSessionHandle();
              this.sessionHandle.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 2:
            if (ftype == Thrift.Type.STRING) {
              this.owner = input.readString();
            } else {
              input.skip(ftype);
            }
            break;
          case 3:
            if (ftype == Thrift.Type.STRING) {
              this.renewer = input.readString();
            } else {
              input.skip(ftype);
            }
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TGetDelegationTokenReq.prototype.write = function(output) {
      output.writeStructBegin("TGetDelegationTokenReq");
      if (this.sessionHandle !== null && this.sessionHandle !== void 0) {
        output.writeFieldBegin("sessionHandle", Thrift.Type.STRUCT, 1);
        this.sessionHandle.write(output);
        output.writeFieldEnd();
      }
      if (this.owner !== null && this.owner !== void 0) {
        output.writeFieldBegin("owner", Thrift.Type.STRING, 2);
        output.writeString(this.owner);
        output.writeFieldEnd();
      }
      if (this.renewer !== null && this.renewer !== void 0) {
        output.writeFieldBegin("renewer", Thrift.Type.STRING, 3);
        output.writeString(this.renewer);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TGetDelegationTokenResp = module2.exports.TGetDelegationTokenResp = function(args) {
      this.status = null;
      this.delegationToken = null;
      if (args) {
        if (args.status !== void 0 && args.status !== null) {
          this.status = new ttypes.TStatus(args.status);
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field status is unset!");
        }
        if (args.delegationToken !== void 0 && args.delegationToken !== null) {
          this.delegationToken = args.delegationToken;
        }
      }
    };
    TGetDelegationTokenResp.prototype = {};
    TGetDelegationTokenResp.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.status = new ttypes.TStatus();
              this.status.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 2:
            if (ftype == Thrift.Type.STRING) {
              this.delegationToken = input.readString();
            } else {
              input.skip(ftype);
            }
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TGetDelegationTokenResp.prototype.write = function(output) {
      output.writeStructBegin("TGetDelegationTokenResp");
      if (this.status !== null && this.status !== void 0) {
        output.writeFieldBegin("status", Thrift.Type.STRUCT, 1);
        this.status.write(output);
        output.writeFieldEnd();
      }
      if (this.delegationToken !== null && this.delegationToken !== void 0) {
        output.writeFieldBegin("delegationToken", Thrift.Type.STRING, 2);
        output.writeString(this.delegationToken);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TCancelDelegationTokenReq = module2.exports.TCancelDelegationTokenReq = function(args) {
      this.sessionHandle = null;
      this.delegationToken = null;
      if (args) {
        if (args.sessionHandle !== void 0 && args.sessionHandle !== null) {
          this.sessionHandle = new ttypes.TSessionHandle(args.sessionHandle);
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field sessionHandle is unset!");
        }
        if (args.delegationToken !== void 0 && args.delegationToken !== null) {
          this.delegationToken = args.delegationToken;
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field delegationToken is unset!");
        }
      }
    };
    TCancelDelegationTokenReq.prototype = {};
    TCancelDelegationTokenReq.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.sessionHandle = new ttypes.TSessionHandle();
              this.sessionHandle.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 2:
            if (ftype == Thrift.Type.STRING) {
              this.delegationToken = input.readString();
            } else {
              input.skip(ftype);
            }
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TCancelDelegationTokenReq.prototype.write = function(output) {
      output.writeStructBegin("TCancelDelegationTokenReq");
      if (this.sessionHandle !== null && this.sessionHandle !== void 0) {
        output.writeFieldBegin("sessionHandle", Thrift.Type.STRUCT, 1);
        this.sessionHandle.write(output);
        output.writeFieldEnd();
      }
      if (this.delegationToken !== null && this.delegationToken !== void 0) {
        output.writeFieldBegin("delegationToken", Thrift.Type.STRING, 2);
        output.writeString(this.delegationToken);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TCancelDelegationTokenResp = module2.exports.TCancelDelegationTokenResp = function(args) {
      this.status = null;
      if (args) {
        if (args.status !== void 0 && args.status !== null) {
          this.status = new ttypes.TStatus(args.status);
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field status is unset!");
        }
      }
    };
    TCancelDelegationTokenResp.prototype = {};
    TCancelDelegationTokenResp.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.status = new ttypes.TStatus();
              this.status.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TCancelDelegationTokenResp.prototype.write = function(output) {
      output.writeStructBegin("TCancelDelegationTokenResp");
      if (this.status !== null && this.status !== void 0) {
        output.writeFieldBegin("status", Thrift.Type.STRUCT, 1);
        this.status.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TRenewDelegationTokenReq = module2.exports.TRenewDelegationTokenReq = function(args) {
      this.sessionHandle = null;
      this.delegationToken = null;
      if (args) {
        if (args.sessionHandle !== void 0 && args.sessionHandle !== null) {
          this.sessionHandle = new ttypes.TSessionHandle(args.sessionHandle);
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field sessionHandle is unset!");
        }
        if (args.delegationToken !== void 0 && args.delegationToken !== null) {
          this.delegationToken = args.delegationToken;
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field delegationToken is unset!");
        }
      }
    };
    TRenewDelegationTokenReq.prototype = {};
    TRenewDelegationTokenReq.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.sessionHandle = new ttypes.TSessionHandle();
              this.sessionHandle.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 2:
            if (ftype == Thrift.Type.STRING) {
              this.delegationToken = input.readString();
            } else {
              input.skip(ftype);
            }
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TRenewDelegationTokenReq.prototype.write = function(output) {
      output.writeStructBegin("TRenewDelegationTokenReq");
      if (this.sessionHandle !== null && this.sessionHandle !== void 0) {
        output.writeFieldBegin("sessionHandle", Thrift.Type.STRUCT, 1);
        this.sessionHandle.write(output);
        output.writeFieldEnd();
      }
      if (this.delegationToken !== null && this.delegationToken !== void 0) {
        output.writeFieldBegin("delegationToken", Thrift.Type.STRING, 2);
        output.writeString(this.delegationToken);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TRenewDelegationTokenResp = module2.exports.TRenewDelegationTokenResp = function(args) {
      this.status = null;
      if (args) {
        if (args.status !== void 0 && args.status !== null) {
          this.status = new ttypes.TStatus(args.status);
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field status is unset!");
        }
      }
    };
    TRenewDelegationTokenResp.prototype = {};
    TRenewDelegationTokenResp.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.status = new ttypes.TStatus();
              this.status.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TRenewDelegationTokenResp.prototype.write = function(output) {
      output.writeStructBegin("TRenewDelegationTokenResp");
      if (this.status !== null && this.status !== void 0) {
        output.writeFieldBegin("status", Thrift.Type.STRUCT, 1);
        this.status.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TProgressUpdateResp = module2.exports.TProgressUpdateResp = function(args) {
      this.headerNames = null;
      this.rows = null;
      this.progressedPercentage = null;
      this.status = null;
      this.footerSummary = null;
      this.startTime = null;
      if (args) {
        if (args.headerNames !== void 0 && args.headerNames !== null) {
          this.headerNames = Thrift.copyList(args.headerNames, [null]);
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field headerNames is unset!");
        }
        if (args.rows !== void 0 && args.rows !== null) {
          this.rows = Thrift.copyList(args.rows, [Thrift.copyList, null]);
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field rows is unset!");
        }
        if (args.progressedPercentage !== void 0 && args.progressedPercentage !== null) {
          this.progressedPercentage = args.progressedPercentage;
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field progressedPercentage is unset!");
        }
        if (args.status !== void 0 && args.status !== null) {
          this.status = args.status;
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field status is unset!");
        }
        if (args.footerSummary !== void 0 && args.footerSummary !== null) {
          this.footerSummary = args.footerSummary;
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field footerSummary is unset!");
        }
        if (args.startTime !== void 0 && args.startTime !== null) {
          this.startTime = args.startTime;
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field startTime is unset!");
        }
      }
    };
    TProgressUpdateResp.prototype = {};
    TProgressUpdateResp.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.LIST) {
              this.headerNames = [];
              var _rtmp3125 = input.readListBegin();
              var _size124 = _rtmp3125.size || 0;
              for (var _i126 = 0; _i126 < _size124; ++_i126) {
                var elem127 = null;
                elem127 = input.readString();
                this.headerNames.push(elem127);
              }
              input.readListEnd();
            } else {
              input.skip(ftype);
            }
            break;
          case 2:
            if (ftype == Thrift.Type.LIST) {
              this.rows = [];
              var _rtmp3129 = input.readListBegin();
              var _size128 = _rtmp3129.size || 0;
              for (var _i130 = 0; _i130 < _size128; ++_i130) {
                var elem131 = null;
                elem131 = [];
                var _rtmp3133 = input.readListBegin();
                var _size132 = _rtmp3133.size || 0;
                for (var _i134 = 0; _i134 < _size132; ++_i134) {
                  var elem135 = null;
                  elem135 = input.readString();
                  elem131.push(elem135);
                }
                input.readListEnd();
                this.rows.push(elem131);
              }
              input.readListEnd();
            } else {
              input.skip(ftype);
            }
            break;
          case 3:
            if (ftype == Thrift.Type.DOUBLE) {
              this.progressedPercentage = input.readDouble();
            } else {
              input.skip(ftype);
            }
            break;
          case 4:
            if (ftype == Thrift.Type.I32) {
              this.status = input.readI32();
            } else {
              input.skip(ftype);
            }
            break;
          case 5:
            if (ftype == Thrift.Type.STRING) {
              this.footerSummary = input.readString();
            } else {
              input.skip(ftype);
            }
            break;
          case 6:
            if (ftype == Thrift.Type.I64) {
              this.startTime = input.readI64();
            } else {
              input.skip(ftype);
            }
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TProgressUpdateResp.prototype.write = function(output) {
      output.writeStructBegin("TProgressUpdateResp");
      if (this.headerNames !== null && this.headerNames !== void 0) {
        output.writeFieldBegin("headerNames", Thrift.Type.LIST, 1);
        output.writeListBegin(Thrift.Type.STRING, this.headerNames.length);
        for (var iter136 in this.headerNames) {
          if (this.headerNames.hasOwnProperty(iter136)) {
            iter136 = this.headerNames[iter136];
            output.writeString(iter136);
          }
        }
        output.writeListEnd();
        output.writeFieldEnd();
      }
      if (this.rows !== null && this.rows !== void 0) {
        output.writeFieldBegin("rows", Thrift.Type.LIST, 2);
        output.writeListBegin(Thrift.Type.LIST, this.rows.length);
        for (var iter137 in this.rows) {
          if (this.rows.hasOwnProperty(iter137)) {
            iter137 = this.rows[iter137];
            output.writeListBegin(Thrift.Type.STRING, iter137.length);
            for (var iter138 in iter137) {
              if (iter137.hasOwnProperty(iter138)) {
                iter138 = iter137[iter138];
                output.writeString(iter138);
              }
            }
            output.writeListEnd();
          }
        }
        output.writeListEnd();
        output.writeFieldEnd();
      }
      if (this.progressedPercentage !== null && this.progressedPercentage !== void 0) {
        output.writeFieldBegin("progressedPercentage", Thrift.Type.DOUBLE, 3);
        output.writeDouble(this.progressedPercentage);
        output.writeFieldEnd();
      }
      if (this.status !== null && this.status !== void 0) {
        output.writeFieldBegin("status", Thrift.Type.I32, 4);
        output.writeI32(this.status);
        output.writeFieldEnd();
      }
      if (this.footerSummary !== null && this.footerSummary !== void 0) {
        output.writeFieldBegin("footerSummary", Thrift.Type.STRING, 5);
        output.writeString(this.footerSummary);
        output.writeFieldEnd();
      }
      if (this.startTime !== null && this.startTime !== void 0) {
        output.writeFieldBegin("startTime", Thrift.Type.I64, 6);
        output.writeI64(this.startTime);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TGetQueryIdReq = module2.exports.TGetQueryIdReq = function(args) {
      this.operationHandle = null;
      if (args) {
        if (args.operationHandle !== void 0 && args.operationHandle !== null) {
          this.operationHandle = new ttypes.TOperationHandle(args.operationHandle);
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field operationHandle is unset!");
        }
      }
    };
    TGetQueryIdReq.prototype = {};
    TGetQueryIdReq.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.operationHandle = new ttypes.TOperationHandle();
              this.operationHandle.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TGetQueryIdReq.prototype.write = function(output) {
      output.writeStructBegin("TGetQueryIdReq");
      if (this.operationHandle !== null && this.operationHandle !== void 0) {
        output.writeFieldBegin("operationHandle", Thrift.Type.STRUCT, 1);
        this.operationHandle.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TGetQueryIdResp = module2.exports.TGetQueryIdResp = function(args) {
      this.queryId = null;
      if (args) {
        if (args.queryId !== void 0 && args.queryId !== null) {
          this.queryId = args.queryId;
        } else {
          throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, "Required field queryId is unset!");
        }
      }
    };
    TGetQueryIdResp.prototype = {};
    TGetQueryIdResp.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRING) {
              this.queryId = input.readString();
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TGetQueryIdResp.prototype.write = function(output) {
      output.writeStructBegin("TGetQueryIdResp");
      if (this.queryId !== null && this.queryId !== void 0) {
        output.writeFieldBegin("queryId", Thrift.Type.STRING, 1);
        output.writeString(this.queryId);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    ttypes.PRIMITIVE_TYPES = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 15, 16, 17, 18, 19, 20, 21, 22];
    ttypes.COMPLEX_TYPES = [10, 11, 12, 13, 14];
    ttypes.COLLECTION_TYPES = [10, 11];
    ttypes.TYPE_NAMES = {
      10: "ARRAY",
      4: "BIGINT",
      9: "BINARY",
      0: "BOOLEAN",
      19: "CHAR",
      17: "DATE",
      15: "DECIMAL",
      6: "DOUBLE",
      5: "FLOAT",
      21: "INTERVAL_DAY_TIME",
      20: "INTERVAL_YEAR_MONTH",
      3: "INT",
      11: "MAP",
      16: "NULL",
      2: "SMALLINT",
      7: "STRING",
      12: "STRUCT",
      22: "TIMESTAMP WITH LOCAL TIME ZONE",
      8: "TIMESTAMP",
      1: "TINYINT",
      13: "UNIONTYPE",
      18: "VARCHAR"
    };
    ttypes.CHARACTER_MAXIMUM_LENGTH = "characterMaximumLength";
    ttypes.PRECISION = "precision";
    ttypes.SCALE = "scale";
  }
});

// node_modules/hive-driver/thrift/gen-nodejs/TCLIService.js
var require_TCLIService = __commonJS({
  "node_modules/hive-driver/thrift/gen-nodejs/TCLIService.js"(exports) {
    "use strict";
    var thrift = require_thrift2();
    var Thrift = thrift.Thrift;
    var Q = thrift.Q;
    var Int64 = require_Int64();
    var ttypes = require_TCLIService_types();
    var TCLIService_OpenSession_args = function(args) {
      this.req = null;
      if (args) {
        if (args.req !== void 0 && args.req !== null) {
          this.req = new ttypes.TOpenSessionReq(args.req);
        }
      }
    };
    TCLIService_OpenSession_args.prototype = {};
    TCLIService_OpenSession_args.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.req = new ttypes.TOpenSessionReq();
              this.req.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TCLIService_OpenSession_args.prototype.write = function(output) {
      output.writeStructBegin("TCLIService_OpenSession_args");
      if (this.req !== null && this.req !== void 0) {
        output.writeFieldBegin("req", Thrift.Type.STRUCT, 1);
        this.req.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TCLIService_OpenSession_result = function(args) {
      this.success = null;
      if (args) {
        if (args.success !== void 0 && args.success !== null) {
          this.success = new ttypes.TOpenSessionResp(args.success);
        }
      }
    };
    TCLIService_OpenSession_result.prototype = {};
    TCLIService_OpenSession_result.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 0:
            if (ftype == Thrift.Type.STRUCT) {
              this.success = new ttypes.TOpenSessionResp();
              this.success.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TCLIService_OpenSession_result.prototype.write = function(output) {
      output.writeStructBegin("TCLIService_OpenSession_result");
      if (this.success !== null && this.success !== void 0) {
        output.writeFieldBegin("success", Thrift.Type.STRUCT, 0);
        this.success.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TCLIService_CloseSession_args = function(args) {
      this.req = null;
      if (args) {
        if (args.req !== void 0 && args.req !== null) {
          this.req = new ttypes.TCloseSessionReq(args.req);
        }
      }
    };
    TCLIService_CloseSession_args.prototype = {};
    TCLIService_CloseSession_args.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.req = new ttypes.TCloseSessionReq();
              this.req.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TCLIService_CloseSession_args.prototype.write = function(output) {
      output.writeStructBegin("TCLIService_CloseSession_args");
      if (this.req !== null && this.req !== void 0) {
        output.writeFieldBegin("req", Thrift.Type.STRUCT, 1);
        this.req.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TCLIService_CloseSession_result = function(args) {
      this.success = null;
      if (args) {
        if (args.success !== void 0 && args.success !== null) {
          this.success = new ttypes.TCloseSessionResp(args.success);
        }
      }
    };
    TCLIService_CloseSession_result.prototype = {};
    TCLIService_CloseSession_result.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 0:
            if (ftype == Thrift.Type.STRUCT) {
              this.success = new ttypes.TCloseSessionResp();
              this.success.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TCLIService_CloseSession_result.prototype.write = function(output) {
      output.writeStructBegin("TCLIService_CloseSession_result");
      if (this.success !== null && this.success !== void 0) {
        output.writeFieldBegin("success", Thrift.Type.STRUCT, 0);
        this.success.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TCLIService_GetInfo_args = function(args) {
      this.req = null;
      if (args) {
        if (args.req !== void 0 && args.req !== null) {
          this.req = new ttypes.TGetInfoReq(args.req);
        }
      }
    };
    TCLIService_GetInfo_args.prototype = {};
    TCLIService_GetInfo_args.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.req = new ttypes.TGetInfoReq();
              this.req.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TCLIService_GetInfo_args.prototype.write = function(output) {
      output.writeStructBegin("TCLIService_GetInfo_args");
      if (this.req !== null && this.req !== void 0) {
        output.writeFieldBegin("req", Thrift.Type.STRUCT, 1);
        this.req.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TCLIService_GetInfo_result = function(args) {
      this.success = null;
      if (args) {
        if (args.success !== void 0 && args.success !== null) {
          this.success = new ttypes.TGetInfoResp(args.success);
        }
      }
    };
    TCLIService_GetInfo_result.prototype = {};
    TCLIService_GetInfo_result.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 0:
            if (ftype == Thrift.Type.STRUCT) {
              this.success = new ttypes.TGetInfoResp();
              this.success.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TCLIService_GetInfo_result.prototype.write = function(output) {
      output.writeStructBegin("TCLIService_GetInfo_result");
      if (this.success !== null && this.success !== void 0) {
        output.writeFieldBegin("success", Thrift.Type.STRUCT, 0);
        this.success.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TCLIService_ExecuteStatement_args = function(args) {
      this.req = null;
      if (args) {
        if (args.req !== void 0 && args.req !== null) {
          this.req = new ttypes.TExecuteStatementReq(args.req);
        }
      }
    };
    TCLIService_ExecuteStatement_args.prototype = {};
    TCLIService_ExecuteStatement_args.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.req = new ttypes.TExecuteStatementReq();
              this.req.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TCLIService_ExecuteStatement_args.prototype.write = function(output) {
      output.writeStructBegin("TCLIService_ExecuteStatement_args");
      if (this.req !== null && this.req !== void 0) {
        output.writeFieldBegin("req", Thrift.Type.STRUCT, 1);
        this.req.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TCLIService_ExecuteStatement_result = function(args) {
      this.success = null;
      if (args) {
        if (args.success !== void 0 && args.success !== null) {
          this.success = new ttypes.TExecuteStatementResp(args.success);
        }
      }
    };
    TCLIService_ExecuteStatement_result.prototype = {};
    TCLIService_ExecuteStatement_result.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 0:
            if (ftype == Thrift.Type.STRUCT) {
              this.success = new ttypes.TExecuteStatementResp();
              this.success.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TCLIService_ExecuteStatement_result.prototype.write = function(output) {
      output.writeStructBegin("TCLIService_ExecuteStatement_result");
      if (this.success !== null && this.success !== void 0) {
        output.writeFieldBegin("success", Thrift.Type.STRUCT, 0);
        this.success.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TCLIService_GetTypeInfo_args = function(args) {
      this.req = null;
      if (args) {
        if (args.req !== void 0 && args.req !== null) {
          this.req = new ttypes.TGetTypeInfoReq(args.req);
        }
      }
    };
    TCLIService_GetTypeInfo_args.prototype = {};
    TCLIService_GetTypeInfo_args.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.req = new ttypes.TGetTypeInfoReq();
              this.req.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TCLIService_GetTypeInfo_args.prototype.write = function(output) {
      output.writeStructBegin("TCLIService_GetTypeInfo_args");
      if (this.req !== null && this.req !== void 0) {
        output.writeFieldBegin("req", Thrift.Type.STRUCT, 1);
        this.req.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TCLIService_GetTypeInfo_result = function(args) {
      this.success = null;
      if (args) {
        if (args.success !== void 0 && args.success !== null) {
          this.success = new ttypes.TGetTypeInfoResp(args.success);
        }
      }
    };
    TCLIService_GetTypeInfo_result.prototype = {};
    TCLIService_GetTypeInfo_result.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 0:
            if (ftype == Thrift.Type.STRUCT) {
              this.success = new ttypes.TGetTypeInfoResp();
              this.success.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TCLIService_GetTypeInfo_result.prototype.write = function(output) {
      output.writeStructBegin("TCLIService_GetTypeInfo_result");
      if (this.success !== null && this.success !== void 0) {
        output.writeFieldBegin("success", Thrift.Type.STRUCT, 0);
        this.success.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TCLIService_GetCatalogs_args = function(args) {
      this.req = null;
      if (args) {
        if (args.req !== void 0 && args.req !== null) {
          this.req = new ttypes.TGetCatalogsReq(args.req);
        }
      }
    };
    TCLIService_GetCatalogs_args.prototype = {};
    TCLIService_GetCatalogs_args.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.req = new ttypes.TGetCatalogsReq();
              this.req.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TCLIService_GetCatalogs_args.prototype.write = function(output) {
      output.writeStructBegin("TCLIService_GetCatalogs_args");
      if (this.req !== null && this.req !== void 0) {
        output.writeFieldBegin("req", Thrift.Type.STRUCT, 1);
        this.req.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TCLIService_GetCatalogs_result = function(args) {
      this.success = null;
      if (args) {
        if (args.success !== void 0 && args.success !== null) {
          this.success = new ttypes.TGetCatalogsResp(args.success);
        }
      }
    };
    TCLIService_GetCatalogs_result.prototype = {};
    TCLIService_GetCatalogs_result.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 0:
            if (ftype == Thrift.Type.STRUCT) {
              this.success = new ttypes.TGetCatalogsResp();
              this.success.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TCLIService_GetCatalogs_result.prototype.write = function(output) {
      output.writeStructBegin("TCLIService_GetCatalogs_result");
      if (this.success !== null && this.success !== void 0) {
        output.writeFieldBegin("success", Thrift.Type.STRUCT, 0);
        this.success.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TCLIService_GetSchemas_args = function(args) {
      this.req = null;
      if (args) {
        if (args.req !== void 0 && args.req !== null) {
          this.req = new ttypes.TGetSchemasReq(args.req);
        }
      }
    };
    TCLIService_GetSchemas_args.prototype = {};
    TCLIService_GetSchemas_args.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.req = new ttypes.TGetSchemasReq();
              this.req.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TCLIService_GetSchemas_args.prototype.write = function(output) {
      output.writeStructBegin("TCLIService_GetSchemas_args");
      if (this.req !== null && this.req !== void 0) {
        output.writeFieldBegin("req", Thrift.Type.STRUCT, 1);
        this.req.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TCLIService_GetSchemas_result = function(args) {
      this.success = null;
      if (args) {
        if (args.success !== void 0 && args.success !== null) {
          this.success = new ttypes.TGetSchemasResp(args.success);
        }
      }
    };
    TCLIService_GetSchemas_result.prototype = {};
    TCLIService_GetSchemas_result.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 0:
            if (ftype == Thrift.Type.STRUCT) {
              this.success = new ttypes.TGetSchemasResp();
              this.success.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TCLIService_GetSchemas_result.prototype.write = function(output) {
      output.writeStructBegin("TCLIService_GetSchemas_result");
      if (this.success !== null && this.success !== void 0) {
        output.writeFieldBegin("success", Thrift.Type.STRUCT, 0);
        this.success.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TCLIService_GetTables_args = function(args) {
      this.req = null;
      if (args) {
        if (args.req !== void 0 && args.req !== null) {
          this.req = new ttypes.TGetTablesReq(args.req);
        }
      }
    };
    TCLIService_GetTables_args.prototype = {};
    TCLIService_GetTables_args.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.req = new ttypes.TGetTablesReq();
              this.req.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TCLIService_GetTables_args.prototype.write = function(output) {
      output.writeStructBegin("TCLIService_GetTables_args");
      if (this.req !== null && this.req !== void 0) {
        output.writeFieldBegin("req", Thrift.Type.STRUCT, 1);
        this.req.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TCLIService_GetTables_result = function(args) {
      this.success = null;
      if (args) {
        if (args.success !== void 0 && args.success !== null) {
          this.success = new ttypes.TGetTablesResp(args.success);
        }
      }
    };
    TCLIService_GetTables_result.prototype = {};
    TCLIService_GetTables_result.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 0:
            if (ftype == Thrift.Type.STRUCT) {
              this.success = new ttypes.TGetTablesResp();
              this.success.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TCLIService_GetTables_result.prototype.write = function(output) {
      output.writeStructBegin("TCLIService_GetTables_result");
      if (this.success !== null && this.success !== void 0) {
        output.writeFieldBegin("success", Thrift.Type.STRUCT, 0);
        this.success.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TCLIService_GetTableTypes_args = function(args) {
      this.req = null;
      if (args) {
        if (args.req !== void 0 && args.req !== null) {
          this.req = new ttypes.TGetTableTypesReq(args.req);
        }
      }
    };
    TCLIService_GetTableTypes_args.prototype = {};
    TCLIService_GetTableTypes_args.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.req = new ttypes.TGetTableTypesReq();
              this.req.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TCLIService_GetTableTypes_args.prototype.write = function(output) {
      output.writeStructBegin("TCLIService_GetTableTypes_args");
      if (this.req !== null && this.req !== void 0) {
        output.writeFieldBegin("req", Thrift.Type.STRUCT, 1);
        this.req.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TCLIService_GetTableTypes_result = function(args) {
      this.success = null;
      if (args) {
        if (args.success !== void 0 && args.success !== null) {
          this.success = new ttypes.TGetTableTypesResp(args.success);
        }
      }
    };
    TCLIService_GetTableTypes_result.prototype = {};
    TCLIService_GetTableTypes_result.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 0:
            if (ftype == Thrift.Type.STRUCT) {
              this.success = new ttypes.TGetTableTypesResp();
              this.success.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TCLIService_GetTableTypes_result.prototype.write = function(output) {
      output.writeStructBegin("TCLIService_GetTableTypes_result");
      if (this.success !== null && this.success !== void 0) {
        output.writeFieldBegin("success", Thrift.Type.STRUCT, 0);
        this.success.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TCLIService_GetColumns_args = function(args) {
      this.req = null;
      if (args) {
        if (args.req !== void 0 && args.req !== null) {
          this.req = new ttypes.TGetColumnsReq(args.req);
        }
      }
    };
    TCLIService_GetColumns_args.prototype = {};
    TCLIService_GetColumns_args.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.req = new ttypes.TGetColumnsReq();
              this.req.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TCLIService_GetColumns_args.prototype.write = function(output) {
      output.writeStructBegin("TCLIService_GetColumns_args");
      if (this.req !== null && this.req !== void 0) {
        output.writeFieldBegin("req", Thrift.Type.STRUCT, 1);
        this.req.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TCLIService_GetColumns_result = function(args) {
      this.success = null;
      if (args) {
        if (args.success !== void 0 && args.success !== null) {
          this.success = new ttypes.TGetColumnsResp(args.success);
        }
      }
    };
    TCLIService_GetColumns_result.prototype = {};
    TCLIService_GetColumns_result.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 0:
            if (ftype == Thrift.Type.STRUCT) {
              this.success = new ttypes.TGetColumnsResp();
              this.success.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TCLIService_GetColumns_result.prototype.write = function(output) {
      output.writeStructBegin("TCLIService_GetColumns_result");
      if (this.success !== null && this.success !== void 0) {
        output.writeFieldBegin("success", Thrift.Type.STRUCT, 0);
        this.success.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TCLIService_GetFunctions_args = function(args) {
      this.req = null;
      if (args) {
        if (args.req !== void 0 && args.req !== null) {
          this.req = new ttypes.TGetFunctionsReq(args.req);
        }
      }
    };
    TCLIService_GetFunctions_args.prototype = {};
    TCLIService_GetFunctions_args.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.req = new ttypes.TGetFunctionsReq();
              this.req.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TCLIService_GetFunctions_args.prototype.write = function(output) {
      output.writeStructBegin("TCLIService_GetFunctions_args");
      if (this.req !== null && this.req !== void 0) {
        output.writeFieldBegin("req", Thrift.Type.STRUCT, 1);
        this.req.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TCLIService_GetFunctions_result = function(args) {
      this.success = null;
      if (args) {
        if (args.success !== void 0 && args.success !== null) {
          this.success = new ttypes.TGetFunctionsResp(args.success);
        }
      }
    };
    TCLIService_GetFunctions_result.prototype = {};
    TCLIService_GetFunctions_result.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 0:
            if (ftype == Thrift.Type.STRUCT) {
              this.success = new ttypes.TGetFunctionsResp();
              this.success.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TCLIService_GetFunctions_result.prototype.write = function(output) {
      output.writeStructBegin("TCLIService_GetFunctions_result");
      if (this.success !== null && this.success !== void 0) {
        output.writeFieldBegin("success", Thrift.Type.STRUCT, 0);
        this.success.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TCLIService_GetPrimaryKeys_args = function(args) {
      this.req = null;
      if (args) {
        if (args.req !== void 0 && args.req !== null) {
          this.req = new ttypes.TGetPrimaryKeysReq(args.req);
        }
      }
    };
    TCLIService_GetPrimaryKeys_args.prototype = {};
    TCLIService_GetPrimaryKeys_args.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.req = new ttypes.TGetPrimaryKeysReq();
              this.req.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TCLIService_GetPrimaryKeys_args.prototype.write = function(output) {
      output.writeStructBegin("TCLIService_GetPrimaryKeys_args");
      if (this.req !== null && this.req !== void 0) {
        output.writeFieldBegin("req", Thrift.Type.STRUCT, 1);
        this.req.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TCLIService_GetPrimaryKeys_result = function(args) {
      this.success = null;
      if (args) {
        if (args.success !== void 0 && args.success !== null) {
          this.success = new ttypes.TGetPrimaryKeysResp(args.success);
        }
      }
    };
    TCLIService_GetPrimaryKeys_result.prototype = {};
    TCLIService_GetPrimaryKeys_result.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 0:
            if (ftype == Thrift.Type.STRUCT) {
              this.success = new ttypes.TGetPrimaryKeysResp();
              this.success.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TCLIService_GetPrimaryKeys_result.prototype.write = function(output) {
      output.writeStructBegin("TCLIService_GetPrimaryKeys_result");
      if (this.success !== null && this.success !== void 0) {
        output.writeFieldBegin("success", Thrift.Type.STRUCT, 0);
        this.success.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TCLIService_GetCrossReference_args = function(args) {
      this.req = null;
      if (args) {
        if (args.req !== void 0 && args.req !== null) {
          this.req = new ttypes.TGetCrossReferenceReq(args.req);
        }
      }
    };
    TCLIService_GetCrossReference_args.prototype = {};
    TCLIService_GetCrossReference_args.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.req = new ttypes.TGetCrossReferenceReq();
              this.req.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TCLIService_GetCrossReference_args.prototype.write = function(output) {
      output.writeStructBegin("TCLIService_GetCrossReference_args");
      if (this.req !== null && this.req !== void 0) {
        output.writeFieldBegin("req", Thrift.Type.STRUCT, 1);
        this.req.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TCLIService_GetCrossReference_result = function(args) {
      this.success = null;
      if (args) {
        if (args.success !== void 0 && args.success !== null) {
          this.success = new ttypes.TGetCrossReferenceResp(args.success);
        }
      }
    };
    TCLIService_GetCrossReference_result.prototype = {};
    TCLIService_GetCrossReference_result.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 0:
            if (ftype == Thrift.Type.STRUCT) {
              this.success = new ttypes.TGetCrossReferenceResp();
              this.success.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TCLIService_GetCrossReference_result.prototype.write = function(output) {
      output.writeStructBegin("TCLIService_GetCrossReference_result");
      if (this.success !== null && this.success !== void 0) {
        output.writeFieldBegin("success", Thrift.Type.STRUCT, 0);
        this.success.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TCLIService_GetOperationStatus_args = function(args) {
      this.req = null;
      if (args) {
        if (args.req !== void 0 && args.req !== null) {
          this.req = new ttypes.TGetOperationStatusReq(args.req);
        }
      }
    };
    TCLIService_GetOperationStatus_args.prototype = {};
    TCLIService_GetOperationStatus_args.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.req = new ttypes.TGetOperationStatusReq();
              this.req.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TCLIService_GetOperationStatus_args.prototype.write = function(output) {
      output.writeStructBegin("TCLIService_GetOperationStatus_args");
      if (this.req !== null && this.req !== void 0) {
        output.writeFieldBegin("req", Thrift.Type.STRUCT, 1);
        this.req.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TCLIService_GetOperationStatus_result = function(args) {
      this.success = null;
      if (args) {
        if (args.success !== void 0 && args.success !== null) {
          this.success = new ttypes.TGetOperationStatusResp(args.success);
        }
      }
    };
    TCLIService_GetOperationStatus_result.prototype = {};
    TCLIService_GetOperationStatus_result.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 0:
            if (ftype == Thrift.Type.STRUCT) {
              this.success = new ttypes.TGetOperationStatusResp();
              this.success.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TCLIService_GetOperationStatus_result.prototype.write = function(output) {
      output.writeStructBegin("TCLIService_GetOperationStatus_result");
      if (this.success !== null && this.success !== void 0) {
        output.writeFieldBegin("success", Thrift.Type.STRUCT, 0);
        this.success.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TCLIService_CancelOperation_args = function(args) {
      this.req = null;
      if (args) {
        if (args.req !== void 0 && args.req !== null) {
          this.req = new ttypes.TCancelOperationReq(args.req);
        }
      }
    };
    TCLIService_CancelOperation_args.prototype = {};
    TCLIService_CancelOperation_args.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.req = new ttypes.TCancelOperationReq();
              this.req.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TCLIService_CancelOperation_args.prototype.write = function(output) {
      output.writeStructBegin("TCLIService_CancelOperation_args");
      if (this.req !== null && this.req !== void 0) {
        output.writeFieldBegin("req", Thrift.Type.STRUCT, 1);
        this.req.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TCLIService_CancelOperation_result = function(args) {
      this.success = null;
      if (args) {
        if (args.success !== void 0 && args.success !== null) {
          this.success = new ttypes.TCancelOperationResp(args.success);
        }
      }
    };
    TCLIService_CancelOperation_result.prototype = {};
    TCLIService_CancelOperation_result.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 0:
            if (ftype == Thrift.Type.STRUCT) {
              this.success = new ttypes.TCancelOperationResp();
              this.success.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TCLIService_CancelOperation_result.prototype.write = function(output) {
      output.writeStructBegin("TCLIService_CancelOperation_result");
      if (this.success !== null && this.success !== void 0) {
        output.writeFieldBegin("success", Thrift.Type.STRUCT, 0);
        this.success.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TCLIService_CloseOperation_args = function(args) {
      this.req = null;
      if (args) {
        if (args.req !== void 0 && args.req !== null) {
          this.req = new ttypes.TCloseOperationReq(args.req);
        }
      }
    };
    TCLIService_CloseOperation_args.prototype = {};
    TCLIService_CloseOperation_args.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.req = new ttypes.TCloseOperationReq();
              this.req.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TCLIService_CloseOperation_args.prototype.write = function(output) {
      output.writeStructBegin("TCLIService_CloseOperation_args");
      if (this.req !== null && this.req !== void 0) {
        output.writeFieldBegin("req", Thrift.Type.STRUCT, 1);
        this.req.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TCLIService_CloseOperation_result = function(args) {
      this.success = null;
      if (args) {
        if (args.success !== void 0 && args.success !== null) {
          this.success = new ttypes.TCloseOperationResp(args.success);
        }
      }
    };
    TCLIService_CloseOperation_result.prototype = {};
    TCLIService_CloseOperation_result.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 0:
            if (ftype == Thrift.Type.STRUCT) {
              this.success = new ttypes.TCloseOperationResp();
              this.success.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TCLIService_CloseOperation_result.prototype.write = function(output) {
      output.writeStructBegin("TCLIService_CloseOperation_result");
      if (this.success !== null && this.success !== void 0) {
        output.writeFieldBegin("success", Thrift.Type.STRUCT, 0);
        this.success.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TCLIService_GetResultSetMetadata_args = function(args) {
      this.req = null;
      if (args) {
        if (args.req !== void 0 && args.req !== null) {
          this.req = new ttypes.TGetResultSetMetadataReq(args.req);
        }
      }
    };
    TCLIService_GetResultSetMetadata_args.prototype = {};
    TCLIService_GetResultSetMetadata_args.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.req = new ttypes.TGetResultSetMetadataReq();
              this.req.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TCLIService_GetResultSetMetadata_args.prototype.write = function(output) {
      output.writeStructBegin("TCLIService_GetResultSetMetadata_args");
      if (this.req !== null && this.req !== void 0) {
        output.writeFieldBegin("req", Thrift.Type.STRUCT, 1);
        this.req.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TCLIService_GetResultSetMetadata_result = function(args) {
      this.success = null;
      if (args) {
        if (args.success !== void 0 && args.success !== null) {
          this.success = new ttypes.TGetResultSetMetadataResp(args.success);
        }
      }
    };
    TCLIService_GetResultSetMetadata_result.prototype = {};
    TCLIService_GetResultSetMetadata_result.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 0:
            if (ftype == Thrift.Type.STRUCT) {
              this.success = new ttypes.TGetResultSetMetadataResp();
              this.success.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TCLIService_GetResultSetMetadata_result.prototype.write = function(output) {
      output.writeStructBegin("TCLIService_GetResultSetMetadata_result");
      if (this.success !== null && this.success !== void 0) {
        output.writeFieldBegin("success", Thrift.Type.STRUCT, 0);
        this.success.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TCLIService_FetchResults_args = function(args) {
      this.req = null;
      if (args) {
        if (args.req !== void 0 && args.req !== null) {
          this.req = new ttypes.TFetchResultsReq(args.req);
        }
      }
    };
    TCLIService_FetchResults_args.prototype = {};
    TCLIService_FetchResults_args.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.req = new ttypes.TFetchResultsReq();
              this.req.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TCLIService_FetchResults_args.prototype.write = function(output) {
      output.writeStructBegin("TCLIService_FetchResults_args");
      if (this.req !== null && this.req !== void 0) {
        output.writeFieldBegin("req", Thrift.Type.STRUCT, 1);
        this.req.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TCLIService_FetchResults_result = function(args) {
      this.success = null;
      if (args) {
        if (args.success !== void 0 && args.success !== null) {
          this.success = new ttypes.TFetchResultsResp(args.success);
        }
      }
    };
    TCLIService_FetchResults_result.prototype = {};
    TCLIService_FetchResults_result.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 0:
            if (ftype == Thrift.Type.STRUCT) {
              this.success = new ttypes.TFetchResultsResp();
              this.success.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TCLIService_FetchResults_result.prototype.write = function(output) {
      output.writeStructBegin("TCLIService_FetchResults_result");
      if (this.success !== null && this.success !== void 0) {
        output.writeFieldBegin("success", Thrift.Type.STRUCT, 0);
        this.success.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TCLIService_GetDelegationToken_args = function(args) {
      this.req = null;
      if (args) {
        if (args.req !== void 0 && args.req !== null) {
          this.req = new ttypes.TGetDelegationTokenReq(args.req);
        }
      }
    };
    TCLIService_GetDelegationToken_args.prototype = {};
    TCLIService_GetDelegationToken_args.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.req = new ttypes.TGetDelegationTokenReq();
              this.req.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TCLIService_GetDelegationToken_args.prototype.write = function(output) {
      output.writeStructBegin("TCLIService_GetDelegationToken_args");
      if (this.req !== null && this.req !== void 0) {
        output.writeFieldBegin("req", Thrift.Type.STRUCT, 1);
        this.req.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TCLIService_GetDelegationToken_result = function(args) {
      this.success = null;
      if (args) {
        if (args.success !== void 0 && args.success !== null) {
          this.success = new ttypes.TGetDelegationTokenResp(args.success);
        }
      }
    };
    TCLIService_GetDelegationToken_result.prototype = {};
    TCLIService_GetDelegationToken_result.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 0:
            if (ftype == Thrift.Type.STRUCT) {
              this.success = new ttypes.TGetDelegationTokenResp();
              this.success.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TCLIService_GetDelegationToken_result.prototype.write = function(output) {
      output.writeStructBegin("TCLIService_GetDelegationToken_result");
      if (this.success !== null && this.success !== void 0) {
        output.writeFieldBegin("success", Thrift.Type.STRUCT, 0);
        this.success.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TCLIService_CancelDelegationToken_args = function(args) {
      this.req = null;
      if (args) {
        if (args.req !== void 0 && args.req !== null) {
          this.req = new ttypes.TCancelDelegationTokenReq(args.req);
        }
      }
    };
    TCLIService_CancelDelegationToken_args.prototype = {};
    TCLIService_CancelDelegationToken_args.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.req = new ttypes.TCancelDelegationTokenReq();
              this.req.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TCLIService_CancelDelegationToken_args.prototype.write = function(output) {
      output.writeStructBegin("TCLIService_CancelDelegationToken_args");
      if (this.req !== null && this.req !== void 0) {
        output.writeFieldBegin("req", Thrift.Type.STRUCT, 1);
        this.req.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TCLIService_CancelDelegationToken_result = function(args) {
      this.success = null;
      if (args) {
        if (args.success !== void 0 && args.success !== null) {
          this.success = new ttypes.TCancelDelegationTokenResp(args.success);
        }
      }
    };
    TCLIService_CancelDelegationToken_result.prototype = {};
    TCLIService_CancelDelegationToken_result.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 0:
            if (ftype == Thrift.Type.STRUCT) {
              this.success = new ttypes.TCancelDelegationTokenResp();
              this.success.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TCLIService_CancelDelegationToken_result.prototype.write = function(output) {
      output.writeStructBegin("TCLIService_CancelDelegationToken_result");
      if (this.success !== null && this.success !== void 0) {
        output.writeFieldBegin("success", Thrift.Type.STRUCT, 0);
        this.success.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TCLIService_RenewDelegationToken_args = function(args) {
      this.req = null;
      if (args) {
        if (args.req !== void 0 && args.req !== null) {
          this.req = new ttypes.TRenewDelegationTokenReq(args.req);
        }
      }
    };
    TCLIService_RenewDelegationToken_args.prototype = {};
    TCLIService_RenewDelegationToken_args.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.req = new ttypes.TRenewDelegationTokenReq();
              this.req.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TCLIService_RenewDelegationToken_args.prototype.write = function(output) {
      output.writeStructBegin("TCLIService_RenewDelegationToken_args");
      if (this.req !== null && this.req !== void 0) {
        output.writeFieldBegin("req", Thrift.Type.STRUCT, 1);
        this.req.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TCLIService_RenewDelegationToken_result = function(args) {
      this.success = null;
      if (args) {
        if (args.success !== void 0 && args.success !== null) {
          this.success = new ttypes.TRenewDelegationTokenResp(args.success);
        }
      }
    };
    TCLIService_RenewDelegationToken_result.prototype = {};
    TCLIService_RenewDelegationToken_result.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 0:
            if (ftype == Thrift.Type.STRUCT) {
              this.success = new ttypes.TRenewDelegationTokenResp();
              this.success.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TCLIService_RenewDelegationToken_result.prototype.write = function(output) {
      output.writeStructBegin("TCLIService_RenewDelegationToken_result");
      if (this.success !== null && this.success !== void 0) {
        output.writeFieldBegin("success", Thrift.Type.STRUCT, 0);
        this.success.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TCLIService_GetQueryId_args = function(args) {
      this.req = null;
      if (args) {
        if (args.req !== void 0 && args.req !== null) {
          this.req = new ttypes.TGetQueryIdReq(args.req);
        }
      }
    };
    TCLIService_GetQueryId_args.prototype = {};
    TCLIService_GetQueryId_args.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.req = new ttypes.TGetQueryIdReq();
              this.req.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TCLIService_GetQueryId_args.prototype.write = function(output) {
      output.writeStructBegin("TCLIService_GetQueryId_args");
      if (this.req !== null && this.req !== void 0) {
        output.writeFieldBegin("req", Thrift.Type.STRUCT, 1);
        this.req.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TCLIService_GetQueryId_result = function(args) {
      this.success = null;
      if (args) {
        if (args.success !== void 0 && args.success !== null) {
          this.success = new ttypes.TGetQueryIdResp(args.success);
        }
      }
    };
    TCLIService_GetQueryId_result.prototype = {};
    TCLIService_GetQueryId_result.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 0:
            if (ftype == Thrift.Type.STRUCT) {
              this.success = new ttypes.TGetQueryIdResp();
              this.success.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TCLIService_GetQueryId_result.prototype.write = function(output) {
      output.writeStructBegin("TCLIService_GetQueryId_result");
      if (this.success !== null && this.success !== void 0) {
        output.writeFieldBegin("success", Thrift.Type.STRUCT, 0);
        this.success.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TCLIService_SetClientInfo_args = function(args) {
      this.req = null;
      if (args) {
        if (args.req !== void 0 && args.req !== null) {
          this.req = new ttypes.TSetClientInfoReq(args.req);
        }
      }
    };
    TCLIService_SetClientInfo_args.prototype = {};
    TCLIService_SetClientInfo_args.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 1:
            if (ftype == Thrift.Type.STRUCT) {
              this.req = new ttypes.TSetClientInfoReq();
              this.req.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TCLIService_SetClientInfo_args.prototype.write = function(output) {
      output.writeStructBegin("TCLIService_SetClientInfo_args");
      if (this.req !== null && this.req !== void 0) {
        output.writeFieldBegin("req", Thrift.Type.STRUCT, 1);
        this.req.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TCLIService_SetClientInfo_result = function(args) {
      this.success = null;
      if (args) {
        if (args.success !== void 0 && args.success !== null) {
          this.success = new ttypes.TSetClientInfoResp(args.success);
        }
      }
    };
    TCLIService_SetClientInfo_result.prototype = {};
    TCLIService_SetClientInfo_result.prototype.read = function(input) {
      input.readStructBegin();
      while (true) {
        var ret = input.readFieldBegin();
        var ftype = ret.ftype;
        var fid = ret.fid;
        if (ftype == Thrift.Type.STOP) {
          break;
        }
        switch (fid) {
          case 0:
            if (ftype == Thrift.Type.STRUCT) {
              this.success = new ttypes.TSetClientInfoResp();
              this.success.read(input);
            } else {
              input.skip(ftype);
            }
            break;
          case 0:
            input.skip(ftype);
            break;
          default:
            input.skip(ftype);
        }
        input.readFieldEnd();
      }
      input.readStructEnd();
      return;
    };
    TCLIService_SetClientInfo_result.prototype.write = function(output) {
      output.writeStructBegin("TCLIService_SetClientInfo_result");
      if (this.success !== null && this.success !== void 0) {
        output.writeFieldBegin("success", Thrift.Type.STRUCT, 0);
        this.success.write(output);
        output.writeFieldEnd();
      }
      output.writeFieldStop();
      output.writeStructEnd();
      return;
    };
    var TCLIServiceClient = exports.Client = function(output, pClass) {
      this.output = output;
      this.pClass = pClass;
      this._seqid = 0;
      this._reqs = {};
    };
    TCLIServiceClient.prototype = {};
    TCLIServiceClient.prototype.seqid = function() {
      return this._seqid;
    };
    TCLIServiceClient.prototype.new_seqid = function() {
      return this._seqid += 1;
    };
    TCLIServiceClient.prototype.OpenSession = function(req, callback) {
      this._seqid = this.new_seqid();
      if (callback === void 0) {
        var _defer = Q.defer();
        this._reqs[this.seqid()] = function(error, result) {
          if (error) {
            _defer.reject(error);
          } else {
            _defer.resolve(result);
          }
        };
        this.send_OpenSession(req);
        return _defer.promise;
      } else {
        this._reqs[this.seqid()] = callback;
        this.send_OpenSession(req);
      }
    };
    TCLIServiceClient.prototype.send_OpenSession = function(req) {
      var output = new this.pClass(this.output);
      var params = {
        req
      };
      var args = new TCLIService_OpenSession_args(params);
      try {
        output.writeMessageBegin("OpenSession", Thrift.MessageType.CALL, this.seqid());
        args.write(output);
        output.writeMessageEnd();
        return this.output.flush();
      } catch (e) {
        delete this._reqs[this.seqid()];
        if (typeof output.reset === "function") {
          output.reset();
        }
        throw e;
      }
    };
    TCLIServiceClient.prototype.recv_OpenSession = function(input, mtype, rseqid) {
      var callback = this._reqs[rseqid] || function() {
      };
      delete this._reqs[rseqid];
      if (mtype == Thrift.MessageType.EXCEPTION) {
        var x = new Thrift.TApplicationException();
        x.read(input);
        input.readMessageEnd();
        return callback(x);
      }
      var result = new TCLIService_OpenSession_result();
      result.read(input);
      input.readMessageEnd();
      if (null !== result.success) {
        return callback(null, result.success);
      }
      return callback("OpenSession failed: unknown result");
    };
    TCLIServiceClient.prototype.CloseSession = function(req, callback) {
      this._seqid = this.new_seqid();
      if (callback === void 0) {
        var _defer = Q.defer();
        this._reqs[this.seqid()] = function(error, result) {
          if (error) {
            _defer.reject(error);
          } else {
            _defer.resolve(result);
          }
        };
        this.send_CloseSession(req);
        return _defer.promise;
      } else {
        this._reqs[this.seqid()] = callback;
        this.send_CloseSession(req);
      }
    };
    TCLIServiceClient.prototype.send_CloseSession = function(req) {
      var output = new this.pClass(this.output);
      var params = {
        req
      };
      var args = new TCLIService_CloseSession_args(params);
      try {
        output.writeMessageBegin("CloseSession", Thrift.MessageType.CALL, this.seqid());
        args.write(output);
        output.writeMessageEnd();
        return this.output.flush();
      } catch (e) {
        delete this._reqs[this.seqid()];
        if (typeof output.reset === "function") {
          output.reset();
        }
        throw e;
      }
    };
    TCLIServiceClient.prototype.recv_CloseSession = function(input, mtype, rseqid) {
      var callback = this._reqs[rseqid] || function() {
      };
      delete this._reqs[rseqid];
      if (mtype == Thrift.MessageType.EXCEPTION) {
        var x = new Thrift.TApplicationException();
        x.read(input);
        input.readMessageEnd();
        return callback(x);
      }
      var result = new TCLIService_CloseSession_result();
      result.read(input);
      input.readMessageEnd();
      if (null !== result.success) {
        return callback(null, result.success);
      }
      return callback("CloseSession failed: unknown result");
    };
    TCLIServiceClient.prototype.GetInfo = function(req, callback) {
      this._seqid = this.new_seqid();
      if (callback === void 0) {
        var _defer = Q.defer();
        this._reqs[this.seqid()] = function(error, result) {
          if (error) {
            _defer.reject(error);
          } else {
            _defer.resolve(result);
          }
        };
        this.send_GetInfo(req);
        return _defer.promise;
      } else {
        this._reqs[this.seqid()] = callback;
        this.send_GetInfo(req);
      }
    };
    TCLIServiceClient.prototype.send_GetInfo = function(req) {
      var output = new this.pClass(this.output);
      var params = {
        req
      };
      var args = new TCLIService_GetInfo_args(params);
      try {
        output.writeMessageBegin("GetInfo", Thrift.MessageType.CALL, this.seqid());
        args.write(output);
        output.writeMessageEnd();
        return this.output.flush();
      } catch (e) {
        delete this._reqs[this.seqid()];
        if (typeof output.reset === "function") {
          output.reset();
        }
        throw e;
      }
    };
    TCLIServiceClient.prototype.recv_GetInfo = function(input, mtype, rseqid) {
      var callback = this._reqs[rseqid] || function() {
      };
      delete this._reqs[rseqid];
      if (mtype == Thrift.MessageType.EXCEPTION) {
        var x = new Thrift.TApplicationException();
        x.read(input);
        input.readMessageEnd();
        return callback(x);
      }
      var result = new TCLIService_GetInfo_result();
      result.read(input);
      input.readMessageEnd();
      if (null !== result.success) {
        return callback(null, result.success);
      }
      return callback("GetInfo failed: unknown result");
    };
    TCLIServiceClient.prototype.ExecuteStatement = function(req, callback) {
      this._seqid = this.new_seqid();
      if (callback === void 0) {
        var _defer = Q.defer();
        this._reqs[this.seqid()] = function(error, result) {
          if (error) {
            _defer.reject(error);
          } else {
            _defer.resolve(result);
          }
        };
        this.send_ExecuteStatement(req);
        return _defer.promise;
      } else {
        this._reqs[this.seqid()] = callback;
        this.send_ExecuteStatement(req);
      }
    };
    TCLIServiceClient.prototype.send_ExecuteStatement = function(req) {
      var output = new this.pClass(this.output);
      var params = {
        req
      };
      var args = new TCLIService_ExecuteStatement_args(params);
      try {
        output.writeMessageBegin("ExecuteStatement", Thrift.MessageType.CALL, this.seqid());
        args.write(output);
        output.writeMessageEnd();
        return this.output.flush();
      } catch (e) {
        delete this._reqs[this.seqid()];
        if (typeof output.reset === "function") {
          output.reset();
        }
        throw e;
      }
    };
    TCLIServiceClient.prototype.recv_ExecuteStatement = function(input, mtype, rseqid) {
      var callback = this._reqs[rseqid] || function() {
      };
      delete this._reqs[rseqid];
      if (mtype == Thrift.MessageType.EXCEPTION) {
        var x = new Thrift.TApplicationException();
        x.read(input);
        input.readMessageEnd();
        return callback(x);
      }
      var result = new TCLIService_ExecuteStatement_result();
      result.read(input);
      input.readMessageEnd();
      if (null !== result.success) {
        return callback(null, result.success);
      }
      return callback("ExecuteStatement failed: unknown result");
    };
    TCLIServiceClient.prototype.GetTypeInfo = function(req, callback) {
      this._seqid = this.new_seqid();
      if (callback === void 0) {
        var _defer = Q.defer();
        this._reqs[this.seqid()] = function(error, result) {
          if (error) {
            _defer.reject(error);
          } else {
            _defer.resolve(result);
          }
        };
        this.send_GetTypeInfo(req);
        return _defer.promise;
      } else {
        this._reqs[this.seqid()] = callback;
        this.send_GetTypeInfo(req);
      }
    };
    TCLIServiceClient.prototype.send_GetTypeInfo = function(req) {
      var output = new this.pClass(this.output);
      var params = {
        req
      };
      var args = new TCLIService_GetTypeInfo_args(params);
      try {
        output.writeMessageBegin("GetTypeInfo", Thrift.MessageType.CALL, this.seqid());
        args.write(output);
        output.writeMessageEnd();
        return this.output.flush();
      } catch (e) {
        delete this._reqs[this.seqid()];
        if (typeof output.reset === "function") {
          output.reset();
        }
        throw e;
      }
    };
    TCLIServiceClient.prototype.recv_GetTypeInfo = function(input, mtype, rseqid) {
      var callback = this._reqs[rseqid] || function() {
      };
      delete this._reqs[rseqid];
      if (mtype == Thrift.MessageType.EXCEPTION) {
        var x = new Thrift.TApplicationException();
        x.read(input);
        input.readMessageEnd();
        return callback(x);
      }
      var result = new TCLIService_GetTypeInfo_result();
      result.read(input);
      input.readMessageEnd();
      if (null !== result.success) {
        return callback(null, result.success);
      }
      return callback("GetTypeInfo failed: unknown result");
    };
    TCLIServiceClient.prototype.GetCatalogs = function(req, callback) {
      this._seqid = this.new_seqid();
      if (callback === void 0) {
        var _defer = Q.defer();
        this._reqs[this.seqid()] = function(error, result) {
          if (error) {
            _defer.reject(error);
          } else {
            _defer.resolve(result);
          }
        };
        this.send_GetCatalogs(req);
        return _defer.promise;
      } else {
        this._reqs[this.seqid()] = callback;
        this.send_GetCatalogs(req);
      }
    };
    TCLIServiceClient.prototype.send_GetCatalogs = function(req) {
      var output = new this.pClass(this.output);
      var params = {
        req
      };
      var args = new TCLIService_GetCatalogs_args(params);
      try {
        output.writeMessageBegin("GetCatalogs", Thrift.MessageType.CALL, this.seqid());
        args.write(output);
        output.writeMessageEnd();
        return this.output.flush();
      } catch (e) {
        delete this._reqs[this.seqid()];
        if (typeof output.reset === "function") {
          output.reset();
        }
        throw e;
      }
    };
    TCLIServiceClient.prototype.recv_GetCatalogs = function(input, mtype, rseqid) {
      var callback = this._reqs[rseqid] || function() {
      };
      delete this._reqs[rseqid];
      if (mtype == Thrift.MessageType.EXCEPTION) {
        var x = new Thrift.TApplicationException();
        x.read(input);
        input.readMessageEnd();
        return callback(x);
      }
      var result = new TCLIService_GetCatalogs_result();
      result.read(input);
      input.readMessageEnd();
      if (null !== result.success) {
        return callback(null, result.success);
      }
      return callback("GetCatalogs failed: unknown result");
    };
    TCLIServiceClient.prototype.GetSchemas = function(req, callback) {
      this._seqid = this.new_seqid();
      if (callback === void 0) {
        var _defer = Q.defer();
        this._reqs[this.seqid()] = function(error, result) {
          if (error) {
            _defer.reject(error);
          } else {
            _defer.resolve(result);
          }
        };
        this.send_GetSchemas(req);
        return _defer.promise;
      } else {
        this._reqs[this.seqid()] = callback;
        this.send_GetSchemas(req);
      }
    };
    TCLIServiceClient.prototype.send_GetSchemas = function(req) {
      var output = new this.pClass(this.output);
      var params = {
        req
      };
      var args = new TCLIService_GetSchemas_args(params);
      try {
        output.writeMessageBegin("GetSchemas", Thrift.MessageType.CALL, this.seqid());
        args.write(output);
        output.writeMessageEnd();
        return this.output.flush();
      } catch (e) {
        delete this._reqs[this.seqid()];
        if (typeof output.reset === "function") {
          output.reset();
        }
        throw e;
      }
    };
    TCLIServiceClient.prototype.recv_GetSchemas = function(input, mtype, rseqid) {
      var callback = this._reqs[rseqid] || function() {
      };
      delete this._reqs[rseqid];
      if (mtype == Thrift.MessageType.EXCEPTION) {
        var x = new Thrift.TApplicationException();
        x.read(input);
        input.readMessageEnd();
        return callback(x);
      }
      var result = new TCLIService_GetSchemas_result();
      result.read(input);
      input.readMessageEnd();
      if (null !== result.success) {
        return callback(null, result.success);
      }
      return callback("GetSchemas failed: unknown result");
    };
    TCLIServiceClient.prototype.GetTables = function(req, callback) {
      this._seqid = this.new_seqid();
      if (callback === void 0) {
        var _defer = Q.defer();
        this._reqs[this.seqid()] = function(error, result) {
          if (error) {
            _defer.reject(error);
          } else {
            _defer.resolve(result);
          }
        };
        this.send_GetTables(req);
        return _defer.promise;
      } else {
        this._reqs[this.seqid()] = callback;
        this.send_GetTables(req);
      }
    };
    TCLIServiceClient.prototype.send_GetTables = function(req) {
      var output = new this.pClass(this.output);
      var params = {
        req
      };
      var args = new TCLIService_GetTables_args(params);
      try {
        output.writeMessageBegin("GetTables", Thrift.MessageType.CALL, this.seqid());
        args.write(output);
        output.writeMessageEnd();
        return this.output.flush();
      } catch (e) {
        delete this._reqs[this.seqid()];
        if (typeof output.reset === "function") {
          output.reset();
        }
        throw e;
      }
    };
    TCLIServiceClient.prototype.recv_GetTables = function(input, mtype, rseqid) {
      var callback = this._reqs[rseqid] || function() {
      };
      delete this._reqs[rseqid];
      if (mtype == Thrift.MessageType.EXCEPTION) {
        var x = new Thrift.TApplicationException();
        x.read(input);
        input.readMessageEnd();
        return callback(x);
      }
      var result = new TCLIService_GetTables_result();
      result.read(input);
      input.readMessageEnd();
      if (null !== result.success) {
        return callback(null, result.success);
      }
      return callback("GetTables failed: unknown result");
    };
    TCLIServiceClient.prototype.GetTableTypes = function(req, callback) {
      this._seqid = this.new_seqid();
      if (callback === void 0) {
        var _defer = Q.defer();
        this._reqs[this.seqid()] = function(error, result) {
          if (error) {
            _defer.reject(error);
          } else {
            _defer.resolve(result);
          }
        };
        this.send_GetTableTypes(req);
        return _defer.promise;
      } else {
        this._reqs[this.seqid()] = callback;
        this.send_GetTableTypes(req);
      }
    };
    TCLIServiceClient.prototype.send_GetTableTypes = function(req) {
      var output = new this.pClass(this.output);
      var params = {
        req
      };
      var args = new TCLIService_GetTableTypes_args(params);
      try {
        output.writeMessageBegin("GetTableTypes", Thrift.MessageType.CALL, this.seqid());
        args.write(output);
        output.writeMessageEnd();
        return this.output.flush();
      } catch (e) {
        delete this._reqs[this.seqid()];
        if (typeof output.reset === "function") {
          output.reset();
        }
        throw e;
      }
    };
    TCLIServiceClient.prototype.recv_GetTableTypes = function(input, mtype, rseqid) {
      var callback = this._reqs[rseqid] || function() {
      };
      delete this._reqs[rseqid];
      if (mtype == Thrift.MessageType.EXCEPTION) {
        var x = new Thrift.TApplicationException();
        x.read(input);
        input.readMessageEnd();
        return callback(x);
      }
      var result = new TCLIService_GetTableTypes_result();
      result.read(input);
      input.readMessageEnd();
      if (null !== result.success) {
        return callback(null, result.success);
      }
      return callback("GetTableTypes failed: unknown result");
    };
    TCLIServiceClient.prototype.GetColumns = function(req, callback) {
      this._seqid = this.new_seqid();
      if (callback === void 0) {
        var _defer = Q.defer();
        this._reqs[this.seqid()] = function(error, result) {
          if (error) {
            _defer.reject(error);
          } else {
            _defer.resolve(result);
          }
        };
        this.send_GetColumns(req);
        return _defer.promise;
      } else {
        this._reqs[this.seqid()] = callback;
        this.send_GetColumns(req);
      }
    };
    TCLIServiceClient.prototype.send_GetColumns = function(req) {
      var output = new this.pClass(this.output);
      var params = {
        req
      };
      var args = new TCLIService_GetColumns_args(params);
      try {
        output.writeMessageBegin("GetColumns", Thrift.MessageType.CALL, this.seqid());
        args.write(output);
        output.writeMessageEnd();
        return this.output.flush();
      } catch (e) {
        delete this._reqs[this.seqid()];
        if (typeof output.reset === "function") {
          output.reset();
        }
        throw e;
      }
    };
    TCLIServiceClient.prototype.recv_GetColumns = function(input, mtype, rseqid) {
      var callback = this._reqs[rseqid] || function() {
      };
      delete this._reqs[rseqid];
      if (mtype == Thrift.MessageType.EXCEPTION) {
        var x = new Thrift.TApplicationException();
        x.read(input);
        input.readMessageEnd();
        return callback(x);
      }
      var result = new TCLIService_GetColumns_result();
      result.read(input);
      input.readMessageEnd();
      if (null !== result.success) {
        return callback(null, result.success);
      }
      return callback("GetColumns failed: unknown result");
    };
    TCLIServiceClient.prototype.GetFunctions = function(req, callback) {
      this._seqid = this.new_seqid();
      if (callback === void 0) {
        var _defer = Q.defer();
        this._reqs[this.seqid()] = function(error, result) {
          if (error) {
            _defer.reject(error);
          } else {
            _defer.resolve(result);
          }
        };
        this.send_GetFunctions(req);
        return _defer.promise;
      } else {
        this._reqs[this.seqid()] = callback;
        this.send_GetFunctions(req);
      }
    };
    TCLIServiceClient.prototype.send_GetFunctions = function(req) {
      var output = new this.pClass(this.output);
      var params = {
        req
      };
      var args = new TCLIService_GetFunctions_args(params);
      try {
        output.writeMessageBegin("GetFunctions", Thrift.MessageType.CALL, this.seqid());
        args.write(output);
        output.writeMessageEnd();
        return this.output.flush();
      } catch (e) {
        delete this._reqs[this.seqid()];
        if (typeof output.reset === "function") {
          output.reset();
        }
        throw e;
      }
    };
    TCLIServiceClient.prototype.recv_GetFunctions = function(input, mtype, rseqid) {
      var callback = this._reqs[rseqid] || function() {
      };
      delete this._reqs[rseqid];
      if (mtype == Thrift.MessageType.EXCEPTION) {
        var x = new Thrift.TApplicationException();
        x.read(input);
        input.readMessageEnd();
        return callback(x);
      }
      var result = new TCLIService_GetFunctions_result();
      result.read(input);
      input.readMessageEnd();
      if (null !== result.success) {
        return callback(null, result.success);
      }
      return callback("GetFunctions failed: unknown result");
    };
    TCLIServiceClient.prototype.GetPrimaryKeys = function(req, callback) {
      this._seqid = this.new_seqid();
      if (callback === void 0) {
        var _defer = Q.defer();
        this._reqs[this.seqid()] = function(error, result) {
          if (error) {
            _defer.reject(error);
          } else {
            _defer.resolve(result);
          }
        };
        this.send_GetPrimaryKeys(req);
        return _defer.promise;
      } else {
        this._reqs[this.seqid()] = callback;
        this.send_GetPrimaryKeys(req);
      }
    };
    TCLIServiceClient.prototype.send_GetPrimaryKeys = function(req) {
      var output = new this.pClass(this.output);
      var params = {
        req
      };
      var args = new TCLIService_GetPrimaryKeys_args(params);
      try {
        output.writeMessageBegin("GetPrimaryKeys", Thrift.MessageType.CALL, this.seqid());
        args.write(output);
        output.writeMessageEnd();
        return this.output.flush();
      } catch (e) {
        delete this._reqs[this.seqid()];
        if (typeof output.reset === "function") {
          output.reset();
        }
        throw e;
      }
    };
    TCLIServiceClient.prototype.recv_GetPrimaryKeys = function(input, mtype, rseqid) {
      var callback = this._reqs[rseqid] || function() {
      };
      delete this._reqs[rseqid];
      if (mtype == Thrift.MessageType.EXCEPTION) {
        var x = new Thrift.TApplicationException();
        x.read(input);
        input.readMessageEnd();
        return callback(x);
      }
      var result = new TCLIService_GetPrimaryKeys_result();
      result.read(input);
      input.readMessageEnd();
      if (null !== result.success) {
        return callback(null, result.success);
      }
      return callback("GetPrimaryKeys failed: unknown result");
    };
    TCLIServiceClient.prototype.GetCrossReference = function(req, callback) {
      this._seqid = this.new_seqid();
      if (callback === void 0) {
        var _defer = Q.defer();
        this._reqs[this.seqid()] = function(error, result) {
          if (error) {
            _defer.reject(error);
          } else {
            _defer.resolve(result);
          }
        };
        this.send_GetCrossReference(req);
        return _defer.promise;
      } else {
        this._reqs[this.seqid()] = callback;
        this.send_GetCrossReference(req);
      }
    };
    TCLIServiceClient.prototype.send_GetCrossReference = function(req) {
      var output = new this.pClass(this.output);
      var params = {
        req
      };
      var args = new TCLIService_GetCrossReference_args(params);
      try {
        output.writeMessageBegin("GetCrossReference", Thrift.MessageType.CALL, this.seqid());
        args.write(output);
        output.writeMessageEnd();
        return this.output.flush();
      } catch (e) {
        delete this._reqs[this.seqid()];
        if (typeof output.reset === "function") {
          output.reset();
        }
        throw e;
      }
    };
    TCLIServiceClient.prototype.recv_GetCrossReference = function(input, mtype, rseqid) {
      var callback = this._reqs[rseqid] || function() {
      };
      delete this._reqs[rseqid];
      if (mtype == Thrift.MessageType.EXCEPTION) {
        var x = new Thrift.TApplicationException();
        x.read(input);
        input.readMessageEnd();
        return callback(x);
      }
      var result = new TCLIService_GetCrossReference_result();
      result.read(input);
      input.readMessageEnd();
      if (null !== result.success) {
        return callback(null, result.success);
      }
      return callback("GetCrossReference failed: unknown result");
    };
    TCLIServiceClient.prototype.GetOperationStatus = function(req, callback) {
      this._seqid = this.new_seqid();
      if (callback === void 0) {
        var _defer = Q.defer();
        this._reqs[this.seqid()] = function(error, result) {
          if (error) {
            _defer.reject(error);
          } else {
            _defer.resolve(result);
          }
        };
        this.send_GetOperationStatus(req);
        return _defer.promise;
      } else {
        this._reqs[this.seqid()] = callback;
        this.send_GetOperationStatus(req);
      }
    };
    TCLIServiceClient.prototype.send_GetOperationStatus = function(req) {
      var output = new this.pClass(this.output);
      var params = {
        req
      };
      var args = new TCLIService_GetOperationStatus_args(params);
      try {
        output.writeMessageBegin("GetOperationStatus", Thrift.MessageType.CALL, this.seqid());
        args.write(output);
        output.writeMessageEnd();
        return this.output.flush();
      } catch (e) {
        delete this._reqs[this.seqid()];
        if (typeof output.reset === "function") {
          output.reset();
        }
        throw e;
      }
    };
    TCLIServiceClient.prototype.recv_GetOperationStatus = function(input, mtype, rseqid) {
      var callback = this._reqs[rseqid] || function() {
      };
      delete this._reqs[rseqid];
      if (mtype == Thrift.MessageType.EXCEPTION) {
        var x = new Thrift.TApplicationException();
        x.read(input);
        input.readMessageEnd();
        return callback(x);
      }
      var result = new TCLIService_GetOperationStatus_result();
      result.read(input);
      input.readMessageEnd();
      if (null !== result.success) {
        return callback(null, result.success);
      }
      return callback("GetOperationStatus failed: unknown result");
    };
    TCLIServiceClient.prototype.CancelOperation = function(req, callback) {
      this._seqid = this.new_seqid();
      if (callback === void 0) {
        var _defer = Q.defer();
        this._reqs[this.seqid()] = function(error, result) {
          if (error) {
            _defer.reject(error);
          } else {
            _defer.resolve(result);
          }
        };
        this.send_CancelOperation(req);
        return _defer.promise;
      } else {
        this._reqs[this.seqid()] = callback;
        this.send_CancelOperation(req);
      }
    };
    TCLIServiceClient.prototype.send_CancelOperation = function(req) {
      var output = new this.pClass(this.output);
      var params = {
        req
      };
      var args = new TCLIService_CancelOperation_args(params);
      try {
        output.writeMessageBegin("CancelOperation", Thrift.MessageType.CALL, this.seqid());
        args.write(output);
        output.writeMessageEnd();
        return this.output.flush();
      } catch (e) {
        delete this._reqs[this.seqid()];
        if (typeof output.reset === "function") {
          output.reset();
        }
        throw e;
      }
    };
    TCLIServiceClient.prototype.recv_CancelOperation = function(input, mtype, rseqid) {
      var callback = this._reqs[rseqid] || function() {
      };
      delete this._reqs[rseqid];
      if (mtype == Thrift.MessageType.EXCEPTION) {
        var x = new Thrift.TApplicationException();
        x.read(input);
        input.readMessageEnd();
        return callback(x);
      }
      var result = new TCLIService_CancelOperation_result();
      result.read(input);
      input.readMessageEnd();
      if (null !== result.success) {
        return callback(null, result.success);
      }
      return callback("CancelOperation failed: unknown result");
    };
    TCLIServiceClient.prototype.CloseOperation = function(req, callback) {
      this._seqid = this.new_seqid();
      if (callback === void 0) {
        var _defer = Q.defer();
        this._reqs[this.seqid()] = function(error, result) {
          if (error) {
            _defer.reject(error);
          } else {
            _defer.resolve(result);
          }
        };
        this.send_CloseOperation(req);
        return _defer.promise;
      } else {
        this._reqs[this.seqid()] = callback;
        this.send_CloseOperation(req);
      }
    };
    TCLIServiceClient.prototype.send_CloseOperation = function(req) {
      var output = new this.pClass(this.output);
      var params = {
        req
      };
      var args = new TCLIService_CloseOperation_args(params);
      try {
        output.writeMessageBegin("CloseOperation", Thrift.MessageType.CALL, this.seqid());
        args.write(output);
        output.writeMessageEnd();
        return this.output.flush();
      } catch (e) {
        delete this._reqs[this.seqid()];
        if (typeof output.reset === "function") {
          output.reset();
        }
        throw e;
      }
    };
    TCLIServiceClient.prototype.recv_CloseOperation = function(input, mtype, rseqid) {
      var callback = this._reqs[rseqid] || function() {
      };
      delete this._reqs[rseqid];
      if (mtype == Thrift.MessageType.EXCEPTION) {
        var x = new Thrift.TApplicationException();
        x.read(input);
        input.readMessageEnd();
        return callback(x);
      }
      var result = new TCLIService_CloseOperation_result();
      result.read(input);
      input.readMessageEnd();
      if (null !== result.success) {
        return callback(null, result.success);
      }
      return callback("CloseOperation failed: unknown result");
    };
    TCLIServiceClient.prototype.GetResultSetMetadata = function(req, callback) {
      this._seqid = this.new_seqid();
      if (callback === void 0) {
        var _defer = Q.defer();
        this._reqs[this.seqid()] = function(error, result) {
          if (error) {
            _defer.reject(error);
          } else {
            _defer.resolve(result);
          }
        };
        this.send_GetResultSetMetadata(req);
        return _defer.promise;
      } else {
        this._reqs[this.seqid()] = callback;
        this.send_GetResultSetMetadata(req);
      }
    };
    TCLIServiceClient.prototype.send_GetResultSetMetadata = function(req) {
      var output = new this.pClass(this.output);
      var params = {
        req
      };
      var args = new TCLIService_GetResultSetMetadata_args(params);
      try {
        output.writeMessageBegin("GetResultSetMetadata", Thrift.MessageType.CALL, this.seqid());
        args.write(output);
        output.writeMessageEnd();
        return this.output.flush();
      } catch (e) {
        delete this._reqs[this.seqid()];
        if (typeof output.reset === "function") {
          output.reset();
        }
        throw e;
      }
    };
    TCLIServiceClient.prototype.recv_GetResultSetMetadata = function(input, mtype, rseqid) {
      var callback = this._reqs[rseqid] || function() {
      };
      delete this._reqs[rseqid];
      if (mtype == Thrift.MessageType.EXCEPTION) {
        var x = new Thrift.TApplicationException();
        x.read(input);
        input.readMessageEnd();
        return callback(x);
      }
      var result = new TCLIService_GetResultSetMetadata_result();
      result.read(input);
      input.readMessageEnd();
      if (null !== result.success) {
        return callback(null, result.success);
      }
      return callback("GetResultSetMetadata failed: unknown result");
    };
    TCLIServiceClient.prototype.FetchResults = function(req, callback) {
      this._seqid = this.new_seqid();
      if (callback === void 0) {
        var _defer = Q.defer();
        this._reqs[this.seqid()] = function(error, result) {
          if (error) {
            _defer.reject(error);
          } else {
            _defer.resolve(result);
          }
        };
        this.send_FetchResults(req);
        return _defer.promise;
      } else {
        this._reqs[this.seqid()] = callback;
        this.send_FetchResults(req);
      }
    };
    TCLIServiceClient.prototype.send_FetchResults = function(req) {
      var output = new this.pClass(this.output);
      var params = {
        req
      };
      var args = new TCLIService_FetchResults_args(params);
      try {
        output.writeMessageBegin("FetchResults", Thrift.MessageType.CALL, this.seqid());
        args.write(output);
        output.writeMessageEnd();
        return this.output.flush();
      } catch (e) {
        delete this._reqs[this.seqid()];
        if (typeof output.reset === "function") {
          output.reset();
        }
        throw e;
      }
    };
    TCLIServiceClient.prototype.recv_FetchResults = function(input, mtype, rseqid) {
      var callback = this._reqs[rseqid] || function() {
      };
      delete this._reqs[rseqid];
      if (mtype == Thrift.MessageType.EXCEPTION) {
        var x = new Thrift.TApplicationException();
        x.read(input);
        input.readMessageEnd();
        return callback(x);
      }
      var result = new TCLIService_FetchResults_result();
      result.read(input);
      input.readMessageEnd();
      if (null !== result.success) {
        return callback(null, result.success);
      }
      return callback("FetchResults failed: unknown result");
    };
    TCLIServiceClient.prototype.GetDelegationToken = function(req, callback) {
      this._seqid = this.new_seqid();
      if (callback === void 0) {
        var _defer = Q.defer();
        this._reqs[this.seqid()] = function(error, result) {
          if (error) {
            _defer.reject(error);
          } else {
            _defer.resolve(result);
          }
        };
        this.send_GetDelegationToken(req);
        return _defer.promise;
      } else {
        this._reqs[this.seqid()] = callback;
        this.send_GetDelegationToken(req);
      }
    };
    TCLIServiceClient.prototype.send_GetDelegationToken = function(req) {
      var output = new this.pClass(this.output);
      var params = {
        req
      };
      var args = new TCLIService_GetDelegationToken_args(params);
      try {
        output.writeMessageBegin("GetDelegationToken", Thrift.MessageType.CALL, this.seqid());
        args.write(output);
        output.writeMessageEnd();
        return this.output.flush();
      } catch (e) {
        delete this._reqs[this.seqid()];
        if (typeof output.reset === "function") {
          output.reset();
        }
        throw e;
      }
    };
    TCLIServiceClient.prototype.recv_GetDelegationToken = function(input, mtype, rseqid) {
      var callback = this._reqs[rseqid] || function() {
      };
      delete this._reqs[rseqid];
      if (mtype == Thrift.MessageType.EXCEPTION) {
        var x = new Thrift.TApplicationException();
        x.read(input);
        input.readMessageEnd();
        return callback(x);
      }
      var result = new TCLIService_GetDelegationToken_result();
      result.read(input);
      input.readMessageEnd();
      if (null !== result.success) {
        return callback(null, result.success);
      }
      return callback("GetDelegationToken failed: unknown result");
    };
    TCLIServiceClient.prototype.CancelDelegationToken = function(req, callback) {
      this._seqid = this.new_seqid();
      if (callback === void 0) {
        var _defer = Q.defer();
        this._reqs[this.seqid()] = function(error, result) {
          if (error) {
            _defer.reject(error);
          } else {
            _defer.resolve(result);
          }
        };
        this.send_CancelDelegationToken(req);
        return _defer.promise;
      } else {
        this._reqs[this.seqid()] = callback;
        this.send_CancelDelegationToken(req);
      }
    };
    TCLIServiceClient.prototype.send_CancelDelegationToken = function(req) {
      var output = new this.pClass(this.output);
      var params = {
        req
      };
      var args = new TCLIService_CancelDelegationToken_args(params);
      try {
        output.writeMessageBegin("CancelDelegationToken", Thrift.MessageType.CALL, this.seqid());
        args.write(output);
        output.writeMessageEnd();
        return this.output.flush();
      } catch (e) {
        delete this._reqs[this.seqid()];
        if (typeof output.reset === "function") {
          output.reset();
        }
        throw e;
      }
    };
    TCLIServiceClient.prototype.recv_CancelDelegationToken = function(input, mtype, rseqid) {
      var callback = this._reqs[rseqid] || function() {
      };
      delete this._reqs[rseqid];
      if (mtype == Thrift.MessageType.EXCEPTION) {
        var x = new Thrift.TApplicationException();
        x.read(input);
        input.readMessageEnd();
        return callback(x);
      }
      var result = new TCLIService_CancelDelegationToken_result();
      result.read(input);
      input.readMessageEnd();
      if (null !== result.success) {
        return callback(null, result.success);
      }
      return callback("CancelDelegationToken failed: unknown result");
    };
    TCLIServiceClient.prototype.RenewDelegationToken = function(req, callback) {
      this._seqid = this.new_seqid();
      if (callback === void 0) {
        var _defer = Q.defer();
        this._reqs[this.seqid()] = function(error, result) {
          if (error) {
            _defer.reject(error);
          } else {
            _defer.resolve(result);
          }
        };
        this.send_RenewDelegationToken(req);
        return _defer.promise;
      } else {
        this._reqs[this.seqid()] = callback;
        this.send_RenewDelegationToken(req);
      }
    };
    TCLIServiceClient.prototype.send_RenewDelegationToken = function(req) {
      var output = new this.pClass(this.output);
      var params = {
        req
      };
      var args = new TCLIService_RenewDelegationToken_args(params);
      try {
        output.writeMessageBegin("RenewDelegationToken", Thrift.MessageType.CALL, this.seqid());
        args.write(output);
        output.writeMessageEnd();
        return this.output.flush();
      } catch (e) {
        delete this._reqs[this.seqid()];
        if (typeof output.reset === "function") {
          output.reset();
        }
        throw e;
      }
    };
    TCLIServiceClient.prototype.recv_RenewDelegationToken = function(input, mtype, rseqid) {
      var callback = this._reqs[rseqid] || function() {
      };
      delete this._reqs[rseqid];
      if (mtype == Thrift.MessageType.EXCEPTION) {
        var x = new Thrift.TApplicationException();
        x.read(input);
        input.readMessageEnd();
        return callback(x);
      }
      var result = new TCLIService_RenewDelegationToken_result();
      result.read(input);
      input.readMessageEnd();
      if (null !== result.success) {
        return callback(null, result.success);
      }
      return callback("RenewDelegationToken failed: unknown result");
    };
    TCLIServiceClient.prototype.GetQueryId = function(req, callback) {
      this._seqid = this.new_seqid();
      if (callback === void 0) {
        var _defer = Q.defer();
        this._reqs[this.seqid()] = function(error, result) {
          if (error) {
            _defer.reject(error);
          } else {
            _defer.resolve(result);
          }
        };
        this.send_GetQueryId(req);
        return _defer.promise;
      } else {
        this._reqs[this.seqid()] = callback;
        this.send_GetQueryId(req);
      }
    };
    TCLIServiceClient.prototype.send_GetQueryId = function(req) {
      var output = new this.pClass(this.output);
      var params = {
        req
      };
      var args = new TCLIService_GetQueryId_args(params);
      try {
        output.writeMessageBegin("GetQueryId", Thrift.MessageType.CALL, this.seqid());
        args.write(output);
        output.writeMessageEnd();
        return this.output.flush();
      } catch (e) {
        delete this._reqs[this.seqid()];
        if (typeof output.reset === "function") {
          output.reset();
        }
        throw e;
      }
    };
    TCLIServiceClient.prototype.recv_GetQueryId = function(input, mtype, rseqid) {
      var callback = this._reqs[rseqid] || function() {
      };
      delete this._reqs[rseqid];
      if (mtype == Thrift.MessageType.EXCEPTION) {
        var x = new Thrift.TApplicationException();
        x.read(input);
        input.readMessageEnd();
        return callback(x);
      }
      var result = new TCLIService_GetQueryId_result();
      result.read(input);
      input.readMessageEnd();
      if (null !== result.success) {
        return callback(null, result.success);
      }
      return callback("GetQueryId failed: unknown result");
    };
    TCLIServiceClient.prototype.SetClientInfo = function(req, callback) {
      this._seqid = this.new_seqid();
      if (callback === void 0) {
        var _defer = Q.defer();
        this._reqs[this.seqid()] = function(error, result) {
          if (error) {
            _defer.reject(error);
          } else {
            _defer.resolve(result);
          }
        };
        this.send_SetClientInfo(req);
        return _defer.promise;
      } else {
        this._reqs[this.seqid()] = callback;
        this.send_SetClientInfo(req);
      }
    };
    TCLIServiceClient.prototype.send_SetClientInfo = function(req) {
      var output = new this.pClass(this.output);
      var params = {
        req
      };
      var args = new TCLIService_SetClientInfo_args(params);
      try {
        output.writeMessageBegin("SetClientInfo", Thrift.MessageType.CALL, this.seqid());
        args.write(output);
        output.writeMessageEnd();
        return this.output.flush();
      } catch (e) {
        delete this._reqs[this.seqid()];
        if (typeof output.reset === "function") {
          output.reset();
        }
        throw e;
      }
    };
    TCLIServiceClient.prototype.recv_SetClientInfo = function(input, mtype, rseqid) {
      var callback = this._reqs[rseqid] || function() {
      };
      delete this._reqs[rseqid];
      if (mtype == Thrift.MessageType.EXCEPTION) {
        var x = new Thrift.TApplicationException();
        x.read(input);
        input.readMessageEnd();
        return callback(x);
      }
      var result = new TCLIService_SetClientInfo_result();
      result.read(input);
      input.readMessageEnd();
      if (null !== result.success) {
        return callback(null, result.success);
      }
      return callback("SetClientInfo failed: unknown result");
    };
    var TCLIServiceProcessor = exports.Processor = function(handler) {
      this._handler = handler;
    };
    TCLIServiceProcessor.prototype.process = function(input, output) {
      var r = input.readMessageBegin();
      if (this["process_" + r.fname]) {
        return this["process_" + r.fname].call(this, r.rseqid, input, output);
      } else {
        input.skip(Thrift.Type.STRUCT);
        input.readMessageEnd();
        var x = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN_METHOD, "Unknown function " + r.fname);
        output.writeMessageBegin(r.fname, Thrift.MessageType.EXCEPTION, r.rseqid);
        x.write(output);
        output.writeMessageEnd();
        output.flush();
      }
    };
    TCLIServiceProcessor.prototype.process_OpenSession = function(seqid, input, output) {
      var args = new TCLIService_OpenSession_args();
      args.read(input);
      input.readMessageEnd();
      if (this._handler.OpenSession.length === 1) {
        Q.fcall(
          this._handler.OpenSession.bind(this._handler),
          args.req
        ).then(function(result) {
          var result_obj = new TCLIService_OpenSession_result({ success: result });
          output.writeMessageBegin("OpenSession", Thrift.MessageType.REPLY, seqid);
          result_obj.write(output);
          output.writeMessageEnd();
          output.flush();
        }).catch(function(err) {
          var result;
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("OpenSession", Thrift.MessageType.EXCEPTION, seqid);
          result.write(output);
          output.writeMessageEnd();
          output.flush();
        });
      } else {
        this._handler.OpenSession(args.req, function(err, result) {
          var result_obj;
          if (err === null || typeof err === "undefined") {
            result_obj = new TCLIService_OpenSession_result(err !== null || typeof err === "undefined" ? err : { success: result });
            output.writeMessageBegin("OpenSession", Thrift.MessageType.REPLY, seqid);
          } else {
            result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("OpenSession", Thrift.MessageType.EXCEPTION, seqid);
          }
          result_obj.write(output);
          output.writeMessageEnd();
          output.flush();
        });
      }
    };
    TCLIServiceProcessor.prototype.process_CloseSession = function(seqid, input, output) {
      var args = new TCLIService_CloseSession_args();
      args.read(input);
      input.readMessageEnd();
      if (this._handler.CloseSession.length === 1) {
        Q.fcall(
          this._handler.CloseSession.bind(this._handler),
          args.req
        ).then(function(result) {
          var result_obj = new TCLIService_CloseSession_result({ success: result });
          output.writeMessageBegin("CloseSession", Thrift.MessageType.REPLY, seqid);
          result_obj.write(output);
          output.writeMessageEnd();
          output.flush();
        }).catch(function(err) {
          var result;
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("CloseSession", Thrift.MessageType.EXCEPTION, seqid);
          result.write(output);
          output.writeMessageEnd();
          output.flush();
        });
      } else {
        this._handler.CloseSession(args.req, function(err, result) {
          var result_obj;
          if (err === null || typeof err === "undefined") {
            result_obj = new TCLIService_CloseSession_result(err !== null || typeof err === "undefined" ? err : { success: result });
            output.writeMessageBegin("CloseSession", Thrift.MessageType.REPLY, seqid);
          } else {
            result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("CloseSession", Thrift.MessageType.EXCEPTION, seqid);
          }
          result_obj.write(output);
          output.writeMessageEnd();
          output.flush();
        });
      }
    };
    TCLIServiceProcessor.prototype.process_GetInfo = function(seqid, input, output) {
      var args = new TCLIService_GetInfo_args();
      args.read(input);
      input.readMessageEnd();
      if (this._handler.GetInfo.length === 1) {
        Q.fcall(
          this._handler.GetInfo.bind(this._handler),
          args.req
        ).then(function(result) {
          var result_obj = new TCLIService_GetInfo_result({ success: result });
          output.writeMessageBegin("GetInfo", Thrift.MessageType.REPLY, seqid);
          result_obj.write(output);
          output.writeMessageEnd();
          output.flush();
        }).catch(function(err) {
          var result;
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("GetInfo", Thrift.MessageType.EXCEPTION, seqid);
          result.write(output);
          output.writeMessageEnd();
          output.flush();
        });
      } else {
        this._handler.GetInfo(args.req, function(err, result) {
          var result_obj;
          if (err === null || typeof err === "undefined") {
            result_obj = new TCLIService_GetInfo_result(err !== null || typeof err === "undefined" ? err : { success: result });
            output.writeMessageBegin("GetInfo", Thrift.MessageType.REPLY, seqid);
          } else {
            result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("GetInfo", Thrift.MessageType.EXCEPTION, seqid);
          }
          result_obj.write(output);
          output.writeMessageEnd();
          output.flush();
        });
      }
    };
    TCLIServiceProcessor.prototype.process_ExecuteStatement = function(seqid, input, output) {
      var args = new TCLIService_ExecuteStatement_args();
      args.read(input);
      input.readMessageEnd();
      if (this._handler.ExecuteStatement.length === 1) {
        Q.fcall(
          this._handler.ExecuteStatement.bind(this._handler),
          args.req
        ).then(function(result) {
          var result_obj = new TCLIService_ExecuteStatement_result({ success: result });
          output.writeMessageBegin("ExecuteStatement", Thrift.MessageType.REPLY, seqid);
          result_obj.write(output);
          output.writeMessageEnd();
          output.flush();
        }).catch(function(err) {
          var result;
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("ExecuteStatement", Thrift.MessageType.EXCEPTION, seqid);
          result.write(output);
          output.writeMessageEnd();
          output.flush();
        });
      } else {
        this._handler.ExecuteStatement(args.req, function(err, result) {
          var result_obj;
          if (err === null || typeof err === "undefined") {
            result_obj = new TCLIService_ExecuteStatement_result(err !== null || typeof err === "undefined" ? err : { success: result });
            output.writeMessageBegin("ExecuteStatement", Thrift.MessageType.REPLY, seqid);
          } else {
            result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("ExecuteStatement", Thrift.MessageType.EXCEPTION, seqid);
          }
          result_obj.write(output);
          output.writeMessageEnd();
          output.flush();
        });
      }
    };
    TCLIServiceProcessor.prototype.process_GetTypeInfo = function(seqid, input, output) {
      var args = new TCLIService_GetTypeInfo_args();
      args.read(input);
      input.readMessageEnd();
      if (this._handler.GetTypeInfo.length === 1) {
        Q.fcall(
          this._handler.GetTypeInfo.bind(this._handler),
          args.req
        ).then(function(result) {
          var result_obj = new TCLIService_GetTypeInfo_result({ success: result });
          output.writeMessageBegin("GetTypeInfo", Thrift.MessageType.REPLY, seqid);
          result_obj.write(output);
          output.writeMessageEnd();
          output.flush();
        }).catch(function(err) {
          var result;
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("GetTypeInfo", Thrift.MessageType.EXCEPTION, seqid);
          result.write(output);
          output.writeMessageEnd();
          output.flush();
        });
      } else {
        this._handler.GetTypeInfo(args.req, function(err, result) {
          var result_obj;
          if (err === null || typeof err === "undefined") {
            result_obj = new TCLIService_GetTypeInfo_result(err !== null || typeof err === "undefined" ? err : { success: result });
            output.writeMessageBegin("GetTypeInfo", Thrift.MessageType.REPLY, seqid);
          } else {
            result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("GetTypeInfo", Thrift.MessageType.EXCEPTION, seqid);
          }
          result_obj.write(output);
          output.writeMessageEnd();
          output.flush();
        });
      }
    };
    TCLIServiceProcessor.prototype.process_GetCatalogs = function(seqid, input, output) {
      var args = new TCLIService_GetCatalogs_args();
      args.read(input);
      input.readMessageEnd();
      if (this._handler.GetCatalogs.length === 1) {
        Q.fcall(
          this._handler.GetCatalogs.bind(this._handler),
          args.req
        ).then(function(result) {
          var result_obj = new TCLIService_GetCatalogs_result({ success: result });
          output.writeMessageBegin("GetCatalogs", Thrift.MessageType.REPLY, seqid);
          result_obj.write(output);
          output.writeMessageEnd();
          output.flush();
        }).catch(function(err) {
          var result;
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("GetCatalogs", Thrift.MessageType.EXCEPTION, seqid);
          result.write(output);
          output.writeMessageEnd();
          output.flush();
        });
      } else {
        this._handler.GetCatalogs(args.req, function(err, result) {
          var result_obj;
          if (err === null || typeof err === "undefined") {
            result_obj = new TCLIService_GetCatalogs_result(err !== null || typeof err === "undefined" ? err : { success: result });
            output.writeMessageBegin("GetCatalogs", Thrift.MessageType.REPLY, seqid);
          } else {
            result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("GetCatalogs", Thrift.MessageType.EXCEPTION, seqid);
          }
          result_obj.write(output);
          output.writeMessageEnd();
          output.flush();
        });
      }
    };
    TCLIServiceProcessor.prototype.process_GetSchemas = function(seqid, input, output) {
      var args = new TCLIService_GetSchemas_args();
      args.read(input);
      input.readMessageEnd();
      if (this._handler.GetSchemas.length === 1) {
        Q.fcall(
          this._handler.GetSchemas.bind(this._handler),
          args.req
        ).then(function(result) {
          var result_obj = new TCLIService_GetSchemas_result({ success: result });
          output.writeMessageBegin("GetSchemas", Thrift.MessageType.REPLY, seqid);
          result_obj.write(output);
          output.writeMessageEnd();
          output.flush();
        }).catch(function(err) {
          var result;
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("GetSchemas", Thrift.MessageType.EXCEPTION, seqid);
          result.write(output);
          output.writeMessageEnd();
          output.flush();
        });
      } else {
        this._handler.GetSchemas(args.req, function(err, result) {
          var result_obj;
          if (err === null || typeof err === "undefined") {
            result_obj = new TCLIService_GetSchemas_result(err !== null || typeof err === "undefined" ? err : { success: result });
            output.writeMessageBegin("GetSchemas", Thrift.MessageType.REPLY, seqid);
          } else {
            result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("GetSchemas", Thrift.MessageType.EXCEPTION, seqid);
          }
          result_obj.write(output);
          output.writeMessageEnd();
          output.flush();
        });
      }
    };
    TCLIServiceProcessor.prototype.process_GetTables = function(seqid, input, output) {
      var args = new TCLIService_GetTables_args();
      args.read(input);
      input.readMessageEnd();
      if (this._handler.GetTables.length === 1) {
        Q.fcall(
          this._handler.GetTables.bind(this._handler),
          args.req
        ).then(function(result) {
          var result_obj = new TCLIService_GetTables_result({ success: result });
          output.writeMessageBegin("GetTables", Thrift.MessageType.REPLY, seqid);
          result_obj.write(output);
          output.writeMessageEnd();
          output.flush();
        }).catch(function(err) {
          var result;
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("GetTables", Thrift.MessageType.EXCEPTION, seqid);
          result.write(output);
          output.writeMessageEnd();
          output.flush();
        });
      } else {
        this._handler.GetTables(args.req, function(err, result) {
          var result_obj;
          if (err === null || typeof err === "undefined") {
            result_obj = new TCLIService_GetTables_result(err !== null || typeof err === "undefined" ? err : { success: result });
            output.writeMessageBegin("GetTables", Thrift.MessageType.REPLY, seqid);
          } else {
            result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("GetTables", Thrift.MessageType.EXCEPTION, seqid);
          }
          result_obj.write(output);
          output.writeMessageEnd();
          output.flush();
        });
      }
    };
    TCLIServiceProcessor.prototype.process_GetTableTypes = function(seqid, input, output) {
      var args = new TCLIService_GetTableTypes_args();
      args.read(input);
      input.readMessageEnd();
      if (this._handler.GetTableTypes.length === 1) {
        Q.fcall(
          this._handler.GetTableTypes.bind(this._handler),
          args.req
        ).then(function(result) {
          var result_obj = new TCLIService_GetTableTypes_result({ success: result });
          output.writeMessageBegin("GetTableTypes", Thrift.MessageType.REPLY, seqid);
          result_obj.write(output);
          output.writeMessageEnd();
          output.flush();
        }).catch(function(err) {
          var result;
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("GetTableTypes", Thrift.MessageType.EXCEPTION, seqid);
          result.write(output);
          output.writeMessageEnd();
          output.flush();
        });
      } else {
        this._handler.GetTableTypes(args.req, function(err, result) {
          var result_obj;
          if (err === null || typeof err === "undefined") {
            result_obj = new TCLIService_GetTableTypes_result(err !== null || typeof err === "undefined" ? err : { success: result });
            output.writeMessageBegin("GetTableTypes", Thrift.MessageType.REPLY, seqid);
          } else {
            result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("GetTableTypes", Thrift.MessageType.EXCEPTION, seqid);
          }
          result_obj.write(output);
          output.writeMessageEnd();
          output.flush();
        });
      }
    };
    TCLIServiceProcessor.prototype.process_GetColumns = function(seqid, input, output) {
      var args = new TCLIService_GetColumns_args();
      args.read(input);
      input.readMessageEnd();
      if (this._handler.GetColumns.length === 1) {
        Q.fcall(
          this._handler.GetColumns.bind(this._handler),
          args.req
        ).then(function(result) {
          var result_obj = new TCLIService_GetColumns_result({ success: result });
          output.writeMessageBegin("GetColumns", Thrift.MessageType.REPLY, seqid);
          result_obj.write(output);
          output.writeMessageEnd();
          output.flush();
        }).catch(function(err) {
          var result;
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("GetColumns", Thrift.MessageType.EXCEPTION, seqid);
          result.write(output);
          output.writeMessageEnd();
          output.flush();
        });
      } else {
        this._handler.GetColumns(args.req, function(err, result) {
          var result_obj;
          if (err === null || typeof err === "undefined") {
            result_obj = new TCLIService_GetColumns_result(err !== null || typeof err === "undefined" ? err : { success: result });
            output.writeMessageBegin("GetColumns", Thrift.MessageType.REPLY, seqid);
          } else {
            result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("GetColumns", Thrift.MessageType.EXCEPTION, seqid);
          }
          result_obj.write(output);
          output.writeMessageEnd();
          output.flush();
        });
      }
    };
    TCLIServiceProcessor.prototype.process_GetFunctions = function(seqid, input, output) {
      var args = new TCLIService_GetFunctions_args();
      args.read(input);
      input.readMessageEnd();
      if (this._handler.GetFunctions.length === 1) {
        Q.fcall(
          this._handler.GetFunctions.bind(this._handler),
          args.req
        ).then(function(result) {
          var result_obj = new TCLIService_GetFunctions_result({ success: result });
          output.writeMessageBegin("GetFunctions", Thrift.MessageType.REPLY, seqid);
          result_obj.write(output);
          output.writeMessageEnd();
          output.flush();
        }).catch(function(err) {
          var result;
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("GetFunctions", Thrift.MessageType.EXCEPTION, seqid);
          result.write(output);
          output.writeMessageEnd();
          output.flush();
        });
      } else {
        this._handler.GetFunctions(args.req, function(err, result) {
          var result_obj;
          if (err === null || typeof err === "undefined") {
            result_obj = new TCLIService_GetFunctions_result(err !== null || typeof err === "undefined" ? err : { success: result });
            output.writeMessageBegin("GetFunctions", Thrift.MessageType.REPLY, seqid);
          } else {
            result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("GetFunctions", Thrift.MessageType.EXCEPTION, seqid);
          }
          result_obj.write(output);
          output.writeMessageEnd();
          output.flush();
        });
      }
    };
    TCLIServiceProcessor.prototype.process_GetPrimaryKeys = function(seqid, input, output) {
      var args = new TCLIService_GetPrimaryKeys_args();
      args.read(input);
      input.readMessageEnd();
      if (this._handler.GetPrimaryKeys.length === 1) {
        Q.fcall(
          this._handler.GetPrimaryKeys.bind(this._handler),
          args.req
        ).then(function(result) {
          var result_obj = new TCLIService_GetPrimaryKeys_result({ success: result });
          output.writeMessageBegin("GetPrimaryKeys", Thrift.MessageType.REPLY, seqid);
          result_obj.write(output);
          output.writeMessageEnd();
          output.flush();
        }).catch(function(err) {
          var result;
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("GetPrimaryKeys", Thrift.MessageType.EXCEPTION, seqid);
          result.write(output);
          output.writeMessageEnd();
          output.flush();
        });
      } else {
        this._handler.GetPrimaryKeys(args.req, function(err, result) {
          var result_obj;
          if (err === null || typeof err === "undefined") {
            result_obj = new TCLIService_GetPrimaryKeys_result(err !== null || typeof err === "undefined" ? err : { success: result });
            output.writeMessageBegin("GetPrimaryKeys", Thrift.MessageType.REPLY, seqid);
          } else {
            result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("GetPrimaryKeys", Thrift.MessageType.EXCEPTION, seqid);
          }
          result_obj.write(output);
          output.writeMessageEnd();
          output.flush();
        });
      }
    };
    TCLIServiceProcessor.prototype.process_GetCrossReference = function(seqid, input, output) {
      var args = new TCLIService_GetCrossReference_args();
      args.read(input);
      input.readMessageEnd();
      if (this._handler.GetCrossReference.length === 1) {
        Q.fcall(
          this._handler.GetCrossReference.bind(this._handler),
          args.req
        ).then(function(result) {
          var result_obj = new TCLIService_GetCrossReference_result({ success: result });
          output.writeMessageBegin("GetCrossReference", Thrift.MessageType.REPLY, seqid);
          result_obj.write(output);
          output.writeMessageEnd();
          output.flush();
        }).catch(function(err) {
          var result;
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("GetCrossReference", Thrift.MessageType.EXCEPTION, seqid);
          result.write(output);
          output.writeMessageEnd();
          output.flush();
        });
      } else {
        this._handler.GetCrossReference(args.req, function(err, result) {
          var result_obj;
          if (err === null || typeof err === "undefined") {
            result_obj = new TCLIService_GetCrossReference_result(err !== null || typeof err === "undefined" ? err : { success: result });
            output.writeMessageBegin("GetCrossReference", Thrift.MessageType.REPLY, seqid);
          } else {
            result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("GetCrossReference", Thrift.MessageType.EXCEPTION, seqid);
          }
          result_obj.write(output);
          output.writeMessageEnd();
          output.flush();
        });
      }
    };
    TCLIServiceProcessor.prototype.process_GetOperationStatus = function(seqid, input, output) {
      var args = new TCLIService_GetOperationStatus_args();
      args.read(input);
      input.readMessageEnd();
      if (this._handler.GetOperationStatus.length === 1) {
        Q.fcall(
          this._handler.GetOperationStatus.bind(this._handler),
          args.req
        ).then(function(result) {
          var result_obj = new TCLIService_GetOperationStatus_result({ success: result });
          output.writeMessageBegin("GetOperationStatus", Thrift.MessageType.REPLY, seqid);
          result_obj.write(output);
          output.writeMessageEnd();
          output.flush();
        }).catch(function(err) {
          var result;
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("GetOperationStatus", Thrift.MessageType.EXCEPTION, seqid);
          result.write(output);
          output.writeMessageEnd();
          output.flush();
        });
      } else {
        this._handler.GetOperationStatus(args.req, function(err, result) {
          var result_obj;
          if (err === null || typeof err === "undefined") {
            result_obj = new TCLIService_GetOperationStatus_result(err !== null || typeof err === "undefined" ? err : { success: result });
            output.writeMessageBegin("GetOperationStatus", Thrift.MessageType.REPLY, seqid);
          } else {
            result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("GetOperationStatus", Thrift.MessageType.EXCEPTION, seqid);
          }
          result_obj.write(output);
          output.writeMessageEnd();
          output.flush();
        });
      }
    };
    TCLIServiceProcessor.prototype.process_CancelOperation = function(seqid, input, output) {
      var args = new TCLIService_CancelOperation_args();
      args.read(input);
      input.readMessageEnd();
      if (this._handler.CancelOperation.length === 1) {
        Q.fcall(
          this._handler.CancelOperation.bind(this._handler),
          args.req
        ).then(function(result) {
          var result_obj = new TCLIService_CancelOperation_result({ success: result });
          output.writeMessageBegin("CancelOperation", Thrift.MessageType.REPLY, seqid);
          result_obj.write(output);
          output.writeMessageEnd();
          output.flush();
        }).catch(function(err) {
          var result;
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("CancelOperation", Thrift.MessageType.EXCEPTION, seqid);
          result.write(output);
          output.writeMessageEnd();
          output.flush();
        });
      } else {
        this._handler.CancelOperation(args.req, function(err, result) {
          var result_obj;
          if (err === null || typeof err === "undefined") {
            result_obj = new TCLIService_CancelOperation_result(err !== null || typeof err === "undefined" ? err : { success: result });
            output.writeMessageBegin("CancelOperation", Thrift.MessageType.REPLY, seqid);
          } else {
            result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("CancelOperation", Thrift.MessageType.EXCEPTION, seqid);
          }
          result_obj.write(output);
          output.writeMessageEnd();
          output.flush();
        });
      }
    };
    TCLIServiceProcessor.prototype.process_CloseOperation = function(seqid, input, output) {
      var args = new TCLIService_CloseOperation_args();
      args.read(input);
      input.readMessageEnd();
      if (this._handler.CloseOperation.length === 1) {
        Q.fcall(
          this._handler.CloseOperation.bind(this._handler),
          args.req
        ).then(function(result) {
          var result_obj = new TCLIService_CloseOperation_result({ success: result });
          output.writeMessageBegin("CloseOperation", Thrift.MessageType.REPLY, seqid);
          result_obj.write(output);
          output.writeMessageEnd();
          output.flush();
        }).catch(function(err) {
          var result;
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("CloseOperation", Thrift.MessageType.EXCEPTION, seqid);
          result.write(output);
          output.writeMessageEnd();
          output.flush();
        });
      } else {
        this._handler.CloseOperation(args.req, function(err, result) {
          var result_obj;
          if (err === null || typeof err === "undefined") {
            result_obj = new TCLIService_CloseOperation_result(err !== null || typeof err === "undefined" ? err : { success: result });
            output.writeMessageBegin("CloseOperation", Thrift.MessageType.REPLY, seqid);
          } else {
            result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("CloseOperation", Thrift.MessageType.EXCEPTION, seqid);
          }
          result_obj.write(output);
          output.writeMessageEnd();
          output.flush();
        });
      }
    };
    TCLIServiceProcessor.prototype.process_GetResultSetMetadata = function(seqid, input, output) {
      var args = new TCLIService_GetResultSetMetadata_args();
      args.read(input);
      input.readMessageEnd();
      if (this._handler.GetResultSetMetadata.length === 1) {
        Q.fcall(
          this._handler.GetResultSetMetadata.bind(this._handler),
          args.req
        ).then(function(result) {
          var result_obj = new TCLIService_GetResultSetMetadata_result({ success: result });
          output.writeMessageBegin("GetResultSetMetadata", Thrift.MessageType.REPLY, seqid);
          result_obj.write(output);
          output.writeMessageEnd();
          output.flush();
        }).catch(function(err) {
          var result;
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("GetResultSetMetadata", Thrift.MessageType.EXCEPTION, seqid);
          result.write(output);
          output.writeMessageEnd();
          output.flush();
        });
      } else {
        this._handler.GetResultSetMetadata(args.req, function(err, result) {
          var result_obj;
          if (err === null || typeof err === "undefined") {
            result_obj = new TCLIService_GetResultSetMetadata_result(err !== null || typeof err === "undefined" ? err : { success: result });
            output.writeMessageBegin("GetResultSetMetadata", Thrift.MessageType.REPLY, seqid);
          } else {
            result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("GetResultSetMetadata", Thrift.MessageType.EXCEPTION, seqid);
          }
          result_obj.write(output);
          output.writeMessageEnd();
          output.flush();
        });
      }
    };
    TCLIServiceProcessor.prototype.process_FetchResults = function(seqid, input, output) {
      var args = new TCLIService_FetchResults_args();
      args.read(input);
      input.readMessageEnd();
      if (this._handler.FetchResults.length === 1) {
        Q.fcall(
          this._handler.FetchResults.bind(this._handler),
          args.req
        ).then(function(result) {
          var result_obj = new TCLIService_FetchResults_result({ success: result });
          output.writeMessageBegin("FetchResults", Thrift.MessageType.REPLY, seqid);
          result_obj.write(output);
          output.writeMessageEnd();
          output.flush();
        }).catch(function(err) {
          var result;
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("FetchResults", Thrift.MessageType.EXCEPTION, seqid);
          result.write(output);
          output.writeMessageEnd();
          output.flush();
        });
      } else {
        this._handler.FetchResults(args.req, function(err, result) {
          var result_obj;
          if (err === null || typeof err === "undefined") {
            result_obj = new TCLIService_FetchResults_result(err !== null || typeof err === "undefined" ? err : { success: result });
            output.writeMessageBegin("FetchResults", Thrift.MessageType.REPLY, seqid);
          } else {
            result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("FetchResults", Thrift.MessageType.EXCEPTION, seqid);
          }
          result_obj.write(output);
          output.writeMessageEnd();
          output.flush();
        });
      }
    };
    TCLIServiceProcessor.prototype.process_GetDelegationToken = function(seqid, input, output) {
      var args = new TCLIService_GetDelegationToken_args();
      args.read(input);
      input.readMessageEnd();
      if (this._handler.GetDelegationToken.length === 1) {
        Q.fcall(
          this._handler.GetDelegationToken.bind(this._handler),
          args.req
        ).then(function(result) {
          var result_obj = new TCLIService_GetDelegationToken_result({ success: result });
          output.writeMessageBegin("GetDelegationToken", Thrift.MessageType.REPLY, seqid);
          result_obj.write(output);
          output.writeMessageEnd();
          output.flush();
        }).catch(function(err) {
          var result;
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("GetDelegationToken", Thrift.MessageType.EXCEPTION, seqid);
          result.write(output);
          output.writeMessageEnd();
          output.flush();
        });
      } else {
        this._handler.GetDelegationToken(args.req, function(err, result) {
          var result_obj;
          if (err === null || typeof err === "undefined") {
            result_obj = new TCLIService_GetDelegationToken_result(err !== null || typeof err === "undefined" ? err : { success: result });
            output.writeMessageBegin("GetDelegationToken", Thrift.MessageType.REPLY, seqid);
          } else {
            result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("GetDelegationToken", Thrift.MessageType.EXCEPTION, seqid);
          }
          result_obj.write(output);
          output.writeMessageEnd();
          output.flush();
        });
      }
    };
    TCLIServiceProcessor.prototype.process_CancelDelegationToken = function(seqid, input, output) {
      var args = new TCLIService_CancelDelegationToken_args();
      args.read(input);
      input.readMessageEnd();
      if (this._handler.CancelDelegationToken.length === 1) {
        Q.fcall(
          this._handler.CancelDelegationToken.bind(this._handler),
          args.req
        ).then(function(result) {
          var result_obj = new TCLIService_CancelDelegationToken_result({ success: result });
          output.writeMessageBegin("CancelDelegationToken", Thrift.MessageType.REPLY, seqid);
          result_obj.write(output);
          output.writeMessageEnd();
          output.flush();
        }).catch(function(err) {
          var result;
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("CancelDelegationToken", Thrift.MessageType.EXCEPTION, seqid);
          result.write(output);
          output.writeMessageEnd();
          output.flush();
        });
      } else {
        this._handler.CancelDelegationToken(args.req, function(err, result) {
          var result_obj;
          if (err === null || typeof err === "undefined") {
            result_obj = new TCLIService_CancelDelegationToken_result(err !== null || typeof err === "undefined" ? err : { success: result });
            output.writeMessageBegin("CancelDelegationToken", Thrift.MessageType.REPLY, seqid);
          } else {
            result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("CancelDelegationToken", Thrift.MessageType.EXCEPTION, seqid);
          }
          result_obj.write(output);
          output.writeMessageEnd();
          output.flush();
        });
      }
    };
    TCLIServiceProcessor.prototype.process_RenewDelegationToken = function(seqid, input, output) {
      var args = new TCLIService_RenewDelegationToken_args();
      args.read(input);
      input.readMessageEnd();
      if (this._handler.RenewDelegationToken.length === 1) {
        Q.fcall(
          this._handler.RenewDelegationToken.bind(this._handler),
          args.req
        ).then(function(result) {
          var result_obj = new TCLIService_RenewDelegationToken_result({ success: result });
          output.writeMessageBegin("RenewDelegationToken", Thrift.MessageType.REPLY, seqid);
          result_obj.write(output);
          output.writeMessageEnd();
          output.flush();
        }).catch(function(err) {
          var result;
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("RenewDelegationToken", Thrift.MessageType.EXCEPTION, seqid);
          result.write(output);
          output.writeMessageEnd();
          output.flush();
        });
      } else {
        this._handler.RenewDelegationToken(args.req, function(err, result) {
          var result_obj;
          if (err === null || typeof err === "undefined") {
            result_obj = new TCLIService_RenewDelegationToken_result(err !== null || typeof err === "undefined" ? err : { success: result });
            output.writeMessageBegin("RenewDelegationToken", Thrift.MessageType.REPLY, seqid);
          } else {
            result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("RenewDelegationToken", Thrift.MessageType.EXCEPTION, seqid);
          }
          result_obj.write(output);
          output.writeMessageEnd();
          output.flush();
        });
      }
    };
    TCLIServiceProcessor.prototype.process_GetQueryId = function(seqid, input, output) {
      var args = new TCLIService_GetQueryId_args();
      args.read(input);
      input.readMessageEnd();
      if (this._handler.GetQueryId.length === 1) {
        Q.fcall(
          this._handler.GetQueryId.bind(this._handler),
          args.req
        ).then(function(result) {
          var result_obj = new TCLIService_GetQueryId_result({ success: result });
          output.writeMessageBegin("GetQueryId", Thrift.MessageType.REPLY, seqid);
          result_obj.write(output);
          output.writeMessageEnd();
          output.flush();
        }).catch(function(err) {
          var result;
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("GetQueryId", Thrift.MessageType.EXCEPTION, seqid);
          result.write(output);
          output.writeMessageEnd();
          output.flush();
        });
      } else {
        this._handler.GetQueryId(args.req, function(err, result) {
          var result_obj;
          if (err === null || typeof err === "undefined") {
            result_obj = new TCLIService_GetQueryId_result(err !== null || typeof err === "undefined" ? err : { success: result });
            output.writeMessageBegin("GetQueryId", Thrift.MessageType.REPLY, seqid);
          } else {
            result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("GetQueryId", Thrift.MessageType.EXCEPTION, seqid);
          }
          result_obj.write(output);
          output.writeMessageEnd();
          output.flush();
        });
      }
    };
    TCLIServiceProcessor.prototype.process_SetClientInfo = function(seqid, input, output) {
      var args = new TCLIService_SetClientInfo_args();
      args.read(input);
      input.readMessageEnd();
      if (this._handler.SetClientInfo.length === 1) {
        Q.fcall(
          this._handler.SetClientInfo.bind(this._handler),
          args.req
        ).then(function(result) {
          var result_obj = new TCLIService_SetClientInfo_result({ success: result });
          output.writeMessageBegin("SetClientInfo", Thrift.MessageType.REPLY, seqid);
          result_obj.write(output);
          output.writeMessageEnd();
          output.flush();
        }).catch(function(err) {
          var result;
          result = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
          output.writeMessageBegin("SetClientInfo", Thrift.MessageType.EXCEPTION, seqid);
          result.write(output);
          output.writeMessageEnd();
          output.flush();
        });
      } else {
        this._handler.SetClientInfo(args.req, function(err, result) {
          var result_obj;
          if (err === null || typeof err === "undefined") {
            result_obj = new TCLIService_SetClientInfo_result(err !== null || typeof err === "undefined" ? err : { success: result });
            output.writeMessageBegin("SetClientInfo", Thrift.MessageType.REPLY, seqid);
          } else {
            result_obj = new Thrift.TApplicationException(Thrift.TApplicationExceptionType.UNKNOWN, err.message);
            output.writeMessageBegin("SetClientInfo", Thrift.MessageType.EXCEPTION, seqid);
          }
          result_obj.write(output);
          output.writeMessageEnd();
          output.flush();
        });
      }
    };
  }
});

// node_modules/hive-driver/dist/errors/HiveDriverError.js
var require_HiveDriverError = __commonJS({
  "node_modules/hive-driver/dist/errors/HiveDriverError.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    var HiveDriverError = function(_super) {
      __extends(HiveDriverError2, _super);
      function HiveDriverError2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return HiveDriverError2;
    }(Error);
    exports.default = HiveDriverError;
  }
});

// node_modules/hive-driver/dist/hive/Commands/BaseCommand.js
var require_BaseCommand = __commonJS({
  "node_modules/hive-driver/dist/hive/Commands/BaseCommand.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var HiveDriverError_1 = __importDefault(require_HiveDriverError());
    var BaseCommand = function() {
      function BaseCommand2(client, TCLIService_types) {
        this.client = client;
        this.TCLIService_types = TCLIService_types;
      }
      BaseCommand2.prototype.executeCommand = function(request, command) {
        var _this = this;
        return new Promise(function(resolve, reject) {
          if (typeof command !== "function") {
            return reject(new HiveDriverError_1.default("Hive driver: the operation does not exist, try to choose another Thrift file."));
          }
          try {
            command.call(_this.client, request, function(err, response) {
              if (err) {
                reject(err);
              } else {
                resolve(response);
              }
            });
          } catch (error) {
            reject(error);
          }
        });
      };
      return BaseCommand2;
    }();
    exports.default = BaseCommand;
  }
});

// node_modules/hive-driver/dist/hive/Commands/OpenSessionCommand.js
var require_OpenSessionCommand = __commonJS({
  "node_modules/hive-driver/dist/hive/Commands/OpenSessionCommand.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var BaseCommand_1 = __importDefault(require_BaseCommand());
    var OpenSessionCommand = function(_super) {
      __extends(OpenSessionCommand2, _super);
      function OpenSessionCommand2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      OpenSessionCommand2.prototype.execute = function(openSessionRequest) {
        var request = new this.TCLIService_types.TOpenSessionReq(openSessionRequest);
        return this.executeCommand(request, this.client.OpenSession);
      };
      return OpenSessionCommand2;
    }(BaseCommand_1.default);
    exports.default = OpenSessionCommand;
  }
});

// node_modules/hive-driver/dist/hive/Commands/CloseSessionCommand.js
var require_CloseSessionCommand = __commonJS({
  "node_modules/hive-driver/dist/hive/Commands/CloseSessionCommand.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var BaseCommand_1 = __importDefault(require_BaseCommand());
    var CloseSessionCommand = function(_super) {
      __extends(CloseSessionCommand2, _super);
      function CloseSessionCommand2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      CloseSessionCommand2.prototype.execute = function(openSessionRequest) {
        var request = new this.TCLIService_types.TCloseSessionReq(openSessionRequest);
        return this.executeCommand(request, this.client.CloseSession);
      };
      return CloseSessionCommand2;
    }(BaseCommand_1.default);
    exports.default = CloseSessionCommand;
  }
});

// node_modules/hive-driver/dist/hive/Commands/ExecuteStatementCommand.js
var require_ExecuteStatementCommand = __commonJS({
  "node_modules/hive-driver/dist/hive/Commands/ExecuteStatementCommand.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var BaseCommand_1 = __importDefault(require_BaseCommand());
    var ExecuteStatementCommand = function(_super) {
      __extends(ExecuteStatementCommand2, _super);
      function ExecuteStatementCommand2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      ExecuteStatementCommand2.prototype.execute = function(executeStatementRequest) {
        var request = new this.TCLIService_types.TExecuteStatementReq(executeStatementRequest);
        return this.executeCommand(request, this.client.ExecuteStatement);
      };
      return ExecuteStatementCommand2;
    }(BaseCommand_1.default);
    exports.default = ExecuteStatementCommand;
  }
});

// node_modules/hive-driver/dist/hive/Commands/GetResultSetMetadataCommand.js
var require_GetResultSetMetadataCommand = __commonJS({
  "node_modules/hive-driver/dist/hive/Commands/GetResultSetMetadataCommand.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var BaseCommand_1 = __importDefault(require_BaseCommand());
    var GetResultSetMetadataCommand = function(_super) {
      __extends(GetResultSetMetadataCommand2, _super);
      function GetResultSetMetadataCommand2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      GetResultSetMetadataCommand2.prototype.execute = function(getResultSetMetadataRequest) {
        var request = new this.TCLIService_types.TGetResultSetMetadataReq(getResultSetMetadataRequest);
        return this.executeCommand(request, this.client.GetResultSetMetadata);
      };
      return GetResultSetMetadataCommand2;
    }(BaseCommand_1.default);
    exports.default = GetResultSetMetadataCommand;
  }
});

// node_modules/hive-driver/dist/hive/Commands/FetchResultsCommand.js
var require_FetchResultsCommand = __commonJS({
  "node_modules/hive-driver/dist/hive/Commands/FetchResultsCommand.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var BaseCommand_1 = __importDefault(require_BaseCommand());
    var FetchResultsCommand = function(_super) {
      __extends(FetchResultsCommand2, _super);
      function FetchResultsCommand2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      FetchResultsCommand2.prototype.execute = function(data) {
        var request = new this.TCLIService_types.TFetchResultsReq(data);
        return this.executeCommand(request, this.client.FetchResults);
      };
      return FetchResultsCommand2;
    }(BaseCommand_1.default);
    exports.default = FetchResultsCommand;
  }
});

// node_modules/hive-driver/dist/hive/Commands/GetInfoCommand.js
var require_GetInfoCommand = __commonJS({
  "node_modules/hive-driver/dist/hive/Commands/GetInfoCommand.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var BaseCommand_1 = __importDefault(require_BaseCommand());
    var GetInfoCommand = function(_super) {
      __extends(GetInfoCommand2, _super);
      function GetInfoCommand2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      GetInfoCommand2.prototype.execute = function(data) {
        var request = new this.TCLIService_types.TGetInfoReq(data);
        return this.executeCommand(request, this.client.GetInfo);
      };
      return GetInfoCommand2;
    }(BaseCommand_1.default);
    exports.default = GetInfoCommand;
  }
});

// node_modules/hive-driver/dist/hive/Commands/GetTypeInfoCommand.js
var require_GetTypeInfoCommand = __commonJS({
  "node_modules/hive-driver/dist/hive/Commands/GetTypeInfoCommand.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var BaseCommand_1 = __importDefault(require_BaseCommand());
    var GetTypeInfoCommand = function(_super) {
      __extends(GetTypeInfoCommand2, _super);
      function GetTypeInfoCommand2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      GetTypeInfoCommand2.prototype.execute = function(data) {
        var request = new this.TCLIService_types.TGetTypeInfoReq(data);
        return this.executeCommand(request, this.client.GetTypeInfo);
      };
      return GetTypeInfoCommand2;
    }(BaseCommand_1.default);
    exports.default = GetTypeInfoCommand;
  }
});

// node_modules/hive-driver/dist/hive/Commands/GetCatalogsCommand.js
var require_GetCatalogsCommand = __commonJS({
  "node_modules/hive-driver/dist/hive/Commands/GetCatalogsCommand.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var BaseCommand_1 = __importDefault(require_BaseCommand());
    var GetCatalogsCommand = function(_super) {
      __extends(GetCatalogsCommand2, _super);
      function GetCatalogsCommand2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      GetCatalogsCommand2.prototype.execute = function(data) {
        var request = new this.TCLIService_types.TGetCatalogsReq(data);
        return this.executeCommand(request, this.client.GetCatalogs);
      };
      return GetCatalogsCommand2;
    }(BaseCommand_1.default);
    exports.default = GetCatalogsCommand;
  }
});

// node_modules/hive-driver/dist/hive/Commands/GetSchemasCommand.js
var require_GetSchemasCommand = __commonJS({
  "node_modules/hive-driver/dist/hive/Commands/GetSchemasCommand.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var BaseCommand_1 = __importDefault(require_BaseCommand());
    var GetSchemasCommand = function(_super) {
      __extends(GetSchemasCommand2, _super);
      function GetSchemasCommand2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      GetSchemasCommand2.prototype.execute = function(data) {
        var request = new this.TCLIService_types.TGetSchemasReq(data);
        return this.executeCommand(request, this.client.GetSchemas);
      };
      return GetSchemasCommand2;
    }(BaseCommand_1.default);
    exports.default = GetSchemasCommand;
  }
});

// node_modules/hive-driver/dist/hive/Commands/GetTablesCommand.js
var require_GetTablesCommand = __commonJS({
  "node_modules/hive-driver/dist/hive/Commands/GetTablesCommand.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var BaseCommand_1 = __importDefault(require_BaseCommand());
    var GetTablesCommand = function(_super) {
      __extends(GetTablesCommand2, _super);
      function GetTablesCommand2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      GetTablesCommand2.prototype.execute = function(data) {
        var request = new this.TCLIService_types.TGetTablesReq(data);
        return this.executeCommand(request, this.client.GetTables);
      };
      return GetTablesCommand2;
    }(BaseCommand_1.default);
    exports.default = GetTablesCommand;
  }
});

// node_modules/hive-driver/dist/hive/Commands/GetTableTypesCommand.js
var require_GetTableTypesCommand = __commonJS({
  "node_modules/hive-driver/dist/hive/Commands/GetTableTypesCommand.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var BaseCommand_1 = __importDefault(require_BaseCommand());
    var GetTableTypesCommand = function(_super) {
      __extends(GetTableTypesCommand2, _super);
      function GetTableTypesCommand2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      GetTableTypesCommand2.prototype.execute = function(data) {
        var request = new this.TCLIService_types.TGetTableTypesReq(data);
        return this.executeCommand(request, this.client.GetTableTypes);
      };
      return GetTableTypesCommand2;
    }(BaseCommand_1.default);
    exports.default = GetTableTypesCommand;
  }
});

// node_modules/hive-driver/dist/hive/Commands/GetColumnsCommand.js
var require_GetColumnsCommand = __commonJS({
  "node_modules/hive-driver/dist/hive/Commands/GetColumnsCommand.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var BaseCommand_1 = __importDefault(require_BaseCommand());
    var GetColumnsCommand = function(_super) {
      __extends(GetColumnsCommand2, _super);
      function GetColumnsCommand2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      GetColumnsCommand2.prototype.execute = function(data) {
        var request = new this.TCLIService_types.TGetColumnsReq(data);
        return this.executeCommand(request, this.client.GetColumns);
      };
      return GetColumnsCommand2;
    }(BaseCommand_1.default);
    exports.default = GetColumnsCommand;
  }
});

// node_modules/hive-driver/dist/hive/Commands/GetFunctionsCommand.js
var require_GetFunctionsCommand = __commonJS({
  "node_modules/hive-driver/dist/hive/Commands/GetFunctionsCommand.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var BaseCommand_1 = __importDefault(require_BaseCommand());
    var GetFunctionsCommand = function(_super) {
      __extends(GetFunctionsCommand2, _super);
      function GetFunctionsCommand2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      GetFunctionsCommand2.prototype.execute = function(data) {
        var request = new this.TCLIService_types.TGetFunctionsReq(data);
        return this.executeCommand(request, this.client.GetFunctions);
      };
      return GetFunctionsCommand2;
    }(BaseCommand_1.default);
    exports.default = GetFunctionsCommand;
  }
});

// node_modules/hive-driver/dist/hive/Commands/GetPrimaryKeysCommand.js
var require_GetPrimaryKeysCommand = __commonJS({
  "node_modules/hive-driver/dist/hive/Commands/GetPrimaryKeysCommand.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var BaseCommand_1 = __importDefault(require_BaseCommand());
    var GetPrimaryKeysCommand = function(_super) {
      __extends(GetPrimaryKeysCommand2, _super);
      function GetPrimaryKeysCommand2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      GetPrimaryKeysCommand2.prototype.execute = function(data) {
        var request = new this.TCLIService_types.TGetPrimaryKeysReq(data);
        return this.executeCommand(request, this.client.GetPrimaryKeys);
      };
      return GetPrimaryKeysCommand2;
    }(BaseCommand_1.default);
    exports.default = GetPrimaryKeysCommand;
  }
});

// node_modules/hive-driver/dist/hive/Commands/GetCrossReferenceCommand.js
var require_GetCrossReferenceCommand = __commonJS({
  "node_modules/hive-driver/dist/hive/Commands/GetCrossReferenceCommand.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var BaseCommand_1 = __importDefault(require_BaseCommand());
    var GetCrossReferenceCommand = function(_super) {
      __extends(GetCrossReferenceCommand2, _super);
      function GetCrossReferenceCommand2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      GetCrossReferenceCommand2.prototype.execute = function(data) {
        var request = new this.TCLIService_types.TGetCrossReferenceReq(data);
        return this.executeCommand(request, this.client.GetCrossReference);
      };
      return GetCrossReferenceCommand2;
    }(BaseCommand_1.default);
    exports.default = GetCrossReferenceCommand;
  }
});

// node_modules/hive-driver/dist/hive/Commands/GetOperationStatusCommand.js
var require_GetOperationStatusCommand = __commonJS({
  "node_modules/hive-driver/dist/hive/Commands/GetOperationStatusCommand.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var BaseCommand_1 = __importDefault(require_BaseCommand());
    var GetOperationStatusCommand = function(_super) {
      __extends(GetOperationStatusCommand2, _super);
      function GetOperationStatusCommand2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      GetOperationStatusCommand2.prototype.execute = function(data) {
        var request = new this.TCLIService_types.TGetOperationStatusReq(data);
        return this.executeCommand(request, this.client.GetOperationStatus);
      };
      return GetOperationStatusCommand2;
    }(BaseCommand_1.default);
    exports.default = GetOperationStatusCommand;
  }
});

// node_modules/hive-driver/dist/hive/Commands/CancelOperationCommand.js
var require_CancelOperationCommand = __commonJS({
  "node_modules/hive-driver/dist/hive/Commands/CancelOperationCommand.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var BaseCommand_1 = __importDefault(require_BaseCommand());
    var CancelOperationCommand = function(_super) {
      __extends(CancelOperationCommand2, _super);
      function CancelOperationCommand2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      CancelOperationCommand2.prototype.execute = function(data) {
        var request = new this.TCLIService_types.TCancelOperationReq(data);
        return this.executeCommand(request, this.client.CancelOperation);
      };
      return CancelOperationCommand2;
    }(BaseCommand_1.default);
    exports.default = CancelOperationCommand;
  }
});

// node_modules/hive-driver/dist/hive/Commands/CloseOperationCommand.js
var require_CloseOperationCommand = __commonJS({
  "node_modules/hive-driver/dist/hive/Commands/CloseOperationCommand.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var BaseCommand_1 = __importDefault(require_BaseCommand());
    var CloseOperationCommand = function(_super) {
      __extends(CloseOperationCommand2, _super);
      function CloseOperationCommand2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      CloseOperationCommand2.prototype.execute = function(data) {
        var request = new this.TCLIService_types.TCloseOperationReq(data);
        return this.executeCommand(request, this.client.CloseOperation);
      };
      return CloseOperationCommand2;
    }(BaseCommand_1.default);
    exports.default = CloseOperationCommand;
  }
});

// node_modules/hive-driver/dist/hive/Commands/GetDelegationTokenCommand.js
var require_GetDelegationTokenCommand = __commonJS({
  "node_modules/hive-driver/dist/hive/Commands/GetDelegationTokenCommand.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var BaseCommand_1 = __importDefault(require_BaseCommand());
    var GetDelegationTokenCommand = function(_super) {
      __extends(GetDelegationTokenCommand2, _super);
      function GetDelegationTokenCommand2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      GetDelegationTokenCommand2.prototype.execute = function(data) {
        var request = new this.TCLIService_types.TGetDelegationTokenReq(data);
        return this.executeCommand(request, this.client.GetDelegationToken);
      };
      return GetDelegationTokenCommand2;
    }(BaseCommand_1.default);
    exports.default = GetDelegationTokenCommand;
  }
});

// node_modules/hive-driver/dist/hive/Commands/CancelDelegationTokenCommand.js
var require_CancelDelegationTokenCommand = __commonJS({
  "node_modules/hive-driver/dist/hive/Commands/CancelDelegationTokenCommand.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var BaseCommand_1 = __importDefault(require_BaseCommand());
    var CancelDelegationTokenCommand = function(_super) {
      __extends(CancelDelegationTokenCommand2, _super);
      function CancelDelegationTokenCommand2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      CancelDelegationTokenCommand2.prototype.execute = function(data) {
        var request = new this.TCLIService_types.TCancelDelegationTokenReq(data);
        return this.executeCommand(request, this.client.CancelDelegationToken);
      };
      return CancelDelegationTokenCommand2;
    }(BaseCommand_1.default);
    exports.default = CancelDelegationTokenCommand;
  }
});

// node_modules/hive-driver/dist/hive/Commands/RenewDelegationTokenCommand.js
var require_RenewDelegationTokenCommand = __commonJS({
  "node_modules/hive-driver/dist/hive/Commands/RenewDelegationTokenCommand.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var BaseCommand_1 = __importDefault(require_BaseCommand());
    var RenewDelegationTokenCommand = function(_super) {
      __extends(RenewDelegationTokenCommand2, _super);
      function RenewDelegationTokenCommand2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      RenewDelegationTokenCommand2.prototype.execute = function(data) {
        var request = new this.TCLIService_types.TRenewDelegationTokenReq(data);
        return this.executeCommand(request, this.client.RenewDelegationToken);
      };
      return RenewDelegationTokenCommand2;
    }(BaseCommand_1.default);
    exports.default = RenewDelegationTokenCommand;
  }
});

// node_modules/hive-driver/dist/hive/Commands/GetQueryIdCommand.js
var require_GetQueryIdCommand = __commonJS({
  "node_modules/hive-driver/dist/hive/Commands/GetQueryIdCommand.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var BaseCommand_1 = __importDefault(require_BaseCommand());
    var GetQueryIdCommand = function(_super) {
      __extends(GetQueryIdCommand2, _super);
      function GetQueryIdCommand2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      GetQueryIdCommand2.prototype.execute = function(data) {
        var request = new this.TCLIService_types.TGetQueryIdReq(data);
        return this.executeCommand(request, this.client.GetQueryId);
      };
      return GetQueryIdCommand2;
    }(BaseCommand_1.default);
    exports.default = GetQueryIdCommand;
  }
});

// node_modules/hive-driver/dist/hive/Commands/SetClientInfoCommand.js
var require_SetClientInfoCommand = __commonJS({
  "node_modules/hive-driver/dist/hive/Commands/SetClientInfoCommand.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var BaseCommand_1 = __importDefault(require_BaseCommand());
    var SetClientInfoCommand = function(_super) {
      __extends(SetClientInfoCommand2, _super);
      function SetClientInfoCommand2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      SetClientInfoCommand2.prototype.execute = function(data) {
        var request = new this.TCLIService_types.TSetClientInfoReq(data);
        return this.executeCommand(request, this.client.SetClientInfo);
      };
      return SetClientInfoCommand2;
    }(BaseCommand_1.default);
    exports.default = SetClientInfoCommand;
  }
});

// node_modules/hive-driver/dist/hive/HiveDriver.js
var require_HiveDriver = __commonJS({
  "node_modules/hive-driver/dist/hive/HiveDriver.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var OpenSessionCommand_1 = __importDefault(require_OpenSessionCommand());
    var CloseSessionCommand_1 = __importDefault(require_CloseSessionCommand());
    var ExecuteStatementCommand_1 = __importDefault(require_ExecuteStatementCommand());
    var GetResultSetMetadataCommand_1 = __importDefault(require_GetResultSetMetadataCommand());
    var FetchResultsCommand_1 = __importDefault(require_FetchResultsCommand());
    var GetInfoCommand_1 = __importDefault(require_GetInfoCommand());
    var GetTypeInfoCommand_1 = __importDefault(require_GetTypeInfoCommand());
    var GetCatalogsCommand_1 = __importDefault(require_GetCatalogsCommand());
    var GetSchemasCommand_1 = __importDefault(require_GetSchemasCommand());
    var GetTablesCommand_1 = __importDefault(require_GetTablesCommand());
    var GetTableTypesCommand_1 = __importDefault(require_GetTableTypesCommand());
    var GetColumnsCommand_1 = __importDefault(require_GetColumnsCommand());
    var GetFunctionsCommand_1 = __importDefault(require_GetFunctionsCommand());
    var GetPrimaryKeysCommand_1 = __importDefault(require_GetPrimaryKeysCommand());
    var GetCrossReferenceCommand_1 = __importDefault(require_GetCrossReferenceCommand());
    var GetOperationStatusCommand_1 = __importDefault(require_GetOperationStatusCommand());
    var CancelOperationCommand_1 = __importDefault(require_CancelOperationCommand());
    var CloseOperationCommand_1 = __importDefault(require_CloseOperationCommand());
    var GetDelegationTokenCommand_1 = __importDefault(require_GetDelegationTokenCommand());
    var CancelDelegationTokenCommand_1 = __importDefault(require_CancelDelegationTokenCommand());
    var RenewDelegationTokenCommand_1 = __importDefault(require_RenewDelegationTokenCommand());
    var GetQueryIdCommand_1 = __importDefault(require_GetQueryIdCommand());
    var SetClientInfoCommand_1 = __importDefault(require_SetClientInfoCommand());
    var HiveDriver = function() {
      function HiveDriver2(TCLIService_types, client) {
        this.TCLIService_types = TCLIService_types;
        this.client = client;
      }
      HiveDriver2.prototype.openSession = function(request) {
        var action = new OpenSessionCommand_1.default(this.client, this.TCLIService_types);
        return action.execute(request);
      };
      HiveDriver2.prototype.closeSession = function(request) {
        var command = new CloseSessionCommand_1.default(this.client, this.TCLIService_types);
        return command.execute(request);
      };
      HiveDriver2.prototype.executeStatement = function(request) {
        var command = new ExecuteStatementCommand_1.default(this.client, this.TCLIService_types);
        return command.execute(request);
      };
      HiveDriver2.prototype.getResultSetMetadata = function(request) {
        var command = new GetResultSetMetadataCommand_1.default(this.client, this.TCLIService_types);
        return command.execute(request);
      };
      HiveDriver2.prototype.fetchResults = function(request) {
        var command = new FetchResultsCommand_1.default(this.client, this.TCLIService_types);
        return command.execute(request);
      };
      HiveDriver2.prototype.getInfo = function(request) {
        var command = new GetInfoCommand_1.default(this.client, this.TCLIService_types);
        return command.execute(request);
      };
      HiveDriver2.prototype.getTypeInfo = function(request) {
        var command = new GetTypeInfoCommand_1.default(this.client, this.TCLIService_types);
        return command.execute(request);
      };
      HiveDriver2.prototype.getCatalogs = function(request) {
        var command = new GetCatalogsCommand_1.default(this.client, this.TCLIService_types);
        return command.execute(request);
      };
      HiveDriver2.prototype.getSchemas = function(request) {
        var command = new GetSchemasCommand_1.default(this.client, this.TCLIService_types);
        return command.execute(request);
      };
      HiveDriver2.prototype.getTables = function(request) {
        var command = new GetTablesCommand_1.default(this.client, this.TCLIService_types);
        return command.execute(request);
      };
      HiveDriver2.prototype.getTableTypes = function(request) {
        var command = new GetTableTypesCommand_1.default(this.client, this.TCLIService_types);
        return command.execute(request);
      };
      HiveDriver2.prototype.getColumns = function(request) {
        var command = new GetColumnsCommand_1.default(this.client, this.TCLIService_types);
        return command.execute(request);
      };
      HiveDriver2.prototype.getFunctions = function(request) {
        var command = new GetFunctionsCommand_1.default(this.client, this.TCLIService_types);
        return command.execute(request);
      };
      HiveDriver2.prototype.getPrimaryKeys = function(request) {
        var command = new GetPrimaryKeysCommand_1.default(this.client, this.TCLIService_types);
        return command.execute(request);
      };
      HiveDriver2.prototype.getCrossReference = function(request) {
        var command = new GetCrossReferenceCommand_1.default(this.client, this.TCLIService_types);
        return command.execute(request);
      };
      HiveDriver2.prototype.getOperationStatus = function(request) {
        var command = new GetOperationStatusCommand_1.default(this.client, this.TCLIService_types);
        return command.execute(request);
      };
      HiveDriver2.prototype.cancelOperation = function(request) {
        var command = new CancelOperationCommand_1.default(this.client, this.TCLIService_types);
        return command.execute(request);
      };
      HiveDriver2.prototype.closeOperation = function(request) {
        var command = new CloseOperationCommand_1.default(this.client, this.TCLIService_types);
        return command.execute(request);
      };
      HiveDriver2.prototype.getDelegationToken = function(request) {
        var command = new GetDelegationTokenCommand_1.default(this.client, this.TCLIService_types);
        return command.execute(request);
      };
      HiveDriver2.prototype.cancelDelegationToken = function(request) {
        var command = new CancelDelegationTokenCommand_1.default(this.client, this.TCLIService_types);
        return command.execute(request);
      };
      HiveDriver2.prototype.renewDelegationToken = function(request) {
        var command = new RenewDelegationTokenCommand_1.default(this.client, this.TCLIService_types);
        return command.execute(request);
      };
      HiveDriver2.prototype.getQueryId = function(request) {
        var command = new GetQueryIdCommand_1.default(this.client, this.TCLIService_types);
        return command.execute(request);
      };
      HiveDriver2.prototype.setClientInfo = function(request) {
        var command = new SetClientInfoCommand_1.default(this.client, this.TCLIService_types);
        return command.execute(request);
      };
      return HiveDriver2;
    }();
    exports.default = HiveDriver;
  }
});

// node_modules/hive-driver/dist/hive/Types/index.js
var require_Types = __commonJS({
  "node_modules/hive-driver/dist/hive/Types/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ColumnCode = void 0;
    var ColumnCode;
    (function(ColumnCode2) {
      ColumnCode2["boolVal"] = "boolVal";
      ColumnCode2["byteVal"] = "byteVal";
      ColumnCode2["i16Val"] = "i16Val";
      ColumnCode2["i32Val"] = "i32Val";
      ColumnCode2["i64Val"] = "i64Val";
      ColumnCode2["doubleVal"] = "doubleVal";
      ColumnCode2["stringVal"] = "stringVal";
      ColumnCode2["binaryVal"] = "binaryVal";
    })(ColumnCode = exports.ColumnCode || (exports.ColumnCode = {}));
  }
});

// node_modules/hive-driver/dist/dto/Status.js
var require_Status = __commonJS({
  "node_modules/hive-driver/dist/dto/Status.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Status = function() {
      function Status2(data) {
        this.isSuccess = data.success;
        this.isExecuting = data.executing;
        this.infoMessages = data.infoMessages;
      }
      Status2.prototype.success = function() {
        return this.isSuccess;
      };
      Status2.prototype.executing = function() {
        return this.isExecuting;
      };
      Status2.prototype.getInfo = function() {
        return this.infoMessages;
      };
      return Status2;
    }();
    exports.default = Status;
  }
});

// node_modules/hive-driver/dist/errors/StatusError.js
var require_StatusError = __commonJS({
  "node_modules/hive-driver/dist/errors/StatusError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var StatusError = function() {
      function StatusError2(status) {
        this.name = "Status Error";
        this.message = status.errorMessage || "";
        this.code = status.errorCode || -1;
        if (Array.isArray(status.infoMessages)) {
          this.stack = status.infoMessages.join("\n");
        }
      }
      return StatusError2;
    }();
    exports.default = StatusError;
  }
});

// node_modules/hive-driver/dist/factory/StatusFactory.js
var require_StatusFactory = __commonJS({
  "node_modules/hive-driver/dist/factory/StatusFactory.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var Status_1 = __importDefault(require_Status());
    var StatusError_1 = __importDefault(require_StatusError());
    var StatusFactory = function() {
      function StatusFactory2(TCLIService_types) {
        this.TCLIService_types = TCLIService_types;
      }
      StatusFactory2.prototype.create = function(status) {
        if (this.isError(status)) {
          throw new StatusError_1.default(status);
        }
        return new Status_1.default({
          success: this.isSuccess(status),
          executing: this.isExecuting(status),
          infoMessages: status.infoMessages || []
        });
      };
      StatusFactory2.prototype.isSuccess = function(status) {
        return status.statusCode === this.TCLIService_types.TStatusCode.SUCCESS_STATUS || status.statusCode === this.TCLIService_types.TStatusCode.SUCCESS_WITH_INFO_STATUS;
      };
      StatusFactory2.prototype.isError = function(status) {
        return status.statusCode === this.TCLIService_types.TStatusCode.ERROR_STATUS || status.statusCode === this.TCLIService_types.TStatusCode.INVALID_HANDLE_STATUS;
      };
      StatusFactory2.prototype.isExecuting = function(status) {
        return status.statusCode === this.TCLIService_types.TStatusCode.STILL_EXECUTING_STATUS;
      };
      return StatusFactory2;
    }();
    exports.default = StatusFactory;
  }
});

// node_modules/hive-driver/dist/HiveOperation.js
var require_HiveOperation = __commonJS({
  "node_modules/hive-driver/dist/HiveOperation.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var Types_1 = require_Types();
    var StatusFactory_1 = __importDefault(require_StatusFactory());
    var HiveOperation = function() {
      function HiveOperation2(driver, operationHandle, TCLIService_type) {
        this.maxRows = 100;
        this.fetchType = 0;
        this._hasMoreRows = false;
        this.hasResultSet = false;
        this.driver = driver;
        this.operationHandle = operationHandle;
        this.hasResultSet = operationHandle.hasResultSet;
        this.TCLIService_type = TCLIService_type;
        this.statusFactory = new StatusFactory_1.default(TCLIService_type);
        this.state = TCLIService_type.TOperationState.INITIALIZED_STATE;
        this.schema = null;
        this.data = [];
      }
      HiveOperation2.prototype.fetch = function() {
        var _this = this;
        if (!this.hasResultSet) {
          return Promise.resolve(this.statusFactory.create({
            statusCode: this.TCLIService_type.TStatusCode.SUCCESS_STATUS
          }));
        }
        if (!this.finished()) {
          return Promise.resolve(this.statusFactory.create({
            statusCode: this.TCLIService_type.TStatusCode.STILL_EXECUTING_STATUS
          }));
        }
        if (this.schema === null) {
          return this.initializeSchema().then(function(schema) {
            _this.schema = schema;
            return _this.firstFetch();
          }).then(function(response) {
            return _this.processFetchResponse(response);
          });
        } else {
          return this.nextFetch().then(function(response) {
            return _this.processFetchResponse(response);
          });
        }
      };
      HiveOperation2.prototype.status = function(progress) {
        var _this = this;
        if (progress === void 0) {
          progress = false;
        }
        return this.driver.getOperationStatus({
          operationHandle: this.operationHandle,
          getProgressUpdate: progress
        }).then(function(response) {
          var _a;
          _this.statusFactory.create(response.status);
          _this.state = (_a = response.operationState) !== null && _a !== void 0 ? _a : _this.state;
          if (typeof response.hasResultSet === "boolean") {
            _this.hasResultSet = response.hasResultSet;
          }
          return response;
        });
      };
      HiveOperation2.prototype.cancel = function() {
        var _this = this;
        return this.driver.cancelOperation({
          operationHandle: this.operationHandle
        }).then(function(response) {
          return _this.statusFactory.create(response.status);
        });
      };
      HiveOperation2.prototype.close = function() {
        var _this = this;
        return this.driver.closeOperation({
          operationHandle: this.operationHandle
        }).then(function(response) {
          return _this.statusFactory.create(response.status);
        });
      };
      HiveOperation2.prototype.finished = function() {
        return this.state === this.TCLIService_type.TOperationState.FINISHED_STATE;
      };
      HiveOperation2.prototype.hasMoreRows = function() {
        return this._hasMoreRows;
      };
      HiveOperation2.prototype.setMaxRows = function(maxRows) {
        this.maxRows = maxRows;
      };
      HiveOperation2.prototype.setFetchType = function(fetchType) {
        this.fetchType = fetchType;
      };
      HiveOperation2.prototype.getSchema = function() {
        return this.schema;
      };
      HiveOperation2.prototype.getData = function() {
        return this.data;
      };
      HiveOperation2.prototype.getQueryId = function() {
        return this.driver.getQueryId({
          operationHandle: this.operationHandle
        }).then(function(response) {
          return response.queryId;
        });
      };
      HiveOperation2.prototype.flush = function() {
        this.data = [];
      };
      HiveOperation2.prototype.initializeSchema = function() {
        var _this = this;
        return this.driver.getResultSetMetadata({
          operationHandle: this.operationHandle
        }).then(function(schema) {
          _this.statusFactory.create(schema.status);
          return schema.schema;
        });
      };
      HiveOperation2.prototype.firstFetch = function() {
        return this.driver.fetchResults({
          operationHandle: this.operationHandle,
          orientation: this.TCLIService_type.TFetchOrientation.FETCH_FIRST,
          maxRows: this.maxRows,
          fetchType: this.fetchType
        });
      };
      HiveOperation2.prototype.nextFetch = function() {
        return this.driver.fetchResults({
          operationHandle: this.operationHandle,
          orientation: this.TCLIService_type.TFetchOrientation.FETCH_NEXT,
          maxRows: this.maxRows,
          fetchType: this.fetchType
        });
      };
      HiveOperation2.prototype.processFetchResponse = function(response) {
        var status = this.statusFactory.create(response.status);
        this._hasMoreRows = this.checkIfOperationHasMoreRows(response);
        if (response.results) {
          this.data.push(response.results);
        }
        return status;
      };
      HiveOperation2.prototype.checkIfOperationHasMoreRows = function(response) {
        var _a, _b;
        if (response.hasMoreRows) {
          return true;
        }
        var columns = ((_a = response.results) === null || _a === void 0 ? void 0 : _a.columns) || [];
        if (!columns.length) {
          return false;
        }
        var column = columns[0];
        var columnValue = column[Types_1.ColumnCode.binaryVal] || column[Types_1.ColumnCode.boolVal] || column[Types_1.ColumnCode.byteVal] || column[Types_1.ColumnCode.doubleVal] || column[Types_1.ColumnCode.i16Val] || column[Types_1.ColumnCode.i32Val] || column[Types_1.ColumnCode.i64Val] || column[Types_1.ColumnCode.stringVal];
        return ((_b = columnValue === null || columnValue === void 0 ? void 0 : columnValue.values) === null || _b === void 0 ? void 0 : _b.length) > 0;
      };
      return HiveOperation2;
    }();
    exports.default = HiveOperation;
  }
});

// node_modules/hive-driver/dist/dto/InfoValue.js
var require_InfoValue = __commonJS({
  "node_modules/hive-driver/dist/dto/InfoValue.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var InfoValue = function() {
      function InfoValue2(value) {
        this.value = value;
      }
      InfoValue2.prototype.getValue = function() {
        var infoValue = this.value;
        if (infoValue.stringValue) {
          return infoValue.stringValue;
        } else if (infoValue.smallIntValue) {
          return infoValue.smallIntValue;
        } else if (infoValue.integerBitmask) {
          return infoValue.integerBitmask;
        } else if (infoValue.integerFlag) {
          return infoValue.integerFlag;
        } else if (infoValue.lenValue) {
          return infoValue.lenValue;
        } else {
          return null;
        }
      };
      return InfoValue2;
    }();
    exports.default = InfoValue;
  }
});

// node_modules/hive-driver/dist/HiveSession.js
var require_HiveSession = __commonJS({
  "node_modules/hive-driver/dist/HiveSession.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var HiveOperation_1 = __importDefault(require_HiveOperation());
    var StatusFactory_1 = __importDefault(require_StatusFactory());
    var InfoValue_1 = __importDefault(require_InfoValue());
    var HiveSession = function() {
      function HiveSession2(driver, sessionHandle, TCLIService_types) {
        this.driver = driver;
        this.sessionHandle = sessionHandle;
        this.TCLIService_types = TCLIService_types;
        this.statusFactory = new StatusFactory_1.default(TCLIService_types);
      }
      HiveSession2.prototype.getInfo = function(infoType) {
        var _this = this;
        return this.driver.getInfo({
          sessionHandle: this.sessionHandle,
          infoType
        }).then(function(response) {
          _this.assertStatus(response.status);
          return new InfoValue_1.default(response.infoValue);
        });
      };
      HiveSession2.prototype.executeStatement = function(statement, options) {
        var _this = this;
        if (options === void 0) {
          options = {};
        }
        options = __assign({ runAsync: false }, options);
        return this.driver.executeStatement(__assign({ sessionHandle: this.sessionHandle, statement }, options)).then(function(response) {
          _this.assertStatus(response.status);
          return _this.createOperation(response.operationHandle);
        });
      };
      HiveSession2.prototype.getTypeInfo = function() {
        var _this = this;
        return this.driver.getTypeInfo({
          sessionHandle: this.sessionHandle
        }).then(function(response) {
          _this.assertStatus(response.status);
          return _this.createOperation(response.operationHandle);
        });
      };
      HiveSession2.prototype.getCatalogs = function() {
        var _this = this;
        return this.driver.getCatalogs({
          sessionHandle: this.sessionHandle
        }).then(function(response) {
          _this.assertStatus(response.status);
          return _this.createOperation(response.operationHandle);
        });
      };
      HiveSession2.prototype.getSchemas = function(request) {
        var _this = this;
        return this.driver.getSchemas({
          sessionHandle: this.sessionHandle,
          catalogName: request.catalogName,
          schemaName: request.schemaName
        }).then(function(response) {
          _this.assertStatus(response.status);
          return _this.createOperation(response.operationHandle);
        });
      };
      HiveSession2.prototype.getTables = function(request) {
        var _this = this;
        return this.driver.getTables({
          sessionHandle: this.sessionHandle,
          catalogName: request.catalogName,
          schemaName: request.schemaName,
          tableName: request.tableName,
          tableTypes: request.tableTypes
        }).then(function(response) {
          _this.assertStatus(response.status);
          return _this.createOperation(response.operationHandle);
        });
      };
      HiveSession2.prototype.getTableTypes = function() {
        var _this = this;
        return this.driver.getTableTypes({
          sessionHandle: this.sessionHandle
        }).then(function(response) {
          _this.assertStatus(response.status);
          return _this.createOperation(response.operationHandle);
        });
      };
      HiveSession2.prototype.getColumns = function(request) {
        var _this = this;
        return this.driver.getColumns({
          sessionHandle: this.sessionHandle,
          catalogName: request.catalogName,
          schemaName: request.schemaName,
          tableName: request.tableName,
          columnName: request.columnName
        }).then(function(response) {
          _this.assertStatus(response.status);
          return _this.createOperation(response.operationHandle);
        });
      };
      HiveSession2.prototype.getFunctions = function(request) {
        var _this = this;
        return this.driver.getFunctions({
          sessionHandle: this.sessionHandle,
          functionName: request.functionName,
          schemaName: request.schemaName,
          catalogName: request.catalogName
        }).then(function(response) {
          _this.assertStatus(response.status);
          return _this.createOperation(response.operationHandle);
        });
      };
      HiveSession2.prototype.getPrimaryKeys = function(request) {
        var _this = this;
        return this.driver.getPrimaryKeys({
          sessionHandle: this.sessionHandle,
          catalogName: request.catalogName,
          schemaName: request.schemaName,
          tableName: request.tableName
        }).then(function(response) {
          _this.assertStatus(response.status);
          return _this.createOperation(response.operationHandle);
        });
      };
      HiveSession2.prototype.getCrossReference = function(request) {
        var _this = this;
        return this.driver.getCrossReference({
          sessionHandle: this.sessionHandle,
          parentCatalogName: request.parentCatalogName,
          parentSchemaName: request.parentSchemaName,
          parentTableName: request.parentTableName,
          foreignCatalogName: request.foreignCatalogName,
          foreignSchemaName: request.foreignSchemaName,
          foreignTableName: request.foreignTableName
        }).then(function(response) {
          _this.assertStatus(response.status);
          return _this.createOperation(response.operationHandle);
        });
      };
      HiveSession2.prototype.getDelegationToken = function(owner, renewer) {
        var _this = this;
        return this.driver.getDelegationToken({
          sessionHandle: this.sessionHandle,
          owner,
          renewer
        }).then(function(response) {
          _this.assertStatus(response.status);
          return response.delegationToken || "";
        });
      };
      HiveSession2.prototype.renewDelegationToken = function(token) {
        var _this = this;
        return this.driver.renewDelegationToken({
          sessionHandle: this.sessionHandle,
          delegationToken: token
        }).then(function(response) {
          _this.assertStatus(response.status);
          return _this.statusFactory.create(response.status);
        });
      };
      HiveSession2.prototype.cancelDelegationToken = function(token) {
        var _this = this;
        return this.driver.cancelDelegationToken({
          sessionHandle: this.sessionHandle,
          delegationToken: token
        }).then(function(response) {
          _this.assertStatus(response.status);
          return _this.statusFactory.create(response.status);
        });
      };
      HiveSession2.prototype.close = function() {
        var _this = this;
        return this.driver.closeSession({
          sessionHandle: this.sessionHandle
        }).then(function(response) {
          return _this.statusFactory.create(response.status);
        });
      };
      HiveSession2.prototype.createOperation = function(handle) {
        return new HiveOperation_1.default(this.driver, handle, this.TCLIService_types);
      };
      HiveSession2.prototype.assertStatus = function(responseStatus) {
        this.statusFactory.create(responseStatus);
      };
      return HiveSession2;
    }();
    exports.default = HiveSession;
  }
});

// node_modules/hive-driver/dist/connection/auth/NoSaslAuthentication.js
var require_NoSaslAuthentication = __commonJS({
  "node_modules/hive-driver/dist/connection/auth/NoSaslAuthentication.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var thrift = require_thrift2();
    var NoSaslAuthentication = function() {
      function NoSaslAuthentication2() {
      }
      NoSaslAuthentication2.prototype.authenticate = function(transport) {
        transport.connect();
        transport.setOptions("transport", thrift.TBufferedTransport);
        return Promise.resolve(transport);
      };
      return NoSaslAuthentication2;
    }();
    exports.default = NoSaslAuthentication;
  }
});

// node_modules/hive-driver/dist/connection/transports/TlsTransport.js
var require_TlsTransport = __commonJS({
  "node_modules/hive-driver/dist/connection/transports/TlsTransport.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var tls = require("tls");
    var constants = require("constants");
    var TlsTransport = function() {
      function TlsTransport2(host, port, options) {
        if (options === void 0) {
          options = {};
        }
        this.tls = tls;
        this.host = host;
        this.port = port;
        this.tlsOptions = __assign({ secureProtocol: "SSLv23_method", secureOptions: constants.SSL_OP_NO_SSLv2 | constants.SSL_OP_NO_SSLv3, rejectUnauthorized: false, ca: options === null || options === void 0 ? void 0 : options.ca, cert: options === null || options === void 0 ? void 0 : options.cert, key: options === null || options === void 0 ? void 0 : options.key }, options);
        this.options = {};
      }
      TlsTransport2.prototype.setOptions = function(option, value) {
        var _a;
        this.options = __assign(__assign({}, this.options), (_a = {}, _a[option] = value, _a));
      };
      TlsTransport2.prototype.getOptions = function() {
        return this.options;
      };
      TlsTransport2.prototype.getTransport = function() {
        return this.connection;
      };
      TlsTransport2.prototype.connect = function() {
        this.connection = this.tls.connect(this.port, this.host, this.tlsOptions);
        this.connection.setMaxSendFragment(65536);
        this.connection.setNoDelay(true);
      };
      ;
      TlsTransport2.prototype.addListener = function(eventName, listener) {
        if (eventName === "connect") {
          return this.connection.addListener("secureConnect", listener);
        } else {
          return this.connection.addListener(eventName, listener);
        }
      };
      TlsTransport2.prototype.removeListener = function(eventName, listener) {
        if (eventName === "connect") {
          return this.connection.removeListener("secureConnect", listener);
        } else {
          return this.connection.removeListener(eventName, listener);
        }
      };
      TlsTransport2.prototype.write = function(data) {
        return this.connection.write(data);
      };
      TlsTransport2.prototype.end = function() {
        return this.connection.end();
      };
      TlsTransport2.prototype.emit = function(eventName) {
        if (eventName === "connect") {
          this.connection.emit("secureConnect");
        } else {
          this.connection.emit(eventName);
        }
      };
      return TlsTransport2;
    }();
    exports.default = TlsTransport;
  }
});

// node_modules/hive-driver/dist/connection/transports/TcpTransport.js
var require_TcpTransport = __commonJS({
  "node_modules/hive-driver/dist/connection/transports/TcpTransport.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var net = require("net");
    var TcpTransport = function() {
      function TcpTransport2(host, port) {
        this.host = host;
        this.port = port;
        this.options = {};
      }
      TcpTransport2.prototype.getTransport = function() {
        return this.connection;
      };
      TcpTransport2.prototype.setOptions = function(option, value) {
        var _a;
        this.options = __assign(__assign({}, this.options), (_a = {}, _a[option] = value, _a));
      };
      TcpTransport2.prototype.getOptions = function() {
        return this.options;
      };
      TcpTransport2.prototype.connect = function() {
        this.connection = net.createConnection(this.port, this.host);
      };
      ;
      TcpTransport2.prototype.addListener = function(eventName, listener) {
        return this.connection.addListener(eventName, listener);
      };
      TcpTransport2.prototype.removeListener = function(eventName, listener) {
        return this.connection.removeListener(eventName, listener);
      };
      TcpTransport2.prototype.write = function(data) {
        return this.connection.write(data);
      };
      TcpTransport2.prototype.end = function() {
        return this.connection.end();
      };
      TcpTransport2.prototype.emit = function(eventName) {
        this.connection.emit(eventName);
      };
      return TcpTransport2;
    }();
    exports.default = TcpTransport;
  }
});

// node_modules/hive-driver/dist/connection/connections/TcpConnection.js
var require_TcpConnection = __commonJS({
  "node_modules/hive-driver/dist/connection/connections/TcpConnection.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var thrift = require_thrift2();
    var ThriftConnection = thrift.Connection;
    var TlsTransport_1 = __importDefault(require_TlsTransport());
    var TcpTransport_1 = __importDefault(require_TcpTransport());
    var TcpConnection = function() {
      function TcpConnection2() {
      }
      TcpConnection2.prototype.connect = function(options, authProvider) {
        var _this = this;
        var _a;
        var transport = ((_a = options.options) === null || _a === void 0 ? void 0 : _a.ssl) ? new TlsTransport_1.default(options.host, options.port, __assign({}, (options === null || options === void 0 ? void 0 : options.options) || {})) : new TcpTransport_1.default(options.host, options.port);
        return authProvider.authenticate(transport).then(function(transport2) {
          _this.connection = _this.createConnection(transport2, options);
          return _this;
        });
      };
      TcpConnection2.prototype.getConnection = function() {
        return this.connection;
      };
      TcpConnection2.prototype.isConnected = function() {
        if (!this.connection) {
          return false;
        } else {
          return this.connection.connected;
        }
      };
      TcpConnection2.prototype.createConnection = function(transport, options) {
        var stream = transport.getTransport();
        var instance = new ThriftConnection(stream, __assign(__assign({ transport: thrift.TFramedTransport, protocol: thrift.TBinaryProtocol }, (options === null || options === void 0 ? void 0 : options.options) || {}), transport.getOptions()));
        instance.host = options.host;
        instance.port = options.port;
        transport.emit("connect");
        return instance;
      };
      return TcpConnection2;
    }();
    exports.default = TcpConnection;
  }
});

// node_modules/hive-driver/dist/HiveClient.js
var require_HiveClient = __commonJS({
  "node_modules/hive-driver/dist/HiveClient.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var thrift = require_thrift2();
    var HiveDriver_1 = __importDefault(require_HiveDriver());
    var HiveSession_1 = __importDefault(require_HiveSession());
    var NoSaslAuthentication_1 = __importDefault(require_NoSaslAuthentication());
    var TcpConnection_1 = __importDefault(require_TcpConnection());
    var events_1 = require("events");
    var StatusFactory_1 = __importDefault(require_StatusFactory());
    var HiveDriverError_1 = __importDefault(require_HiveDriverError());
    var HiveClient2 = function(_super) {
      __extends(HiveClient3, _super);
      function HiveClient3(TCLIService, TCLIService_types) {
        var _this = _super.call(this) || this;
        _this.thrift = thrift;
        _this.TCLIService = TCLIService;
        _this.TCLIService_types = TCLIService_types;
        _this.connectionProvider = new TcpConnection_1.default();
        _this.authProvider = new NoSaslAuthentication_1.default();
        _this.statusFactory = new StatusFactory_1.default(TCLIService_types);
        _this.client = null;
        _this.connection = null;
        return _this;
      }
      HiveClient3.prototype.connect = function(options, connectionProvider, authProvider) {
        return __awaiter(this, void 0, void 0, function() {
          var _a;
          var _this = this;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                if (connectionProvider) {
                  this.connectionProvider = connectionProvider;
                }
                if (authProvider) {
                  this.authProvider = authProvider;
                }
                _a = this;
                return [4, this.connectionProvider.connect(options, this.authProvider)];
              case 1:
                _a.connection = _b.sent();
                this.client = this.thrift.createClient(this.TCLIService, this.connection.getConnection());
                this.connection.getConnection().on("error", function(error) {
                  _this.emit("error", error);
                });
                this.connection.getConnection().on("reconnecting", function(params) {
                  _this.emit("reconnecting", params);
                });
                this.connection.getConnection().on("close", function() {
                  _this.emit("close");
                });
                this.connection.getConnection().on("timeout", function() {
                  _this.emit("timeout");
                });
                return [2, this];
            }
          });
        });
      };
      HiveClient3.prototype.openSession = function(request) {
        var _this = this;
        var _a;
        if (!((_a = this.connection) === null || _a === void 0 ? void 0 : _a.isConnected())) {
          return Promise.reject(new HiveDriverError_1.default("HiveClient: connection is lost"));
        }
        var driver = new HiveDriver_1.default(this.TCLIService_types, this.getClient());
        return driver.openSession(request).then(function(response) {
          _this.statusFactory.create(response.status);
          var session = new HiveSession_1.default(driver, response.sessionHandle, _this.TCLIService_types);
          return session;
        });
      };
      HiveClient3.prototype.getClient = function() {
        if (!this.client) {
          throw new HiveDriverError_1.default("HiveClient: client is not initialized");
        }
        return this.client;
      };
      HiveClient3.prototype.close = function() {
        if (!this.connection) {
          return;
        }
        var thriftConnection = this.connection.getConnection();
        if (typeof thriftConnection.end === "function") {
          this.connection.getConnection().end();
        }
      };
      return HiveClient3;
    }(events_1.EventEmitter);
    exports.default = HiveClient2;
  }
});

// node_modules/hive-driver/dist/errors/OperationStateError.js
var require_OperationStateError = __commonJS({
  "node_modules/hive-driver/dist/errors/OperationStateError.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var HiveDriverError_1 = __importDefault(require_HiveDriverError());
    var OperationStateError = function(_super) {
      __extends(OperationStateError2, _super);
      function OperationStateError2(message, response) {
        var _this = _super.call(this, message) || this;
        _this.response = response;
        return _this;
      }
      return OperationStateError2;
    }(HiveDriverError_1.default);
    exports.default = OperationStateError;
  }
});

// node_modules/hive-driver/dist/utils/WaitUntilReady.js
var require_WaitUntilReady = __commonJS({
  "node_modules/hive-driver/dist/utils/WaitUntilReady.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var OperationStateError_1 = __importDefault(require_OperationStateError());
    var WaitUntilReady = function() {
      function WaitUntilReady2(operation, TCLIService_types) {
        this.operation = operation;
        this.TCLIService_types = TCLIService_types;
      }
      WaitUntilReady2.prototype.execute = function(progress, callback) {
        return __awaiter(this, void 0, void 0, function() {
          var response, isReady;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, this.operation.status(Boolean(progress))];
              case 1:
                response = _a.sent();
                if (!(typeof callback === "function"))
                  return [3, 3];
                return [4, this.executeCallback(callback.bind(null, response))];
              case 2:
                _a.sent();
                _a.label = 3;
              case 3:
                try {
                  isReady = this.isReady(response);
                  if (isReady) {
                    return [2, this.operation];
                  } else {
                    return [2, this.execute(progress, callback)];
                  }
                } catch (error) {
                  throw error;
                }
                return [2];
            }
          });
        });
      };
      WaitUntilReady2.prototype.isReady = function(response) {
        switch (response.operationState) {
          case this.TCLIService_types.TOperationState.INITIALIZED_STATE:
            return false;
          case this.TCLIService_types.TOperationState.RUNNING_STATE:
            return false;
          case this.TCLIService_types.TOperationState.FINISHED_STATE:
            return true;
          case this.TCLIService_types.TOperationState.CANCELED_STATE:
            throw new OperationStateError_1.default("The operation was canceled by a client", response);
          case this.TCLIService_types.TOperationState.CLOSED_STATE:
            throw new OperationStateError_1.default("The operation was closed by a client", response);
          case this.TCLIService_types.TOperationState.ERROR_STATE:
            throw new OperationStateError_1.default("The operation failed due to an error", response);
          case this.TCLIService_types.TOperationState.PENDING_STATE:
            throw new OperationStateError_1.default("The operation is in a pending state", response);
          case this.TCLIService_types.TOperationState.TIMEDOUT_STATE:
            throw new OperationStateError_1.default("The operation is in a timedout state", response);
          case this.TCLIService_types.TOperationState.UKNOWN_STATE:
          default:
            throw new OperationStateError_1.default("The operation is in an unrecognized state", response);
        }
      };
      WaitUntilReady2.prototype.executeCallback = function(callback) {
        var result = callback();
        if (result instanceof Promise) {
          return result;
        } else {
          return Promise.resolve(result);
        }
      };
      return WaitUntilReady2;
    }();
    exports.default = WaitUntilReady;
  }
});

// node_modules/hive-driver/dist/result/NullResult.js
var require_NullResult = __commonJS({
  "node_modules/hive-driver/dist/result/NullResult.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var NullResult = function() {
      function NullResult2() {
      }
      NullResult2.prototype.setOperation = function(operation) {
      };
      NullResult2.prototype.getValue = function() {
        return null;
      };
      return NullResult2;
    }();
    exports.default = NullResult;
  }
});

// node_modules/hive-driver/dist/result/JsonResult.js
var require_JsonResult = __commonJS({
  "node_modules/hive-driver/dist/result/JsonResult.js"(exports) {
    "use strict";
    var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var Types_1 = require_Types();
    var JsonResult = function() {
      function JsonResult2(TCLIService_types) {
        this.TCLIService_types = TCLIService_types;
        this.schema = null;
        this.data = null;
      }
      JsonResult2.prototype.setOperation = function(operation) {
        this.schema = operation.getSchema();
        this.data = operation.getData();
      };
      JsonResult2.prototype.getValue = function() {
        var _this = this;
        if (!this.data) {
          return [];
        }
        var descriptors = this.getSchemaColumns();
        return this.data.reduce(function(result, rowSet) {
          var columns = rowSet.columns || [];
          var rows = _this.getRows(columns, descriptors);
          return result.concat(rows);
        }, []);
      };
      JsonResult2.prototype.getSchemaColumns = function() {
        if (!this.schema) {
          return [];
        }
        return __spreadArray([], this.schema.columns, true).sort(function(c1, c2) {
          return c1.position - c2.position;
        });
      };
      JsonResult2.prototype.getRows = function(columns, descriptors) {
        var _this = this;
        var columnStartPosition = Math.min.apply(Math, descriptors.map(function(d) {
          return d.position;
        }));
        return descriptors.reduce(function(rows, descriptor) {
          return _this.getSchemaValues(descriptor, columns[descriptor.position - columnStartPosition]).reduce(function(result, value, i) {
            if (!result[i]) {
              result[i] = {};
            }
            var name = _this.getColumnName(descriptor);
            result[i][name] = value;
            return result;
          }, rows);
        }, []);
      };
      JsonResult2.prototype.getSchemaValues = function(descriptor, column) {
        var _this = this;
        var _a;
        var typeDescriptor = ((_a = descriptor.typeDesc.types[0]) === null || _a === void 0 ? void 0 : _a.primitiveEntry) || {};
        var columnValue = this.getColumnValue(column);
        if (!columnValue) {
          return [];
        }
        return columnValue.values.map(function(value, i) {
          if (columnValue.nulls && _this.isNull(columnValue.nulls, i)) {
            return null;
          } else {
            return _this.convertData(typeDescriptor, value);
          }
        });
      };
      JsonResult2.prototype.getColumnName = function(column) {
        var name = column.columnName || "";
        return name.split(".").pop() || "";
      };
      JsonResult2.prototype.convertData = function(typeDescriptor, value) {
        switch (typeDescriptor.type) {
          case this.TCLIService_types.TTypeId.TIMESTAMP_TYPE:
          case this.TCLIService_types.TTypeId.DATE_TYPE:
          case this.TCLIService_types.TTypeId.UNION_TYPE:
          case this.TCLIService_types.TTypeId.USER_DEFINED_TYPE:
            return String(value);
          case this.TCLIService_types.TTypeId.DECIMAL_TYPE:
            return Number(value);
          case this.TCLIService_types.TTypeId.STRUCT_TYPE:
          case this.TCLIService_types.TTypeId.MAP_TYPE:
            return this.toJSON(value, {});
          case this.TCLIService_types.TTypeId.ARRAY_TYPE:
            return this.toJSON(value, []);
          case this.TCLIService_types.TTypeId.BIGINT_TYPE:
            return this.convertBigInt(value);
          case this.TCLIService_types.TTypeId.NULL_TYPE:
          case this.TCLIService_types.TTypeId.BINARY_TYPE:
          case this.TCLIService_types.TTypeId.INTERVAL_YEAR_MONTH_TYPE:
          case this.TCLIService_types.TTypeId.INTERVAL_DAY_TIME_TYPE:
          case this.TCLIService_types.TTypeId.FLOAT_TYPE:
          case this.TCLIService_types.TTypeId.DOUBLE_TYPE:
          case this.TCLIService_types.TTypeId.INT_TYPE:
          case this.TCLIService_types.TTypeId.SMALLINT_TYPE:
          case this.TCLIService_types.TTypeId.TINYINT_TYPE:
          case this.TCLIService_types.TTypeId.BOOLEAN_TYPE:
          case this.TCLIService_types.TTypeId.STRING_TYPE:
          case this.TCLIService_types.TTypeId.CHAR_TYPE:
          case this.TCLIService_types.TTypeId.VARCHAR_TYPE:
          default:
            return value;
        }
      };
      JsonResult2.prototype.isNull = function(nulls, i) {
        var byte = nulls[Math.floor(i / 8)];
        var ofs = Math.pow(2, i % 8);
        return (byte & ofs) !== 0;
      };
      JsonResult2.prototype.toJSON = function(value, defaultValue) {
        try {
          return JSON.parse(value);
        } catch (e) {
          return defaultValue;
        }
      };
      JsonResult2.prototype.convertBigInt = function(value) {
        return value.toNumber();
      };
      JsonResult2.prototype.getColumnValue = function(column) {
        return column[Types_1.ColumnCode.binaryVal] || column[Types_1.ColumnCode.boolVal] || column[Types_1.ColumnCode.byteVal] || column[Types_1.ColumnCode.doubleVal] || column[Types_1.ColumnCode.i16Val] || column[Types_1.ColumnCode.i32Val] || column[Types_1.ColumnCode.i64Val] || column[Types_1.ColumnCode.stringVal];
      };
      return JsonResult2;
    }();
    exports.default = JsonResult;
  }
});

// node_modules/hive-driver/dist/utils/GetResult.js
var require_GetResult = __commonJS({
  "node_modules/hive-driver/dist/utils/GetResult.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var NullResult_1 = __importDefault(require_NullResult());
    var JsonResult_1 = __importDefault(require_JsonResult());
    var GetResult = function() {
      function GetResult2(operation, TCLIService_types) {
        this.TCLIService_types = TCLIService_types;
        this.operation = operation;
      }
      GetResult2.prototype.execute = function(resultHandler) {
        if (!resultHandler) {
          resultHandler = this.getDefaultHandler();
        }
        resultHandler.setOperation(this.operation);
        return resultHandler;
      };
      GetResult2.prototype.getDefaultHandler = function() {
        var schema = this.operation.getSchema();
        if (schema === null) {
          return new NullResult_1.default();
        } else {
          return new JsonResult_1.default(this.TCLIService_types);
        }
      };
      return GetResult2;
    }();
    exports.default = GetResult;
  }
});

// node_modules/hive-driver/dist/utils/ProgressUpdateTransformer.js
var require_ProgressUpdateTransformer = __commonJS({
  "node_modules/hive-driver/dist/utils/ProgressUpdateTransformer.js"(exports) {
    "use strict";
    var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var ProgressUpdateTransformer = function() {
      function ProgressUpdateTransformer2(progressUpdate) {
        this.rowWidth = 10;
        this.progressUpdate = progressUpdate;
      }
      ProgressUpdateTransformer2.prototype.formatRow = function(row) {
        var _this = this;
        return row.map(function(cell) {
          return cell.padEnd(_this.rowWidth, " ");
        }).join("|");
      };
      ProgressUpdateTransformer2.prototype.toString = function() {
        var _this = this;
        var header = this.formatRow(this.progressUpdate.headerNames);
        var footer = this.progressUpdate.footerSummary;
        var rows = this.progressUpdate.rows.map(function(row) {
          return _this.formatRow(row);
        });
        return __spreadArray(__spreadArray([header], rows, true), [footer], false).join("\n");
      };
      return ProgressUpdateTransformer2;
    }();
    exports.default = ProgressUpdateTransformer;
  }
});

// node_modules/hive-driver/dist/utils/HiveUtils.js
var require_HiveUtils = __commonJS({
  "node_modules/hive-driver/dist/utils/HiveUtils.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var WaitUntilReady_1 = __importDefault(require_WaitUntilReady());
    var GetResult_1 = __importDefault(require_GetResult());
    var ProgressUpdateTransformer_1 = __importDefault(require_ProgressUpdateTransformer());
    var HiveUtils2 = function() {
      function HiveUtils3(TCLIService_types) {
        this.TCLIService_types = TCLIService_types;
      }
      HiveUtils3.prototype.waitUntilReady = function(operation, progress, callback) {
        var waitUntilReady = new WaitUntilReady_1.default(operation, this.TCLIService_types);
        return waitUntilReady.execute(progress, callback);
      };
      HiveUtils3.prototype.getResult = function(operation, resultHandler) {
        var getResult = new GetResult_1.default(operation, this.TCLIService_types);
        return getResult.execute(resultHandler);
      };
      HiveUtils3.prototype.fetchAll = function(operation) {
        var _this = this;
        return operation.fetch().then(function() {
          if (operation.hasMoreRows()) {
            return _this.fetchAll(operation);
          } else {
            return operation;
          }
        });
      };
      HiveUtils3.prototype.formatProgress = function(progressUpdate) {
        return String(new ProgressUpdateTransformer_1.default(progressUpdate));
      };
      return HiveUtils3;
    }();
    exports.default = HiveUtils2;
  }
});

// node_modules/hive-driver/dist/connection/auth/helpers/SaslPackageFactory.js
var require_SaslPackageFactory = __commonJS({
  "node_modules/hive-driver/dist/connection/auth/helpers/SaslPackageFactory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SaslPackageFactory = exports.StatusCode = void 0;
    var StatusCode;
    (function(StatusCode2) {
      StatusCode2[StatusCode2["START"] = 1] = "START";
      StatusCode2[StatusCode2["OK"] = 2] = "OK";
      StatusCode2[StatusCode2["BAD"] = 3] = "BAD";
      StatusCode2[StatusCode2["ERROR"] = 4] = "ERROR";
      StatusCode2[StatusCode2["COMPLETE"] = 5] = "COMPLETE";
    })(StatusCode = exports.StatusCode || (exports.StatusCode = {}));
    var SaslPackageFactory = function() {
      function SaslPackageFactory2() {
      }
      SaslPackageFactory2.create = function(status, body) {
        var bodyLength = Buffer.alloc(4);
        bodyLength.writeUInt32BE(body.length, 0);
        return Buffer.concat([Buffer.from([status]), bodyLength, body]);
      };
      return SaslPackageFactory2;
    }();
    exports.SaslPackageFactory = SaslPackageFactory;
  }
});

// node_modules/hive-driver/dist/errors/AuthenticationError.js
var require_AuthenticationError = __commonJS({
  "node_modules/hive-driver/dist/errors/AuthenticationError.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var HiveDriverError_1 = __importDefault(require_HiveDriverError());
    var AuthenticationError = function(_super) {
      __extends(AuthenticationError2, _super);
      function AuthenticationError2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return AuthenticationError2;
    }(HiveDriverError_1.default);
    exports.default = AuthenticationError;
  }
});

// node_modules/hive-driver/dist/connection/auth/PlainTcpAuthentication.js
var require_PlainTcpAuthentication = __commonJS({
  "node_modules/hive-driver/dist/connection/auth/PlainTcpAuthentication.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var SaslPackageFactory_1 = require_SaslPackageFactory();
    var AuthenticationError_1 = __importDefault(require_AuthenticationError());
    var PlainTcpAuthentication = function() {
      function PlainTcpAuthentication2(authOptions) {
        this.username = (authOptions === null || authOptions === void 0 ? void 0 : authOptions.username) || "anonymous";
        if ((authOptions === null || authOptions === void 0 ? void 0 : authOptions.password) === void 0) {
          this.password = "anonymous";
        } else {
          this.password = authOptions === null || authOptions === void 0 ? void 0 : authOptions.password;
        }
      }
      PlainTcpAuthentication2.prototype.authenticate = function(transport) {
        var _this = this;
        return new Promise(function(resolve, reject) {
          var onConnect = function() {
            transport.write(SaslPackageFactory_1.SaslPackageFactory.create(SaslPackageFactory_1.StatusCode.START, Buffer.from(PlainTcpAuthentication2.AUTH_MECH)));
            transport.write(SaslPackageFactory_1.SaslPackageFactory.create(SaslPackageFactory_1.StatusCode.OK, Buffer.concat([
              Buffer.from(_this.username || ""),
              Buffer.from([0]),
              Buffer.from(_this.username || ""),
              Buffer.from([0]),
              Buffer.from(_this.password || "")
            ])));
          };
          var onData = function(data) {
            var result = data[0];
            if (result === SaslPackageFactory_1.StatusCode.COMPLETE) {
              onSuccess();
            } else {
              var message = data.slice(5).toString();
              onError(new AuthenticationError_1.default("Authentication error: " + message));
            }
          };
          var onSuccess = function() {
            transport.removeListener("connect", onConnect);
            transport.removeListener("data", onData);
            resolve(transport);
          };
          var onError = function(error) {
            transport.end();
            reject(error);
          };
          transport.connect();
          transport.addListener("connect", onConnect);
          transport.addListener("data", onData);
          transport.addListener("error", onError);
        });
      };
      PlainTcpAuthentication2.AUTH_MECH = "PLAIN";
      return PlainTcpAuthentication2;
    }();
    exports.default = PlainTcpAuthentication;
  }
});

// node_modules/hive-driver/dist/connection/auth/PlainHttpAuthentication.js
var require_PlainHttpAuthentication = __commonJS({
  "node_modules/hive-driver/dist/connection/auth/PlainHttpAuthentication.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var PlainHttpAuthentication = function() {
      function PlainHttpAuthentication2(options) {
        this.username = (options === null || options === void 0 ? void 0 : options.username) || "anonymous";
        this.password = (options === null || options === void 0 ? void 0 : options.password) !== void 0 ? options === null || options === void 0 ? void 0 : options.password : "anonymous";
        this.headers = (options === null || options === void 0 ? void 0 : options.headers) || {};
      }
      PlainHttpAuthentication2.prototype.authenticate = function(transport) {
        transport.setOptions("headers", __assign(__assign({}, this.headers), { Authorization: this.getToken(this.username, this.password) }));
        return Promise.resolve(transport);
      };
      PlainHttpAuthentication2.prototype.getToken = function(username, password) {
        return "Basic " + Buffer.from("".concat(username, ":").concat(password)).toString("base64");
      };
      return PlainHttpAuthentication2;
    }();
    exports.default = PlainHttpAuthentication;
  }
});

// node_modules/hive-driver/dist/connection/auth/KerberosTcpAuthentication.js
var require_KerberosTcpAuthentication = __commonJS({
  "node_modules/hive-driver/dist/connection/auth/KerberosTcpAuthentication.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var SaslPackageFactory_1 = require_SaslPackageFactory();
    var AuthenticationError_1 = __importDefault(require_AuthenticationError());
    var KerberosTcpAuthentication = function() {
      function KerberosTcpAuthentication2(options, authProcess) {
        this.username = (options === null || options === void 0 ? void 0 : options.username) || "anonymous";
        this.password = (options === null || options === void 0 ? void 0 : options.password) !== void 0 ? options.password : "anonymous";
        this.authProcess = authProcess;
      }
      KerberosTcpAuthentication2.prototype.authenticate = function(transport) {
        var _this = this;
        return new Promise(function(resolve, reject) {
          _this.authProcess.init({
            password: _this.password,
            username: _this.username
          }, function(error, client) {
            if (error) {
              return reject(error);
            }
            var onError = function(err) {
              transport.end();
              reject(err);
            };
            var onSuccess = function() {
              transport.removeListener("connect", onConnect);
              transport.removeListener("data", onData);
              resolve(transport);
            };
            var onConnect = function() {
              _this.onConnect(transport).catch(onError);
            };
            var onData = function(data) {
              var status = data[0];
              if (status === SaslPackageFactory_1.StatusCode.OK) {
                _this.nextTransition(transport, data).catch(onError);
              } else if (status === SaslPackageFactory_1.StatusCode.COMPLETE) {
                onSuccess();
              } else {
                var message = data.slice(5).toString();
                onError(new AuthenticationError_1.default("Authentication error: " + message));
              }
            };
            transport.connect();
            transport.addListener("connect", onConnect);
            transport.addListener("data", onData);
            transport.addListener("error", onError);
          });
        });
      };
      KerberosTcpAuthentication2.prototype.onConnect = function(transport) {
        var _this = this;
        return new Promise(function(resolve, reject) {
          transport.write(SaslPackageFactory_1.SaslPackageFactory.create(SaslPackageFactory_1.StatusCode.START, Buffer.from(KerberosTcpAuthentication2.AUTH_MECH)));
          _this.authProcess.transition("", function(err, token) {
            if (err) {
              return reject(err);
            }
            transport.write(SaslPackageFactory_1.SaslPackageFactory.create(SaslPackageFactory_1.StatusCode.OK, Buffer.from(token || "", "base64")));
            resolve();
          });
        });
      };
      KerberosTcpAuthentication2.prototype.nextTransition = function(transport, data) {
        var _this = this;
        return new Promise(function(resolve, reject) {
          var payload = data.slice(5).toString("base64");
          _this.authProcess.transition(payload, function(err, response) {
            if (err) {
              return reject(err);
            }
            transport.write(SaslPackageFactory_1.SaslPackageFactory.create(SaslPackageFactory_1.StatusCode.OK, Buffer.from(response || "", "base64")));
            resolve();
          });
        });
      };
      KerberosTcpAuthentication2.AUTH_MECH = "GSSAPI";
      return KerberosTcpAuthentication2;
    }();
    exports.default = KerberosTcpAuthentication;
  }
});

// node_modules/hive-driver/dist/connection/auth/KerberosHttpAuthentication.js
var require_KerberosHttpAuthentication = __commonJS({
  "node_modules/hive-driver/dist/connection/auth/KerberosHttpAuthentication.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var KerberosHttpAuthentication = function() {
      function KerberosHttpAuthentication2(options, authProcess) {
        this.username = (options === null || options === void 0 ? void 0 : options.username) || "anonymous";
        this.password = (options === null || options === void 0 ? void 0 : options.password) !== void 0 ? options.password : "anonymous";
        this.headers = (options === null || options === void 0 ? void 0 : options.headers) || {};
        this.authProcess = authProcess;
      }
      KerberosHttpAuthentication2.prototype.authenticate = function(transport) {
        var _this = this;
        return new Promise(function(resolve, reject) {
          _this.authProcess.init({
            username: _this.username,
            password: _this.password,
            http: true
          }, function(error, client) {
            if (error) {
              return reject(error);
            }
            client.step("", function(error2, token) {
              if (error2) {
                return reject(error2);
              }
              transport.setOptions("headers", __assign(__assign({}, _this.headers), { Authorization: "Negotiate : " + token }));
              resolve(transport);
            });
          });
        });
      };
      return KerberosHttpAuthentication2;
    }();
    exports.default = KerberosHttpAuthentication;
  }
});

// node_modules/hive-driver/dist/connection/contracts/IKerberosAuthProcess.js
var require_IKerberosAuthProcess = __commonJS({
  "node_modules/hive-driver/dist/connection/contracts/IKerberosAuthProcess.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QOP = void 0;
    var QOP;
    (function(QOP2) {
      QOP2[QOP2["AUTH"] = 1] = "AUTH";
      QOP2[QOP2["AUTH_INTEGRITY"] = 2] = "AUTH_INTEGRITY";
      QOP2[QOP2["AUTH_CONFIDENTIALITY"] = 4] = "AUTH_CONFIDENTIALITY";
    })(QOP = exports.QOP || (exports.QOP = {}));
  }
});

// node_modules/hive-driver/dist/errors/KerberosError.js
var require_KerberosError = __commonJS({
  "node_modules/hive-driver/dist/errors/KerberosError.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var HiveDriverError_1 = __importDefault(require_HiveDriverError());
    var KerberosError = function(_super) {
      __extends(KerberosError2, _super);
      function KerberosError2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return KerberosError2;
    }(HiveDriverError_1.default);
    exports.default = KerberosError;
  }
});

// node_modules/hive-driver/dist/connection/auth/helpers/KerberosStep.js
var require_KerberosStep = __commonJS({
  "node_modules/hive-driver/dist/connection/auth/helpers/KerberosStep.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.KerberosStep = void 0;
    var KerberosError_1 = __importDefault(require_KerberosError());
    var TransitionState;
    (function(TransitionState2) {
      TransitionState2[TransitionState2["STEP_1"] = 0] = "STEP_1";
      TransitionState2[TransitionState2["STEP_2"] = 1] = "STEP_2";
      TransitionState2[TransitionState2["STEP_3"] = 2] = "STEP_3";
      TransitionState2[TransitionState2["STEP_4"] = 3] = "STEP_4";
    })(TransitionState || (TransitionState = {}));
    var KerberosStep = function() {
      function KerberosStep2(client, options) {
        this.step = TransitionState.STEP_1;
        this.client = client;
        this.attempts = 10;
        this.options = options;
      }
      KerberosStep2.prototype.execute = function(payload, cb) {
        switch (this.step) {
          case TransitionState.STEP_1:
            return this.first(payload, cb);
          case TransitionState.STEP_2:
            return this.second(payload, cb);
          case TransitionState.STEP_3:
            return this.third(payload, cb);
          case TransitionState.STEP_4:
            return this.fourth(payload, cb);
          default:
            throw new KerberosError_1.default("Kerberos transition does not exist: " + this.step);
        }
      };
      KerberosStep2.prototype.first = function(payload, cb) {
        var _this = this;
        this.client.step(payload, function(error, challenge) {
          if (error) {
            cb(error);
          }
          _this.step = TransitionState.STEP_2;
          cb(null, challenge);
        });
      };
      KerberosStep2.prototype.second = function(payload, cb) {
        var _this = this;
        this.client.step(payload, function(error, challenge) {
          if (error) {
            if (_this.attempts <= 0) {
              return cb(error);
            } else {
              _this.attempts--;
              return _this.second(payload, cb);
            }
          }
          _this.step = TransitionState.STEP_3;
          cb(null, challenge);
        });
      };
      KerberosStep2.prototype.third = function(payload, cb) {
        var _this = this;
        this.client.unwrap(payload, function(error, data) {
          if (error) {
            return cb(error);
          }
          var qop = Buffer.from(data, "base64")[0];
          _this.client.wrap(data, {
            user: _this.options.username
          }, function(error2, response) {
            if (error2) {
              return cb(error2);
            }
            _this.step = TransitionState.STEP_4;
            cb(null, response, qop);
          });
        });
      };
      KerberosStep2.prototype.fourth = function(payload, cb) {
        return cb(new KerberosError_1.default("Process finished"));
      };
      return KerberosStep2;
    }();
    exports.KerberosStep = KerberosStep;
  }
});

// node_modules/hive-driver/dist/connection/auth/helpers/MongoKerberosAuthProcess.js
var require_MongoKerberosAuthProcess = __commonJS({
  "node_modules/hive-driver/dist/connection/auth/helpers/MongoKerberosAuthProcess.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var IKerberosAuthProcess_1 = require_IKerberosAuthProcess();
    var KerberosStep_1 = require_KerberosStep();
    var KerberosError_1 = __importDefault(require_KerberosError());
    var MongoKerberosAuthProcess = function() {
      function MongoKerberosAuthProcess2(options, kerberos) {
        this.kerberos = kerberos;
        this.options = options;
        this.kerberosStep = null;
        this.qop = IKerberosAuthProcess_1.QOP.AUTH;
        this.platform = process.platform;
      }
      MongoKerberosAuthProcess2.prototype.init = function(options, cb) {
        var _this = this;
        this.kerberos.initializeClient(this.getSpn(), {
          mechOID: options.http ? this.kerberos.GSS_MECH_OID_SPNEGO : this.kerberos.GSS_C_NO_OID,
          domain: this.options.fqdn,
          user: options.username,
          password: options.password
        }, function(error, client) {
          if (error) {
            return cb(error);
          }
          _this.kerberosStep = new KerberosStep_1.KerberosStep(client, options);
          cb(null, client);
        });
      };
      MongoKerberosAuthProcess2.prototype.transition = function(payload, cb) {
        var _this = this;
        if (!this.kerberosStep) {
          throw new KerberosError_1.default("Kerberos client is not initialized");
        }
        this.kerberosStep.execute(payload, function(error, challenge, qop) {
          if (error) {
            return cb(error);
          }
          if (qop) {
            _this.qop = qop;
          }
          cb(null, challenge);
        });
      };
      MongoKerberosAuthProcess2.prototype.getQOP = function() {
        return this.qop;
      };
      MongoKerberosAuthProcess2.prototype.getSpn = function() {
        return this.platform === "win32" ? "".concat(this.options.service, "/").concat(this.options.fqdn) : "".concat(this.options.service, "@").concat(this.options.fqdn);
      };
      return MongoKerberosAuthProcess2;
    }();
    exports.default = MongoKerberosAuthProcess;
  }
});

// node_modules/hive-driver/dist/connection/transports/HttpTransport.js
var require_HttpTransport = __commonJS({
  "node_modules/hive-driver/dist/connection/transports/HttpTransport.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var HttpTransport = function() {
      function HttpTransport2(httpOptions) {
        if (httpOptions === void 0) {
          httpOptions = {};
        }
        this.httpOptions = httpOptions;
      }
      HttpTransport2.prototype.getTransport = function() {
        return this.httpOptions;
      };
      HttpTransport2.prototype.setOptions = function(option, value) {
        var _a;
        this.httpOptions = __assign(__assign({}, this.httpOptions), (_a = {}, _a[option] = value, _a));
      };
      HttpTransport2.prototype.getOptions = function() {
        return this.httpOptions;
      };
      HttpTransport2.prototype.connect = function() {
      };
      ;
      HttpTransport2.prototype.addListener = function() {
      };
      HttpTransport2.prototype.removeListener = function() {
      };
      HttpTransport2.prototype.write = function() {
      };
      HttpTransport2.prototype.end = function() {
      };
      HttpTransport2.prototype.emit = function() {
      };
      return HttpTransport2;
    }();
    exports.default = HttpTransport;
  }
});

// node_modules/hive-driver/dist/connection/connections/HttpConnection.js
var require_HttpConnection = __commonJS({
  "node_modules/hive-driver/dist/connection/connections/HttpConnection.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var thrift = require_thrift2();
    var HttpTransport_1 = __importDefault(require_HttpTransport());
    var HttpConnection = function() {
      function HttpConnection2() {
        this.thrift = thrift;
      }
      HttpConnection2.prototype.connect = function(options, authProvider) {
        var _this = this;
        var _a;
        var httpTransport = new HttpTransport_1.default(__assign(__assign({ transport: thrift.TBufferedTransport, protocol: thrift.TBinaryProtocol }, options.options), { nodeOptions: __assign(__assign({}, this.getNodeOptions(options.options || {})), ((_a = options.options) === null || _a === void 0 ? void 0 : _a.nodeOptions) || {}) }));
        return authProvider.authenticate(httpTransport).then(function() {
          _this.connection = _this.thrift.createHttpConnection(options.host, options.port, httpTransport.getOptions());
          _this.addCookieHandler();
          return _this;
        });
      };
      HttpConnection2.prototype.getConnection = function() {
        return this.connection;
      };
      HttpConnection2.prototype.isConnected = function() {
        if (this.connection) {
          return true;
        } else {
          return false;
        }
      };
      HttpConnection2.prototype.getNodeOptions = function(options) {
        var ca = options.ca, cert = options.cert, key = options.key, https = options.https;
        var nodeOptions = {};
        if (ca) {
          nodeOptions.ca = ca;
        }
        if (cert) {
          nodeOptions.cert = cert;
        }
        if (key) {
          nodeOptions.key = key;
        }
        if (https) {
          nodeOptions.rejectUnauthorized = false;
        }
        return nodeOptions;
      };
      HttpConnection2.prototype.addCookieHandler = function() {
        var _this = this;
        var responseCallback = this.connection.responseCallback;
        this.connection.responseCallback = function(response) {
          if (Array.isArray(response.headers["set-cookie"])) {
            var cookie = [_this.connection.nodeOptions.headers["cookie"]];
            _this.connection.nodeOptions.headers["cookie"] = cookie.concat(response.headers["set-cookie"]).filter(Boolean).join(";");
          }
          responseCallback.call(_this.connection, response);
        };
      };
      return HttpConnection2;
    }();
    exports.default = HttpConnection;
  }
});

// node_modules/hive-driver/dist/index.js
var require_dist4 = __commonJS({
  "node_modules/hive-driver/dist/index.js"(exports) {
    "use strict";
    var __extends = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HiveUtils = exports.HiveDriver = exports.HiveClient = exports.thrift = exports.connections = exports.auth = void 0;
    var TCLIService = require_TCLIService();
    var TCLIService_types = require_TCLIService_types();
    var HiveClient_1 = __importDefault(require_HiveClient());
    var HiveDriver_1 = __importDefault(require_HiveDriver());
    var HiveUtils_1 = __importDefault(require_HiveUtils());
    var NoSaslAuthentication_1 = __importDefault(require_NoSaslAuthentication());
    var PlainTcpAuthentication_1 = __importDefault(require_PlainTcpAuthentication());
    var PlainHttpAuthentication_1 = __importDefault(require_PlainHttpAuthentication());
    var KerberosTcpAuthentication_1 = __importDefault(require_KerberosTcpAuthentication());
    var KerberosHttpAuthentication_1 = __importDefault(require_KerberosHttpAuthentication());
    var MongoKerberosAuthProcess_1 = __importDefault(require_MongoKerberosAuthProcess());
    var HttpConnection_1 = __importDefault(require_HttpConnection());
    var TcpConnection_1 = __importDefault(require_TcpConnection());
    exports.auth = {
      helpers: {
        MongoKerberosAuthProcess: MongoKerberosAuthProcess_1.default
      },
      NoSaslAuthentication: NoSaslAuthentication_1.default,
      PlainTcpAuthentication: PlainTcpAuthentication_1.default,
      PlainHttpAuthentication: PlainHttpAuthentication_1.default,
      KerberosTcpAuthentication: KerberosTcpAuthentication_1.default,
      KerberosHttpAuthentication: KerberosHttpAuthentication_1.default
    };
    exports.connections = {
      HttpConnection: HttpConnection_1.default,
      TcpConnection: TcpConnection_1.default
    };
    exports.thrift = {
      TCLIService,
      TCLIService_types
    };
    var HiveClient2 = function(_super) {
      __extends(HiveClient3, _super);
      function HiveClient3() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return HiveClient3;
    }(HiveClient_1.default);
    exports.HiveClient = HiveClient2;
    var HiveDriver = function(_super) {
      __extends(HiveDriver2, _super);
      function HiveDriver2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return HiveDriver2;
    }(HiveDriver_1.default);
    exports.HiveDriver = HiveDriver;
    var HiveUtils2 = function(_super) {
      __extends(HiveUtils3, _super);
      function HiveUtils3() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return HiveUtils3;
    }(HiveUtils_1.default);
    exports.HiveUtils = HiveUtils2;
  }
});

// src/ls/plugin.ts
var plugin_exports = {};
__export(plugin_exports, {
  default: () => plugin_default
});
module.exports = __toCommonJS(plugin_exports);

// src/ls/queries.ts
var queries_exports = {};
__export(queries_exports, {
  countRecords: () => countRecords,
  describeTable: () => describeTable,
  fetchColumns: () => fetchColumns,
  fetchDatabases: () => fetchDatabases,
  fetchFunctions: () => fetchFunctions,
  fetchRecords: () => fetchRecords,
  fetchTables: () => fetchTables,
  fetchViews: () => fetchViews,
  searchColumns: () => searchColumns,
  searchTables: () => searchTables
});
var import_factory = __toESM(require_factory());
var import_types = __toESM(require_types());
function escapeTableName(table) {
  let items = [];
  let tableObj = typeof table === "string" ? { label: table } : table;
  tableObj.schema && items.push(`\`${tableObj.schema}\``);
  items.push(`\`${tableObj.label}\``);
  return items.join(".");
}
var describeTable = import_factory.default`
  DESCRIBE ${(p) => escapeTableName(p)}
`;
var fetchColumns = import_factory.default`
${(p) => p?.table ? `SHOW COLUMNS IN ${p.tables} LIMIT ${p.limit || 100};` : ";"}
`;
var fetchRecords = import_factory.default`
SELECT *
FROM ${(p) => escapeTableName(p.table)}
LIMIT ${(p) => p.limit || 50}
OFFSET ${(p) => p.offset || 0};
`;
var countRecords = import_factory.default`
SELECT count(1) AS total
FROM ${(p) => escapeTableName(p.table)}
`;
var fetchFunctions = import_factory.default`
;`;
var fetchTablesAndViews = (type, tableType = "BASE TABLE") => import_factory.default`
SHOW TABLES ${(p) => p.search ? `LIKE '${p.search}*'` : ""};
`;
var fetchTables = fetchTablesAndViews(import_types.ContextValue.TABLE);
var fetchViews = fetchTablesAndViews(import_types.ContextValue.VIEW, "VIEW");
var fetchDatabases = import_factory.default`
SHOW DATABASES ${(p) => p.search ? `LIKE '${p.search}*'` : ""};
`;
var searchTables = import_factory.default`
SHOW TABLES ${(p) => p.search ? `LIKE '${p.search}*'` : ""};
`;
var searchColumns = import_factory.default`
${(p) => p?.tables?.length > 0 ? `SHOW COLUMNS IN ${(p2) => p2.tables?.[0]} ${(p2) => p2.search ? `LIKE '${p2.search}*'` : ""};` : ";"}
`;

// src/ls/driver.ts
var import_strip_comments = __toESM(require_strip_comments());
var import_base_driver = __toESM(require_dist2());

// src/util/internal-id.ts
var import_uuid = __toESM(require_dist3());
var internal_id_default = import_uuid.v4;

// src/ls/driver.ts
var import_hive_driver = __toESM(require_dist4());
var import_types2 = __toESM(require_types());

// src/ls/keywords.ts
var keywordsArr = [
  "ADD",
  "ADMIN",
  "AFTER",
  "ANALYZE",
  "ARCHIVE",
  "ASC",
  "BEFORE",
  "BUCKET",
  "BUCKETS",
  "CASCADE",
  "CHANGE",
  "CLUSTER",
  "CLUSTERED",
  "CLUSTERSTATUS",
  "COLLECTION",
  "COLUMNS",
  "COMMENT",
  "COMPACT",
  "COMPACTIONS",
  "COMPUTE",
  "CONCATENATE",
  "CONTINUE",
  "DATA",
  "DATABASES",
  "DATETIME",
  "DAY",
  "DBPROPERTIES",
  "DEFERRED",
  "DEFINED",
  "DELIMITED",
  "DEPENDENCY",
  "DESC",
  "DIRECTORIES",
  "DIRECTORY",
  "DISABLE",
  "DISTRIBUTE",
  "ELEM_TYPE",
  "ENABLE",
  "ESCAPED",
  "EXCLUSIVE",
  "EXPLAIN",
  "EXPORT",
  "FIELDS",
  "FILE",
  "FILEFORMAT",
  "FIRST",
  "FORMAT",
  "FORMATTED",
  "FUNCTIONS",
  "HOLD_DDLTIME",
  "HOUR",
  "IDXPROPERTIES",
  "IGNORE",
  "INDEX",
  "INDEXES",
  "INPATH",
  "INPUTDRIVER",
  "INPUTFORMAT",
  "ITEMS",
  "JAR",
  "KEYS",
  "KEY_TYPE",
  "LIMIT",
  "LINES",
  "LOAD",
  "LOCATION",
  "LOCK",
  "LOCKS",
  "LOGICAL",
  "LONG",
  "MAPJOIN",
  "MATERIALIZED",
  "METADATA",
  "MINUS",
  "MINUTE",
  "MONTH",
  "MSCK",
  "NOSCAN",
  "NO_DROP",
  "OFFLINE",
  "OPTION",
  "OUTPUTDRIVER",
  "OUTPUTFORMAT",
  "OVERWRITE",
  "OWNER",
  "PARTITIONED",
  "PARTITIONS",
  "PLUS",
  "PRETTY",
  "PRINCIPALS",
  "PROTECTION",
  "PURGE",
  "READ",
  "READONLY",
  "REBUILD",
  "RECORDREADER",
  "RECORDWRITER",
  "RELOAD",
  "RENAME",
  "REPAIR",
  "REPLACE",
  "REPLICATION",
  "RESTRICT",
  "REWRITE",
  "ROLE",
  "ROLES",
  "SCHEMA",
  "SCHEMAS",
  "SECOND",
  "SEMI",
  "SERDE",
  "SERDEPROPERTIES",
  "SERVER",
  "SETS",
  "SHARED",
  "SHOW",
  "SHOW_DATABASE",
  "SKEWED",
  "SORT",
  "SORTED",
  "SSL",
  "STATISTICS",
  "STORED",
  "STREAMTABLE",
  "STRING",
  "STRUCT",
  "TABLES",
  "TBLPROPERTIES",
  "TEMPORARY",
  "TERMINATED",
  "TINYINT",
  "TOUCH",
  "TRANSACTIONS",
  "UNARCHIVE",
  "UNDO",
  "UNIONTYPE",
  "UNLOCK",
  "UNSET",
  "UNSIGNED",
  "URI",
  "USE",
  "UTC",
  "UTCTIMESTAMP",
  "VALUE_TYPE",
  "VIEW",
  "WHILE",
  "YEAR",
  "AUTOCOMMIT",
  "ISOLATION",
  "LEVEL",
  "OFFSET",
  "SNAPSHOT",
  "TRANSACTION",
  "WORK",
  "WRITE",
  "ABORT",
  "KEY",
  "LAST",
  "NORELY",
  "NOVALIDATE",
  "NULLS",
  "RELY",
  "VALIDATE",
  "DETAIL",
  "DOW",
  "EXPRESSION",
  "OPERATOR",
  "QUARTER",
  "SUMMARY",
  "VECTORIZATION",
  "WEEK",
  "YEARS",
  "MONTHS",
  "WEEKS",
  "DAYS",
  "HOURS",
  "MINUTES",
  "SECONDS",
  "TIMESTAMPTZ",
  "ZONE",
  "ALL",
  "ALTER",
  "AND",
  "ARRAY",
  "AS",
  "AUTHORIZATION",
  "BETWEEN",
  "BIGINT",
  "BINARY",
  "BOOLEAN",
  "BOTH",
  "BY",
  "CASE",
  "CAST",
  "CHAR",
  "COLUMN",
  "CONF",
  "CREATE",
  "CROSS",
  "CUBE",
  "CURRENT",
  "CURRENT_DATE",
  "CURRENT_TIMESTAMP",
  "CURSOR",
  "DATABASE",
  "DATE",
  "DECIMAL",
  "DELETE",
  "DESCRIBE",
  "DISTINCT",
  "DOUBLE",
  "DROP",
  "ELSE",
  "END",
  "EXCHANGE",
  "EXISTS",
  "EXTENDED",
  "EXTERNAL",
  "FALSE",
  "FETCH",
  "FLOAT",
  "FOLLOWING",
  "FOR",
  "FROM",
  "FULL",
  "FUNCTION",
  "GRANT",
  "GROUP",
  "GROUPING",
  "HAVING",
  "IF",
  "IMPORT",
  "IN",
  "INNER",
  "INSERT",
  "INT",
  "INTERSECT",
  "INTERVAL",
  "INTO",
  "IS",
  "JOIN",
  "LATERAL",
  "LEFT",
  "LESS",
  "LIKE",
  "LOCAL",
  "MACRO",
  "MAP",
  "MORE",
  "NONE",
  "NOT",
  "NULL",
  "OF",
  "ON",
  "OR",
  "ORDER",
  "OUT",
  "OUTER",
  "OVER",
  "PARTIALSCAN",
  "PARTITION",
  "PERCENT",
  "PRECEDING",
  "PRESERVE",
  "PROCEDURE",
  "RANGE",
  "READS",
  "REDUCE",
  "REVOKE",
  "RIGHT",
  "ROLLUP",
  "ROW",
  "ROWS",
  "SELECT",
  "SET",
  "SMALLINT",
  "TABLE",
  "TABLESAMPLE",
  "THEN",
  "TIMESTAMP",
  "TO",
  "TRANSFORM",
  "TRIGGER",
  "TRUE",
  "TRUNCATE",
  "UNBOUNDED",
  "UNION",
  "UNIQUEJOIN",
  "UPDATE",
  "USER",
  "USING",
  "UTC_TMESTAMP",
  "VALUES",
  "VARCHAR",
  "WHEN",
  "WHERE",
  "WINDOW",
  "WITH",
  "COMMIT",
  "ONLY",
  "REGEXP",
  "RLIKE",
  "ROLLBACK",
  "START",
  "CACHE",
  "CONSTRAINT",
  "FOREIGN",
  "PRIMARY",
  "REFERENCES",
  "DAYOFWEEK",
  "EXTRACT",
  "FLOOR",
  "INTEGER",
  "PRECISION",
  "VIEWS",
  "TIME",
  "NUMERIC",
  "SYNC"
];
var keywordsCompletion = keywordsArr.reduce((agg, word) => {
  agg[word] = {
    label: word,
    detail: word,
    filterText: word,
    sortText: (["SELECT", "CREATE", "UPDATE", "DELETE"].includes(word) ? "2:" : "") + word,
    documentation: {
      value: `\`\`\`yaml
WORD: ${word}
\`\`\``,
      kind: "markdown"
    }
  };
  return agg;
}, {});

// src/ls/driver.ts
var HiveSQL = class extends import_base_driver.default {
  constructor(credentials, getWorkSpaceFolders) {
    super(credentials, getWorkSpaceFolders);
    this.credentials = credentials;
    __publicField(this, "queries", queries_exports);
    __publicField(this, "hiveClient");
    __publicField(this, "connectedHiveClient");
    __publicField(this, "hiveUtils");
    __publicField(this, "executeOneQuery", async (session, query) => {
      if (!query || !session)
        return;
      const operation = await session?.executeStatement?.(query, { runAsync: false });
      await this.hiveUtils.waitUntilReady(operation, false, () => {
      });
      const queriesResults = await this.hiveUtils.fetchAll(operation);
      await operation.close();
      const values = this.hiveUtils.getResult(operation).getValue?.();
      const columns = queriesResults?.getSchema?.()?.columns?.map?.((c) => c?.columnName) || [];
      return { queriesResults, columns, values };
    });
    __publicField(this, "query", async (queryStr, opt = {}) => {
      const removedCommentsStr = this.removeComments(queryStr);
      const queries = removedCommentsStr?.split?.(/;/g) || [];
      const session = await this.open();
      if (!session)
        return [];
      const result = [];
      for (let i = 0; i < queries.length; i++) {
        const query = queries[i];
        if (!query)
          continue;
        const { columns, values } = await this.executeOneQuery(session, queries[i]);
        try {
          result.push({
            cols: columns,
            connId: this.getId(),
            messages: [{ date: new Date(), message: `Query ok with ${values.length} results.` }],
            results: values.map((_row) => {
              const row = {};
              columns?.forEach?.((columnName) => {
                const arr = columnName?.split?.(".") || [];
                const colName = arr?.[arr?.length - 1];
                row[columnName] = _row?.[colName];
              });
              return row;
            }),
            query: query?.toString?.() || "",
            requestId: opt.requestId,
            resultId: internal_id_default()
          });
        } catch (e) {
          console.error(e);
        }
      }
      await session.close();
      return result;
    });
    __publicField(this, "commonHandleOperation", async (operation) => {
      await this.hiveUtils.waitUntilReady(operation, false, () => {
      });
      const queriesResults = await this.hiveUtils.fetchAll(operation);
      await operation.close();
      const values = this.hiveUtils.getResult(operation).getValue?.() || [];
      const columns = queriesResults?.getSchema?.()?.columns?.map?.((c) => c?.columnName) || [];
      return { queriesResults, columns, values };
    });
    __publicField(this, "completionsCache", null);
    __publicField(this, "getStaticCompletions", async () => {
      if (this.completionsCache)
        return this.completionsCache;
      this.completionsCache = {};
      const items = keywordsArr;
      items.forEach((item) => {
        this.completionsCache[item] = {
          label: item,
          detail: item,
          filterText: item,
          sortText: (["SELECT", "CREATE", "UPDATE", "DELETE"].includes(item) ? "2:" : "") + item,
          documentation: {
            value: `\`\`\`yaml
WORD: ${item}
TYPE: ${item}
\`\`\``,
            kind: "markdown"
          }
        };
      });
      return this.completionsCache;
    });
    const { TCLIService, TCLIService_types } = import_hive_driver.thrift || {};
    this.hiveClient = new import_hive_driver.HiveClient(
      TCLIService,
      TCLIService_types
    );
    this.hiveUtils = new import_hive_driver.HiveUtils(
      TCLIService_types
    );
  }
  async open() {
    if (!this.connection) {
      this.connectedHiveClient = await this.hiveClient.connect(
        {
          host: this.credentials?.host,
          port: this.credentials?.port
        },
        new import_hive_driver.connections.TcpConnection(),
        this.credentials?.username && this.credentials?.password ? new import_hive_driver.auth.PlainTcpAuthentication({
          username: this.credentials?.username,
          password: this.credentials?.password
        }) : new import_hive_driver.auth.NoSaslAuthentication()
      );
      this.connection = this.connectedHiveClient;
    }
    const { TCLIService_types } = import_hive_driver.thrift || {};
    const session = await this.connectedHiveClient.openSession({
      client_protocol: TCLIService_types.TProtocolVersion.HIVE_CLI_SERVICE_PROTOCOL_V10
    });
    return session;
  }
  async close() {
    try {
      await this.connectedHiveClient?.close?.();
    } catch (e) {
      console.error(e);
    }
    this.connection = null;
    this.connectedHiveClient = null;
    if (!this.connection)
      return Promise.resolve();
  }
  removeComments(str) {
    if (!str)
      return "";
    let stringWithoutComments = "";
    try {
      stringWithoutComments = (0, import_strip_comments.default)(str) || "";
      stringWithoutComments = str.replace(/(\/\*[^*]*\*\/)|(\/\/[^*]*)|(--[^.].*)/gm, "");
      stringWithoutComments = stringWithoutComments.replace(/^\s*\n/gm, "");
      stringWithoutComments = stringWithoutComments.replace(/^\s+/gm, "");
    } catch (e) {
      console.error(e);
    }
    return stringWithoutComments || "";
  }
  async testConnection() {
    await this.open();
  }
  async listDatabases() {
    const session = await this.open();
    const { values } = await this.executeOneQuery(session, "show databases");
    return values?.map?.((db) => ({
      type: import_types2.ContextValue.DATABASE,
      iconName: "database",
      childType: import_types2.ContextValue.SCHEMA,
      catalog: db?.[Object.keys(db || {})?.[0]],
      database: db?.[Object.keys(db || {})?.[0]],
      label: db?.[Object.keys(db || {})?.[0]],
      schema: void 0,
      isView: false
    })) || [];
  }
  async listSchemas(parent, item) {
    const session = await this.open();
    const database = parent?.catalog || parent?.database;
    const request = {
      catalogName: database
    };
    if (item?.search)
      request.schemaName = item?.search;
    const operation = await session?.getSchemas?.(request);
    const { values } = await this.commonHandleOperation(operation);
    return values?.map?.((schema) => ({
      type: import_types2.ContextValue.SCHEMA,
      iconId: "group-by-ref-type",
      childType: import_types2.ContextValue.TABLE,
      database,
      catalog: schema?.TABLE_CATALOG || database,
      label: schema?.TABLE_SCHEM,
      schema: schema?.TABLE_SCHEM,
      isView: false
    })) || [];
  }
  async listTables(parent, item) {
    const session = await this.open();
    const database = parent?.catalog || parent?.database;
    const isView = item?.childType === import_types2.ContextValue.VIEW;
    const request = {
      catalogName: database,
      schemaName: parent?.schema,
      tableTypes: isView ? ["VIEW"] : ["TABLE", "VIEW", "SYSTEM TABLE", "GLOBAL TEMPORARY", "LOCAL TEMPORARY", "ALIAS", "SYNONYM"]
    };
    if (item?.search)
      request.tableName = item?.search;
    const operation = await session?.getTables?.(request);
    const { values } = await this.commonHandleOperation(operation);
    return values?.map?.((table) => ({
      type: item?.childType || (isView ? import_types2.ContextValue.VIEW : import_types2.ContextValue.TABLE),
      iconName: isView ? "view" : "table",
      childType: import_types2.ContextValue.COLUMN,
      database,
      catalog: table?.TABLE_CAT || database,
      schema: table?.TABLE_SCHEM || parent?.schema,
      label: table?.TABLE_NAME,
      table: table?.TABLE_NAME,
      detail: table?.REMARKS,
      isView
    })) || [];
  }
  async getTable(parent, item) {
    const session = await this.open();
    const database = parent?.catalog || parent?.database;
    const request = {
      catalogName: database,
      schemaName: parent?.schema,
      tableName: parent?.table
    };
    if (item?.search)
      request.columnName = item?.search;
    const operation = await session?.getColumns?.(request);
    const { values } = await this.commonHandleOperation(operation);
    return values?.map?.((column) => ({
      type: import_types2.ContextValue.COLUMN,
      iconName: column?.IS_AUTO_INCREMENT === "YES" ? "pk" : "column",
      childType: import_types2.ContextValue.NO_CHILD,
      database: parent?.database,
      catalog: parent?.catalog,
      schema: column?.TABLE_SCHEM || parent?.schema,
      table: column?.TABLE_NAME || parent?.table,
      label: column?.COLUMN_NAME,
      column: column?.COLUMN_NAME,
      size: column?.COLUMN_SIZE,
      dataType: column?.TYPE_NAME,
      detail: `${column?.TYPE_NAME ? `${column?.TYPE_NAME} ` : ""}${column?.REMARKS || ""}`,
      isNullable: column?.IS_NULLABLE === "YES"
    })) || [];
  }
  async getChildrenForItem({ item, parent }) {
    switch (item.type) {
      case import_types2.ContextValue.CONNECTION:
      case import_types2.ContextValue.CONNECTED_CONNECTION:
        return [
          { label: "Databases", type: import_types2.ContextValue.RESOURCE_GROUP, iconId: "folder", childType: import_types2.ContextValue.DATABASE }
        ];
      case import_types2.ContextValue.DATABASE:
        return [
          { label: "Schemas", type: import_types2.ContextValue.RESOURCE_GROUP, iconId: "folder", childType: import_types2.ContextValue.SCHEMA }
        ];
      case import_types2.ContextValue.SCHEMA:
        return [
          { label: "Tables", type: import_types2.ContextValue.RESOURCE_GROUP, iconId: "folder", childType: import_types2.ContextValue.TABLE },
          { label: "Views", type: import_types2.ContextValue.RESOURCE_GROUP, iconId: "folder", childType: import_types2.ContextValue.VIEW }
        ];
      case import_types2.ContextValue.VIEW:
      case import_types2.ContextValue.MATERIALIZED_VIEW:
      case import_types2.ContextValue.TABLE:
        return this.getTable(parent, item);
      case import_types2.ContextValue.RESOURCE_GROUP:
        return this.getChildrenForGroup({ item, parent });
    }
    return [];
  }
  async getChildrenForGroup({ parent, item }) {
    switch (item.childType) {
      case import_types2.ContextValue.DATABASE:
        const databases = await this.listDatabases();
        return databases;
      case "tableCatalog":
        const tableCatalogs = await this.listDatabases();
        return tableCatalogs;
      case import_types2.ContextValue.SCHEMA:
        const schemas = await this.listSchemas(parent, item);
        return schemas;
      case import_types2.ContextValue.VIEW:
        const views = await this.listTables(parent, item);
        return views;
      case import_types2.ContextValue.TABLE:
        const tables = await this.listTables(parent, item);
        return tables;
    }
    return [];
  }
  async searchItems(itemType, search, extraParams = {}) {
    switch (itemType) {
      case import_types2.ContextValue.DATABASE:
      case "tableCatalog":
        return await this.listDatabases();
      case import_types2.ContextValue.SCHEMA:
        return await this.listSchemas({ ...extraParams }, { search });
      case import_types2.ContextValue.TABLE:
        return await this.listTables({ ...extraParams }, { search });
      case import_types2.ContextValue.COLUMN:
        const columns = [];
        if (extraParams?.tables?.length > 0) {
          for (let i = 0; i < extraParams?.tables?.length; i++) {
            const table = extraParams?.tables?.[i]?.label;
            const schema = extraParams?.tables?.[i]?.schema;
            const database = extraParams?.tables?.[i]?.database;
            const _columns = await this.getTable({ ...extraParams, database, catalog: database, schema, table }, { search });
            if (_columns?.length > 0)
              columns.push(..._columns);
          }
        }
        return columns;
    }
  }
  async showRecords(table, opt) {
    const queryStr = `SELECT * FROM ${table.label} LIMIT ${opt.limit || 200}`;
    return await this.query(queryStr, opt);
  }
};

// src/constants.ts
var DRIVER_ALIASES = [
  { displayName: "Hive", value: "Hive" }
];

// src/ls/plugin.ts
var HiveSQLDriverPlugin = {
  register(server) {
    DRIVER_ALIASES.forEach(({ value }) => {
      server.getContext().drivers.set(value, HiveSQL);
    });
  }
};
var plugin_default = HiveSQLDriverPlugin;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
/*!
 *
 * Copyright 2009-2017 Kris Kowal under the terms of the MIT
 * license found at https://github.com/kriskowal/q/blob/v1/LICENSE
 *
 * With parts by Tyler Close
 * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found
 * at http://www.opensource.org/licenses/mit-license.html
 * Forked at ref_send.js version: 2009-05-11
 *
 * With parts by Mark Miller
 * Copyright (C) 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
/*!
 * strip-comments <https://github.com/jonschlinkert/strip-comments>
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Released under the MIT License.
 */
